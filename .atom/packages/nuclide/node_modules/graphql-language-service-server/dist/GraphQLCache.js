'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLCache = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getGraphQLCache = getGraphQLCache;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphql = require('graphql');

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _kinds = require('graphql/language/kinds');

var _graphqlLanguageServiceConfig = require('graphql-language-service-config');

var _GraphQLWatchman = require('./GraphQLWatchman');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Maximum files to read when processing GraphQL files.
var MAX_READS = 200;

function getGraphQLCache(configDir) {
  var graphQLConfig, watchmanClient;
  return regeneratorRuntime.async(function getGraphQLCache$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _graphqlLanguageServiceConfig.getGraphQLConfig)(configDir));

        case 2:
          graphQLConfig = _context.sent;
          watchmanClient = new _GraphQLWatchman.GraphQLWatchman();

          watchmanClient.checkVersion();
          watchmanClient.watchProject(configDir);
          return _context.abrupt('return', new GraphQLCache(configDir, graphQLConfig, watchmanClient));

        case 7:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

var GraphQLCache = exports.GraphQLCache = function () {
  function GraphQLCache(configDir, graphQLConfig, watchmanClient) {
    _classCallCheck(this, GraphQLCache);

    _initialiseProps.call(this);

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._watchmanClient = watchmanClient || new _GraphQLWatchman.GraphQLWatchman();
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
  }

  /**
   * Subscribes to the file changes and update the cache accordingly.
   * @param `rootDir` the directory of config path
   */
  GraphQLCache.prototype._subscribeToFileChanges = function _subscribeToFileChanges(rootDir, inputDirs, excludeDirs) {
    var _this = this;

    this._watchmanClient.subscribe(this._configDir, function (result) {
      if (result.files && result.files.length > 0) {
        var _graphQLFileMap = _this._graphQLFileListCache.get(rootDir);
        if (!_graphQLFileMap) {
          return;
        }
        result.files.forEach(function _callee(_ref) {
          var name = _ref.name,
              exists = _ref.exists,
              size = _ref.size,
              mtime = _ref.mtime;
          var filePath, existingFile, fileAndContent, fragmentDefinitionCache;
          return regeneratorRuntime.async(function _callee$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(!inputDirs.some(function (dir) {
                    return name.startsWith(dir);
                  }) || excludeDirs.some(function (dir) {
                    return name.startsWith(dir);
                  }))) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt('return');

                case 2:
                  filePath = _path2.default.join(result.root, result.subscription, name);

                  // In the event of watchman recrawl (is_fresh_instance),
                  // watchman subscription returns a full set of files within the
                  // watched directory. After pruning with input/excluded directories,
                  // the file could have been created/modified.
                  // Using the cached size/mtime information, only cache the file if
                  // the file doesn't exist or the file exists and one of or both
                  // size/mtime is different.

                  if (!(result.is_fresh_instance && exists)) {
                    _context2.next = 13;
                    break;
                  }

                  existingFile = _graphQLFileMap.get(filePath);
                  // Same size/mtime means the file stayed the same

                  if (!(existingFile && existingFile.size === size && existingFile.mtime === mtime)) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt('return');

                case 7:
                  _context2.next = 9;
                  return regeneratorRuntime.awrap(promiseToReadGraphQLFile(filePath));

                case 9:
                  fileAndContent = _context2.sent;

                  _graphQLFileMap.set(filePath, _extends({}, fileAndContent, {
                    size: size,
                    mtime: mtime
                  }));
                  // Otherwise, create/update the cache with the updated file and
                  // content, or delete the cache if (!exists)
                  _context2.next = 28;
                  break;

                case 13:
                  if (!_graphQLFileMap) {
                    _context2.next = 20;
                    break;
                  }

                  _context2.t0 = _this._graphQLFileListCache;
                  _context2.t1 = rootDir;
                  _context2.next = 18;
                  return regeneratorRuntime.awrap(_this._updateGraphQLFileListCache(_graphQLFileMap, { size: size, mtime: mtime }, filePath, exists));

                case 18:
                  _context2.t2 = _context2.sent;

                  _context2.t0.set.call(_context2.t0, _context2.t1, _context2.t2);

                case 20:
                  fragmentDefinitionCache = _this._fragmentDefinitionsCache.get(rootDir);

                  if (!fragmentDefinitionCache) {
                    _context2.next = 28;
                    break;
                  }

                  _context2.t3 = _this._fragmentDefinitionsCache;
                  _context2.t4 = rootDir;
                  _context2.next = 26;
                  return regeneratorRuntime.awrap(_this._updateFragmentDefinitionCache(fragmentDefinitionCache, filePath, exists));

                case 26:
                  _context2.t5 = _context2.sent;

                  _context2.t3.set.call(_context2.t3, _context2.t4, _context2.t5);

                case 28:
                case 'end':
                  return _context2.stop();
              }
            }
          }, null, _this);
        });
      }
    });
  };

  GraphQLCache.prototype._updateGraphQLFileListCache = function _updateGraphQLFileListCache(graphQLFileMap, metrics, filePath, exists) {
    var fileAndContent, graphQLFileInfo, existingFile;
    return regeneratorRuntime.async(function _updateGraphQLFileListCache$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!exists) {
              _context3.next = 6;
              break;
            }

            _context3.next = 3;
            return regeneratorRuntime.awrap(promiseToReadGraphQLFile(filePath));

          case 3:
            _context3.t0 = _context3.sent;
            _context3.next = 7;
            break;

          case 6:
            _context3.t0 = null;

          case 7:
            fileAndContent = _context3.t0;
            graphQLFileInfo = _extends({}, fileAndContent, metrics);
            existingFile = graphQLFileMap.get(filePath);

            // 3 cases for the cache invalidation: create/modify/delete.
            // For create/modify, swap the existing entry if available;
            // otherwise, just push in the new entry created.
            // For delete, check `exists` and splice the file out.

            if (existingFile && !exists) {
              graphQLFileMap.delete(filePath);
            } else if (graphQLFileInfo) {
              graphQLFileMap.set(filePath, graphQLFileInfo);
            }

            return _context3.abrupt('return', graphQLFileMap);

          case 12:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._updateFragmentDefinitionCache = function _updateFragmentDefinitionCache(fragmentDefinitionCache, filePath, exists) {
    var fileAndContent;
    return regeneratorRuntime.async(function _updateFragmentDefinitionCache$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!exists) {
              _context4.next = 6;
              break;
            }

            _context4.next = 3;
            return regeneratorRuntime.awrap(promiseToReadGraphQLFile(filePath));

          case 3:
            _context4.t0 = _context4.sent;
            _context4.next = 7;
            break;

          case 6:
            _context4.t0 = null;

          case 7:
            fileAndContent = _context4.t0;

            // In the case of fragment definitions, the cache could just map the
            // definition name to the parsed ast, whether or not it existed
            // previously.
            // For delete, remove the entry from the set.
            // For cases where the modified content has syntax error and therefore
            // cannot be parsed, maintain the previous cache (do nothing).
            if (!exists) {
              fragmentDefinitionCache.delete(filePath);
            } else if (fileAndContent && fileAndContent.ast) {
              fileAndContent.ast.definitions.forEach(function (definition) {
                if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                  fragmentDefinitionCache.set(definition.name.value, {
                    filePath: fileAndContent.filePath,
                    content: fileAndContent.content,
                    definition: definition
                  });
                }
              });
            }

            return _context4.abrupt('return', fragmentDefinitionCache);

          case 10:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, this);
  };

  return GraphQLCache;
}();

/**
 * Given a list of GraphQL file metadata, read all files collected from watchman
 * and create fragmentDefinitions and GraphQL files cache.
 */


var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.getGraphQLConfig = function () {
    return _this2._graphQLConfig;
  };

  this.getFragmentDependencies = function _callee2(query, fragmentDefinitions) {
    var parsedQuery;
    return regeneratorRuntime.async(function _callee2$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (fragmentDefinitions) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return', []);

          case 2:
            // If the query cannot be parsed, validations cannot happen yet.
            // Return an empty array.
            parsedQuery = void 0;
            _context6.prev = 3;

            parsedQuery = (0, _graphql.parse)(query);
            _context6.next = 10;
            break;

          case 7:
            _context6.prev = 7;
            _context6.t0 = _context6['catch'](3);
            return _context6.abrupt('return', []);

          case 10:
            return _context6.abrupt('return', _this2.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions));

          case 11:
          case 'end':
            return _context6.stop();
        }
      }
    }, null, _this2, [[3, 7]]);
  };

  this.getFragmentDependenciesForAST = function _callee3(parsedQuery, fragmentDefinitions) {
    var existingFrags, referencedFragNames, asts, referencedFragments;
    return regeneratorRuntime.async(function _callee3$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (fragmentDefinitions) {
              _context7.next = 2;
              break;
            }

            return _context7.abrupt('return', []);

          case 2:
            existingFrags = new Map();
            referencedFragNames = new Set();


            (0, _graphql.visit)(parsedQuery, {
              FragmentDefinition: function FragmentDefinition(node) {
                existingFrags.set(node.name.value, true);
              },
              FragmentSpread: function FragmentSpread(node) {
                if (!referencedFragNames.has(node.name.value)) {
                  referencedFragNames.add(node.name.value);
                }
              }
            });

            asts = new Set();

            referencedFragNames.forEach(function (name) {
              if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
                asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(name)));
              }
            });

            referencedFragments = [];


            asts.forEach(function (ast) {
              (0, _graphql.visit)(ast.definition, {
                FragmentSpread: function FragmentSpread(node) {
                  if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                    asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(node.name.value)));
                    referencedFragNames.add(node.name.value);
                  }
                }
              });
              if (!existingFrags.has(ast.definition.name.value)) {
                referencedFragments.push(ast);
              }
            });

            return _context7.abrupt('return', referencedFragments);

          case 10:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, _this2);
  };

  this.getFragmentDefinitions = function _callee4(graphQLConfig, appName) {
    var rootDir, inputDirs, excludeDirs, filesFromInputDirs, list, _ref2, fragmentDefinitions, graphQLFileMap;

    return regeneratorRuntime.async(function _callee4$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            // This function may be called from other classes.
            // If then, check the cache first.
            rootDir = graphQLConfig.getRootDir();

            if (!_this2._fragmentDefinitionsCache.has(rootDir)) {
              _context8.next = 3;
              break;
            }

            return _context8.abrupt('return', _this2._fragmentDefinitionsCache.get(rootDir) || new Map());

          case 3:
            inputDirs = graphQLConfig.getIncludeDirs(appName);
            excludeDirs = graphQLConfig.getExcludeDirs(appName);
            _context8.next = 7;
            return regeneratorRuntime.awrap(_this2._watchmanClient.listFiles(rootDir, {
              path: inputDirs
            }));

          case 7:
            filesFromInputDirs = _context8.sent;
            list = filesFromInputDirs.map(function (fileInfo) {
              return {
                filePath: _path2.default.join(rootDir, fileInfo.name),
                size: fileInfo.size,
                mtime: fileInfo.mtime
              };
            }).filter(function (fileInfo) {
              return excludeDirs.every(function (exclude) {
                return !fileInfo.filePath.startsWith(_path2.default.join(rootDir, exclude));
              });
            });
            _context8.next = 11;
            return regeneratorRuntime.awrap(readAllGraphQLFiles(list));

          case 11:
            _ref2 = _context8.sent;
            fragmentDefinitions = _ref2.fragmentDefinitions;
            graphQLFileMap = _ref2.graphQLFileMap;


            _this2._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);
            _this2._graphQLFileListCache.set(rootDir, graphQLFileMap);

            _this2._subscribeToFileChanges(rootDir, inputDirs, excludeDirs);

            return _context8.abrupt('return', fragmentDefinitions);

          case 18:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, _this2);
  };

  this.getSchema = function _callee5(configSchemaPath) {
    var schemaPath, schemaDSL, schemaFileExt, schema;
    return regeneratorRuntime.async(function _callee5$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (configSchemaPath) {
              _context9.next = 2;
              break;
            }

            return _context9.abrupt('return', null);

          case 2:
            schemaPath = _path2.default.join(_this2._configDir, configSchemaPath);

            if (!_this2._schemaMap.has(schemaPath)) {
              _context9.next = 5;
              break;
            }

            return _context9.abrupt('return', _this2._schemaMap.get(schemaPath));

          case 5:
            _context9.next = 7;
            return regeneratorRuntime.awrap(new Promise(function (resolve) {
              return _fs2.default.readFile(schemaPath, 'utf8', function (error, content) {
                if (error) {
                  throw new Error(error);
                }
                resolve(content);
              });
            }));

          case 7:
            schemaDSL = _context9.sent;
            schemaFileExt = _path2.default.extname(schemaPath);
            schema = void 0;
            _context9.prev = 10;
            _context9.t0 = schemaFileExt;
            _context9.next = _context9.t0 === '.graphql' ? 14 : _context9.t0 === '.json' ? 16 : 18;
            break;

          case 14:
            schema = (0, _graphql.buildSchema)(schemaDSL);
            return _context9.abrupt('break', 19);

          case 16:
            schema = (0, _graphql.buildClientSchema)(JSON.parse(schemaDSL));
            return _context9.abrupt('break', 19);

          case 18:
            throw new Error('Unsupported schema file extention');

          case 19:
            _context9.next = 24;
            break;

          case 21:
            _context9.prev = 21;
            _context9.t1 = _context9['catch'](10);
            throw new Error(_context9.t1);

          case 24:

            _this2._schemaMap.set(schemaPath, schema);
            return _context9.abrupt('return', schema);

          case 26:
          case 'end':
            return _context9.stop();
        }
      }
    }, null, _this2, [[10, 21]]);
  };
};

function readAllGraphQLFiles(list) {
  var queue, responses, chunk, promises;
  return regeneratorRuntime.async(function readAllGraphQLFiles$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          queue = list.slice(); // copy

          responses = [];

        case 2:
          if (!queue.length) {
            _context5.next = 9;
            break;
          }

          chunk = queue.splice(0, MAX_READS);
          promises = chunk.map(function (fileInfo) {
            return promiseToReadGraphQLFile(fileInfo.filePath).catch(function (error) {
              /**
               * fs emits `EMFILE | ENFILE` error when there are too many
               * open files - this can cause some fragment files not to be
               * processed.  Solve this case by implementing a queue to save
               * files failed to be processed because of `EMFILE` error,
               * and await on Promises created with the next batch from the
               * queue.
               */
              if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                queue.push(fileInfo);
              }
            }).then(function (response) {
              return responses.push(_extends({}, response, {
                mtime: fileInfo.mtime,
                size: fileInfo.size
              }));
            });
          });
          _context5.next = 7;
          return regeneratorRuntime.awrap(Promise.all(promises));

        case 7:
          _context5.next = 2;
          break;

        case 9:
          return _context5.abrupt('return', processGraphQLFiles(responses));

        case 10:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
}

/**
 * Takes an array of GraphQL File information and batch-processes into a
 * map of fragmentDefinitions and GraphQL file cache.
 */
function processGraphQLFiles(responses) {
  var fragmentDefinitions = new Map();
  var graphQLFileMap = new Map();

  responses.forEach(function (response) {
    var filePath = response.filePath,
        content = response.content,
        ast = response.ast,
        mtime = response.mtime,
        size = response.size;


    if (ast) {
      ast.definitions.forEach(function (definition) {
        if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
          fragmentDefinitions.set(definition.name.value, {
            filePath: filePath,
            content: content,
            definition: definition
          });
        }
      });
    }

    // Relay the previous object whether or not ast exists.
    graphQLFileMap.set(filePath, {
      filePath: filePath,
      content: content,
      ast: ast,
      mtime: mtime,
      size: size
    });
  });

  return { fragmentDefinitions: fragmentDefinitions, graphQLFileMap: graphQLFileMap };
}

/**
 * Returns a Promise to read a GraphQL file and return a GraphQL metadata
 * including a parsed AST.
 */
function promiseToReadGraphQLFile(filePath) {
  return new Promise(function (resolve, reject) {
    return _fs2.default.readFile(filePath, 'utf8', function (error, content) {
      if (error) {
        reject(error);
        return;
      }

      var ast = null;
      if (content.trim().length !== 0) {
        try {
          ast = (0, _graphql.parse)(content);
        } catch (_) {
          // If query has syntax errors, go ahead and still resolve
          // the filePath and the content, but leave ast with null.
          resolve({ filePath: filePath, content: content, ast: null });
          return;
        }
      }
      resolve({ filePath: filePath, content: content, ast: ast });
    });
  });
}