'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _MessageProcessor = require('./MessageProcessor');

var _vscodeJsonrpc = require('vscode-jsonrpc');

var _vscodeLanguageserver = require('vscode-languageserver');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  Copyright (c) Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
 *
 *  
 */

exports.default = function startServer(options) {
  var reader, writer, _port, socket, connection;

  return regeneratorRuntime.async(function startServer$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(options && options.method)) {
            _context.next = 22;
            break;
          }

          reader = void 0;
          writer = void 0;
          _context.t0 = options.method;
          _context.next = _context.t0 === 'socket' ? 6 : _context.t0 === 'stream' ? 13 : _context.t0 === 'node' ? 16 : 16;
          break;

        case 6:
          if (options.port) {
            _context.next = 10;
            break;
          }

          process.stderr.write('--port is required to establish socket connection.');
          process.exit(1);
          return _context.abrupt('return');

        case 10:
          _port = options.port;
          socket = _net2.default.createServer(function (client) {
            client.setEncoding('utf8');
            reader = new _vscodeJsonrpc.SocketMessageReader(client);
            writer = new _vscodeJsonrpc.SocketMessageWriter(client);
            client.on('end', function () {
              socket.close();
              process.exit(0);
            });
            var connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer);
            addHandlers(connection, options.configDir);
            connection.listen();
          }).listen(_port);
          return _context.abrupt('return');

        case 13:
          reader = new _vscodeJsonrpc.StreamMessageReader(process.stdin);
          writer = new _vscodeJsonrpc.StreamMessageWriter(process.stdout);
          return _context.abrupt('break', 19);

        case 16:
          reader = new _vscodeJsonrpc.IPCMessageReader(process);
          writer = new _vscodeJsonrpc.IPCMessageWriter(process);
          return _context.abrupt('break', 19);

        case 19:
          connection = (0, _vscodeJsonrpc.createMessageConnection)(reader, writer);

          addHandlers(connection, options.configDir);
          connection.listen();

        case 22:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
};

function addHandlers(connection, configDir) {
  var _this = this;

  connection.onNotification(_vscodeLanguageserver.DidOpenTextDocumentNotification.type, function _callee(params) {
    var diagnostics;
    return regeneratorRuntime.async(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return regeneratorRuntime.awrap((0, _MessageProcessor.handleDidOpenOrSaveNotification)(params));

          case 2:
            diagnostics = _context2.sent;

            if (diagnostics) {
              connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
            }

          case 4:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, _this);
  });
  connection.onNotification(_vscodeLanguageserver.DidSaveTextDocumentNotification.type, function _callee2(params) {
    var diagnostics;
    return regeneratorRuntime.async(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return regeneratorRuntime.awrap((0, _MessageProcessor.handleDidOpenOrSaveNotification)(params));

          case 2:
            diagnostics = _context3.sent;

            if (diagnostics) {
              connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
            }

          case 4:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, _this);
  });
  connection.onNotification(_vscodeLanguageserver.DidChangeTextDocumentNotification.type, function _callee3(params) {
    var diagnostics;
    return regeneratorRuntime.async(function _callee3$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return regeneratorRuntime.awrap((0, _MessageProcessor.handleDidChangeNotification)(params));

          case 2:
            diagnostics = _context4.sent;

            if (diagnostics) {
              connection.sendNotification(_vscodeLanguageserver.PublishDiagnosticsNotification.type, diagnostics);
            }

          case 4:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, _this);
  });
  connection.onNotification(_vscodeLanguageserver.DidCloseTextDocumentNotification.type, _MessageProcessor.handleDidCloseNotification);
  connection.onNotification(_vscodeLanguageserver.ExitNotification.type, function () {
    return process.exit(0);
  });
  // Ignore cancel requests
  connection.onNotification('$/cancelRequest', function () {
    return {};
  });

  connection.onRequest(_vscodeLanguageserver.InitializeRequest.type, function (params, token) {
    return (0, _MessageProcessor.handleInitializeRequest)(params, token, configDir);
  });
  connection.onRequest(_vscodeLanguageserver.CompletionRequest.type, _MessageProcessor.handleCompletionRequest);
  connection.onRequest(_vscodeLanguageserver.CompletionResolveRequest.type, function (item) {
    return item;
  });
  connection.onRequest(_vscodeLanguageserver.DefinitionRequest.type, _MessageProcessor.handleDefinitionRequest);
}