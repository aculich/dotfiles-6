'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleDidOpenOrSaveNotification = handleDidOpenOrSaveNotification;
exports.handleDidChangeNotification = handleDidChangeNotification;
exports.handleDidCloseNotification = handleDidCloseNotification;
exports.handleInitializeRequest = handleInitializeRequest;
exports.handleCompletionRequest = handleCompletionRequest;
exports.handleDefinitionRequest = handleDefinitionRequest;

var _vscodeLanguageserver = require('vscode-languageserver');

var _graphqlLanguageServiceConfig = require('graphql-language-service-config');

var _graphqlLanguageServiceInterface = require('graphql-language-service-interface');

var _graphqlLanguageServiceUtils = require('graphql-language-service-utils');

var _vscodeJsonrpc = require('vscode-jsonrpc');

var _GraphQLCache = require('./GraphQLCache');

var graphQLCache = void 0; /**
                            *  Copyright (c) Facebook, Inc.
                            *  All rights reserved.
                            *
                            *  This source code is licensed under the license found in the
                            *  LICENSE file in the root directory of this source tree.
                            *
                            *  
                            */

var languageService = void 0;
var textDocumentCache = new Map();

function handleDidOpenOrSaveNotification(params) {
  var textDocument, uri, text, cachedDocument, diagnostics;
  return regeneratorRuntime.async(function handleDidOpenOrSaveNotification$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(!params || !params.textDocument)) {
            _context.next = 2;
            break;
          }

          throw new Error('`textDocument` argument is required.');

        case 2:
          textDocument = params.textDocument;
          uri = textDocument.uri;
          text = textDocument.text;

          // Create/modify the cached entry if text is provided.
          // Otherwise, try searching the cache to perform diagnostics.

          if (text) {
            invalidateCache(textDocument, uri, { text: text });
          } else {
            if (textDocumentCache.has(uri)) {
              cachedDocument = textDocumentCache.get(uri);

              if (cachedDocument) {
                text = cachedDocument.content.text;
              }
            }
          }

          _context.next = 8;
          return regeneratorRuntime.awrap(provideDiagnosticsMessage(text, uri));

        case 8:
          diagnostics = _context.sent;
          return _context.abrupt('return', { uri: uri, diagnostics: diagnostics });

        case 10:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

function handleDidChangeNotification(params) {
  var textDocument, contentChanges, uri, cachedDocument, diagnostics;
  return regeneratorRuntime.async(function handleDidChangeNotification$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(!params || !params.textDocument || !params.contentChanges)) {
            _context2.next = 2;
            break;
          }

          throw new Error('`textDocument` and `contentChanges` arguments are required.');

        case 2:
          textDocument = params.textDocument;
          contentChanges = params.contentChanges;

          // As `contentChanges` is an array and we just want the
          // latest update to the text, grab the last entry from the array.

          uri = textDocument.uri || params.uri;

          invalidateCache(textDocument, uri, contentChanges[contentChanges.length - 1]);

          cachedDocument = textDocumentCache.get(uri);

          if (cachedDocument) {
            _context2.next = 9;
            break;
          }

          return _context2.abrupt('return');

        case 9:
          _context2.next = 11;
          return regeneratorRuntime.awrap(provideDiagnosticsMessage(cachedDocument.content.text, uri));

        case 11:
          diagnostics = _context2.sent;
          return _context2.abrupt('return', { uri: uri, diagnostics: diagnostics });

        case 13:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
}

function handleDidCloseNotification(params) {
  var textDocument;
  return regeneratorRuntime.async(function handleDidCloseNotification$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (!(!params || !params.textDocument)) {
            _context3.next = 2;
            break;
          }

          throw new Error('`textDocument` is required.');

        case 2:
          textDocument = params.textDocument;


          if (textDocumentCache.has(textDocument.uri)) {
            textDocumentCache.delete(textDocument.uri);
          }

        case 4:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
}

function handleInitializeRequest(params, token, configDir) {
  var serverCapabilities;
  return regeneratorRuntime.async(function handleInitializeRequest$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(!params || !params.rootPath)) {
            _context4.next = 2;
            break;
          }

          throw new Error('`rootPath` argument is required.');

        case 2:
          _context4.next = 4;
          return regeneratorRuntime.awrap(initialize(configDir ? configDir.trim() : params.rootPath));

        case 4:
          serverCapabilities = _context4.sent;

          if (serverCapabilities) {
            _context4.next = 7;
            break;
          }

          throw new Error('GraphQL Language Server is not initialized.');

        case 7:
          return _context4.abrupt('return', serverCapabilities);

        case 8:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
}

function handleCompletionRequest(params, token) {
  var textDocument, position, cachedDocument, query, result;
  return regeneratorRuntime.async(function handleCompletionRequest$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          if (!(!params || !params.textDocument || !params.position)) {
            _context5.next = 2;
            break;
          }

          throw new Error('`textDocument` argument is required.');

        case 2:
          textDocument = params.textDocument;
          position = params.position;
          cachedDocument = getCachedDocument(textDocument.uri);

          if (cachedDocument) {
            _context5.next = 7;
            break;
          }

          throw new Error(textDocument.uri + ' is not available.');

        case 7:
          query = cachedDocument.content.text;
          _context5.next = 10;
          return regeneratorRuntime.awrap(languageService.getAutocompleteSuggestions(query, position, textDocument.uri));

        case 10:
          result = _context5.sent;
          return _context5.abrupt('return', { items: result, isIncomplete: false });

        case 12:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
}

function handleDefinitionRequest(params, token) {
  var textDocument, pos, cachedDocument, query, result, formatted;
  return regeneratorRuntime.async(function handleDefinitionRequest$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          if (!(!params || !params.textDocument || !params.position)) {
            _context6.next = 2;
            break;
          }

          throw new Error('`textDocument` and `position` arguments are required.');

        case 2:
          textDocument = params.textDocument;
          pos = params.position;
          cachedDocument = getCachedDocument(textDocument.uri);

          if (cachedDocument) {
            _context6.next = 7;
            break;
          }

          throw new Error(textDocument.uri + ' is not available.');

        case 7:
          query = cachedDocument.content.text;
          _context6.next = 10;
          return regeneratorRuntime.awrap(languageService.getDefinition(query, pos, textDocument.uri));

        case 10:
          result = _context6.sent;
          formatted = result ? result.definitions.map(function (res) {
            return {
              // TODO: fix this hack!
              // URI is being misused all over this library - there's a link that
              // defines how an URI should be structured:
              // https://tools.ietf.org/html/rfc3986
              // Remove the below hack once the usage of URI is sorted out in related
              // libraries.
              uri: res.path.indexOf('file://') === 0 ? res.path : 'file://' + res.path,
              range: res.range
            };
          }) : [];
          return _context6.abrupt('return', formatted);

        case 13:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, this);
}

/**
 * Helper functions to perform requested services from client/server.
 */

function initialize(rootPath) {
  var serverCapabilities, configDir;
  return regeneratorRuntime.async(function initialize$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          serverCapabilities = {
            capabilities: {
              completionProvider: { resolveProvider: true },
              definitionProvider: true,
              textDocumentSync: 1
            }
          };
          configDir = (0, _graphqlLanguageServiceConfig.findGraphQLConfigDir)(rootPath);

          if (configDir) {
            _context7.next = 4;
            break;
          }

          return _context7.abrupt('return', null);

        case 4:
          _context7.next = 6;
          return regeneratorRuntime.awrap((0, _GraphQLCache.getGraphQLCache)(configDir));

        case 6:
          graphQLCache = _context7.sent;

          languageService = new _graphqlLanguageServiceInterface.GraphQLLanguageService(graphQLCache);

          return _context7.abrupt('return', serverCapabilities);

        case 9:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, this);
}

function provideDiagnosticsMessage(query, uri) {
  var results, queryLines, totalLines, lastLineLength, lastCharacterPosition;
  return regeneratorRuntime.async(function provideDiagnosticsMessage$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return regeneratorRuntime.awrap(languageService.getDiagnostics(query, uri));

        case 2:
          results = _context8.sent;

          if (results && results.length > 0) {
            queryLines = query.split('\n');
            totalLines = queryLines.length;
            lastLineLength = queryLines[totalLines - 1].length;
            lastCharacterPosition = new _graphqlLanguageServiceUtils.Position(totalLines, lastLineLength);

            results = results.filter(function (diagnostic) {
              return diagnostic.range.end.lessThanOrEqualTo(lastCharacterPosition);
            });
          }

          return _context8.abrupt('return', results);

        case 5:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, this);
}

function invalidateCache(textDocument, uri, content) {
  if (!uri) {
    return;
  }

  if (textDocumentCache.has(uri)) {
    var cachedDocument = textDocumentCache.get(uri);
    if (cachedDocument && cachedDocument.version < textDocument.version) {
      // Current server capabilities specify the full sync of the contents.
      // Therefore always overwrite the entire content.
      textDocumentCache.set(uri, {
        version: textDocument.version,
        content: content
      });
    }
  } else {
    textDocumentCache.set(uri, {
      version: textDocument.version,
      content: content
    });
  }
}

function getCachedDocument(uri) {
  if (textDocumentCache.has(uri)) {
    var cachedDocument = textDocumentCache.get(uri);
    if (cachedDocument) {
      return cachedDocument;
    }
  }

  return null;
}