From 113f4015c2854887694d52f44d6e5ebbb84f39d4 Mon Sep 17 00:00:00 2001
Message-Id: <113f4015c2854887694d52f44d6e5ebbb84f39d4.1535435518.git.joeypabalinas@gmail.com>
In-Reply-To: <b9bc74359a8a18242c0827d51541a1025c60b590.1535435517.git.joeypabalinas@gmail.com>
References: <b9bc74359a8a18242c0827d51541a1025c60b590.1535435517.git.joeypabalinas@gmail.com>
From: Joey Pabalinas <joeypabalinas@gmail.com>
Date: Mon, 27 Aug 2018 17:36:21 -1000
Subject: [PATCH 2/2] fork: add userspace emulation of fork to the NaCl
 Internal Runtime (IRT)

Add a single-process implementation (using the Linux NPTL implementation
of POSIX Threads to simulate common multi-process programming) of the fork
system call. Programming and system designs leveraging this style are
ubiquitous in modern Computer Science and Networking; common implementation
of a standard web server is the single HTTP parent daemon which forks off
several children worker processes.

The main motivation for an emulation of fork (as opposed to just using
the kernel system call) is allowing for _much_ stricter control and
auditing of application(s) being run within NaCl while still being
transparent to sandboxed processes.

This provide users with a balance between useful security and practical
usability which, if not respected, tends to become "a system safe from
everyone; owner included."

Signed-off-by: Joey Pabalinas <joeypabalinas@gmail.com>
---
 src/trusted/service_runtime/nacl_app_thread.c |  584 ++++++-
 src/trusted/service_runtime/nacl_app_thread.h |   13 +
 src/trusted/service_runtime/nacl_globals.c    |   10 +-
 src/trusted/service_runtime/nacl_globals.h    |   95 +-
 .../service_runtime/nacl_syscall_common.c     | 1396 ++++++++++-------
 .../service_runtime/nacl_syscall_common.h     |   23 +-
 .../service_runtime/nacl_syscall_handlers.h   |    7 +
 .../nacl_syscall_handlers_gen.py              |   53 +-
 .../service_runtime/posix/sel_memory.c        |    8 +
 src/trusted/service_runtime/sel_addrspace.c   |   40 +-
 src/trusted/service_runtime/sel_ldr.c         |  401 +++--
 src/trusted/service_runtime/sel_ldr.h         |  180 ++-
 .../service_runtime/sel_ldr_standard.c        |  295 +++-
 src/trusted/service_runtime/sel_main.c        |  474 ++++--
 src/trusted/service_runtime/sel_memory.h      |    3 +
 15 files changed, 2617 insertions(+), 965 deletions(-)

diff --git a/src/trusted/service_runtime/nacl_app_thread.c b/src/trusted/service_runtime/nacl_app_thread.c
index 88db85b2a81e883327..fabc7b16fefa8fa2d2 100644
--- a/src/trusted/service_runtime/nacl_app_thread.c
+++ b/src/trusted/service_runtime/nacl_app_thread.c
@@ -14,29 +14,247 @@
 #include "native_client/src/shared/platform/nacl_check.h"
 #include "native_client/src/shared/platform/nacl_exit.h"
 #include "native_client/src/shared/platform/nacl_sync_checked.h"
 
 #include "native_client/src/trusted/service_runtime/arch/sel_ldr_arch.h"
+#include "native_client/src/trusted/service_runtime/dyn_array.h"
+#include "native_client/src/trusted/service_runtime/nacl_app.h"
 #include "native_client/src/trusted/service_runtime/nacl_desc_effector_ldr.h"
 #include "native_client/src/trusted/service_runtime/nacl_globals.h"
-#include "native_client/src/trusted/service_runtime/nacl_tls.h"
-#include "native_client/src/trusted/service_runtime/nacl_switch_to_app.h"
 #include "native_client/src/trusted/service_runtime/nacl_stack_safety.h"
+#include "native_client/src/trusted/service_runtime/nacl_switch_to_app.h"
 #include "native_client/src/trusted/service_runtime/nacl_syscall_common.h"
+#include "native_client/src/trusted/service_runtime/nacl_tls.h"
 #include "native_client/src/trusted/service_runtime/osx/mach_thread_map.h"
 
+#include "native_client/src/include/win/mman.h"
+#include "native_client/src/trusted/service_runtime/load_file.h"
+#include "native_client/src/trusted/service_runtime/sel_memory.h"
+
+#include "native_client/src/trusted/desc/nacl_desc_io.h"
+#include "native_client/src/shared/platform/lind_platform.h"
+#include "native_client/src/trusted/service_runtime/include/bits/mman.h"
+#include "native_client/src/trusted/service_runtime/include/sys/fcntl.h"
+
+
+/*
+ * always points at original program context
+ *
+ * -jp
+ */
+struct NaClThreadContext *master_ctx;
+
+
+/*
+ * dynamically allocate and initilize a copy
+ * of the parents NaClApp structure which is
+ * used in NaClSysFork()
+ */
+struct NaClApp *NaClChildNapCtor(struct NaClAppThread *natp) {
+  struct NaClApp *nap_master = ((struct NaClAppThread *)master_ctx)->nap;
+  struct NaClApp *nap_child = calloc(1, sizeof *nap_child);
+  struct NaClApp *nap_parent = natp->nap;
+  NaClErrorCode *mod_status = NULL;
+
+  CHECK(nap_master);
+  CHECK(nap_parent);
+  CHECK(nap_child);
+
+  NaClLog(1, "%s\n", "Entered NaClChildNapCtor()");
+  if (!NaClAppCtor(nap_child)) {
+    NaClLog(LOG_FATAL, "%s\n", "Failed to initialize fork child nap");
+  }
+  mod_status = &nap_child->module_load_status;
+  nap_child->command_num = nap_parent->command_num;
+  nap_child->binary_path = nap_parent->binary_path;
+  nap_child->binary_command = nap_parent->binary_command;
+  nap_child->nacl_file = nap_parent->nacl_file ? nap_parent->nacl_file : LD_FILE;
+  nap_child->enable_exception_handling = nap_parent->enable_exception_handling;
+  nap_child->validator_stub_out_mode = nap_parent->validator_stub_out_mode;
+  nap_child->parent_id = nap_parent->cage_id;
+  nap_child->parent = nap_parent;
+  nap_child->master = nap_master;
+  fork_num++;
+
+  /* store cage_ids in both master and parent */
+  for (struct NaClApp *nap_cur = nap_master; nap_cur; nap_cur = nap_parent) {
+    NaClXMutexLock(&nap_cur->children_mu);
+    if (nap_cur->children_ids[nap_cur->num_children]) {
+       nap_cur->num_children++;
+    }
+    /* make sure cage_id is unique and assign it to child */
+    InitializeCage(nap_child, nap_master->cage_id + fork_num);
+    NaClLog(1, "[nap %d] incrementing num_children\n", nap_cur->cage_id);
+    nap_cur->children_ids[nap_cur->num_children++] = nap_child->cage_id;
+    if (!DynArraySet(&nap_cur->children, nap_child->cage_id, nap_child)) {
+      NaClLog(LOG_FATAL, "[nap %u] failed to add child: cage_id = %d\n", nap_cur->cage_id, nap_child->cage_id);
+    }
+    NaClLog(1, "[nap %d] new child count: %d\n", nap_cur->cage_id, nap_cur->num_children);
+    NaClXMutexUnlock(&nap_cur->children_mu);
+
+    /* break after parent's cleanup */
+    if (nap_cur == nap_parent) {
+      break;
+    }
+  }
+
+  NaClAppInitialDescriptorHookup(nap_child);
+  NaClLog(1, "fork_num = %d, cage_id = %d\n", fork_num, nap_child->cage_id);
+  if ((*mod_status = NaClAppLoadFileFromFilename(nap_child, nap_child->nacl_file)) != LOAD_OK) {
+    NaClLog(1, "Error while loading \"%s\": %s\n", nap_child->nacl_file, NaClErrorString(*mod_status));
+    NaClLog(LOG_FATAL, "%s\n%s\n",
+                       "Using the wrong type of nexe (nacl-x86-32 on an x86-64 or vice versa) ",
+                       "or a corrupt nexe file may be responsible for this error.");
+  }
+
+  if ((*mod_status = NaClAppPrepareToLaunch(nap_child)) != LOAD_OK) {
+    NaClLog(LOG_FATAL, "Failed to prepare child nap_parent for launch\n");
+  }
+  NaClLog(1, "Loading blob file %s\n", nap_child->nacl_file);
+  if (!nap_child->validator->readonly_text_implemented) {
+    NaClLog(LOG_FATAL, "fixed_feature_cpu_mode is not supported\n");
+  }
+  NaClLog(1, "%s\n", "Enabling Fixed-Feature CPU Mode");
+  nap_child->fixed_feature_cpu_mode = 1;
+  if (!nap_child->validator->FixCPUFeatures(nap_child->cpu_features)) {
+    NaClLog(LOG_FATAL, "This CPU lacks features required by fixed-function CPU mode.\n");
+  }
+  if (!NaClAppLaunchServiceThreads(nap_child)) {
+    NaClLog(LOG_FATAL, "Launch service threads failed\n");
+  }
+
+  for (int old_fd = 0, new_fd; old_fd < CAGING_FD_NUM; old_fd++) {
+    struct NaClDesc *old_nd;
+    old_nd = NaClGetDesc(nap_parent, old_fd);
+    if (!old_nd) {
+      break;
+    }
+    new_fd = NaClSetAvail(nap_child, old_nd);
+    NaClSetDesc(nap_child, new_fd, old_nd);
+    fd_cage_table[nap_child->cage_id][new_fd] = fd_cage_table[nap_parent->cage_id][old_fd];
+    nap_child->fd++;
+    NaClLog(1, "NaClGetDesc() copied parent fd [%d] to child fd [%d]\n", old_fd, new_fd);
+  }
+
+  return nap_child;
+}
+
+void WINAPI NaClAppForkThreadLauncher(void *state) {
+  struct NaClAppThread *natp = (struct NaClAppThread *) state;
+  struct NaClApp *nap = natp->nap;
+  struct NaClThreadContext *context = &natp->user;
+  uint32_t thread_idx;
+  nacl_reg_t secure_stack_ptr;
+
+  UNREFERENCED_PARAMETER(context);
+
+  NaClLog(1, "%s\n", "NaClAppForkThreadLauncher: entered");
+
+  NaClSignalStackRegister(natp->signal_stack);
+
+  NaClLog(1, "     natp  = 0x%016"NACL_PRIxPTR"\n", (uintptr_t)natp);
+  NaClLog(1, " prog_ctr  = 0x%016"NACL_PRIxNACL_REG"\n", natp->user.prog_ctr);
+  NaClLog(1, "stack_ptr  = 0x%016"NACL_PRIxPTR"\n", NaClGetThreadCtxSp(&natp->user));
+
+  /* thread_idx = nap->cage_id; */
+  thread_idx = NaClGetThreadIdx(natp);
+  CHECK(0 < thread_idx);
+  CHECK(thread_idx < NACL_THREAD_MAX);
+  NaClTlsSetCurrentThread(natp);
+  nacl_user[thread_idx] = &natp->user;
+#if NACL_WINDOWS
+  nacl_thread_ids[thread_idx] = GetCurrentThreadId();
+#elif NACL_OSX
+  NaClSetCurrentMachThreadForThreadIndex(thread_idx);
+#endif
+
+  /*
+   * We have to hold the threads_mu and children_mu locks until
+   * after thread_num field in this thread has been initialized.
+   * All other threads can only find and examine this natp through
+   * the threads table, so the fact that natp is not consistent (no
+   * thread_num) will not be visible.
+   */
+  NaClXMutexLock(&nap->threads_mu);
+  NaClXMutexLock(&nap->children_mu);
+  nap->num_threads = thread_idx + 1;
+  natp->thread_num = thread_idx + 1;
+  if (!DynArraySet(&nap->threads, natp->thread_num, natp)) {
+    NaClLog(LOG_FATAL, "NaClAddThreadMu: DynArraySet at position %d failed\n", natp->thread_num);
+  }
+  NaClXMutexUnlock(&nap->threads_mu);
+  NaClXMutexUnlock(&nap->children_mu);
+
+  NaClVmHoleThreadStackIsSafe(natp->nap);
+
+  NaClStackSafetyNowOnUntrustedStack();
+
+  /*
+   * Notify the debug stub, that a new thread is availible.
+   */
+  if (NULL != natp->nap->debug_stub_callbacks) {
+    natp->nap->debug_stub_callbacks->thread_create_hook(natp);
+  }
+
+#if !NACL_WINDOWS
+  /*
+   * Ensure stack alignment.  Stack pointer must be -8 mod 16 when no
+   * __m256 objects are passed (8 mod 32 if __m256), after the call.
+   * Note the current doc (as of 2009-12-09) at
+   *
+   *   http://www.x86-64.org/documentation/abi.pdf
+   *
+   * is wrong since it claims (%rsp-8) should be 0 mod 16 or mod 32
+   * after the call, and it should be (%rsp+8) == 0 mod 16 or 32.
+   * Clearly it makes no difference since -8 and 8 are the same mod
+   * 16, but there is a difference when mod 32.
+   *
+   * This is not suitable for Windows because we do not reserve 32
+   * bytes for the shadow space.
+   */
+  secure_stack_ptr = NaClGetStackPtr();
+  NaClLog(1, "NaClStartThreadInApp: secure stack:   0x%"NACL_PRIxNACL_REG"\n",
+          secure_stack_ptr);
+  secure_stack_ptr = secure_stack_ptr & ~0x1f;
+  NaClLog(1, "NaClStartThreadInApp: adjusted stack: 0x%"NACL_PRIxNACL_REG"\n",
+          secure_stack_ptr);
+  natp->user.trusted_stack_ptr = secure_stack_ptr;
+#endif
+
+  NaClLog(1, "NaClStackThreadInApp: user stack: 0x%"NACL_PRIxPTR"\n",
+          NaClGetThreadCtxSp(context));
+  NaClLog(1, "%s\n", "NaClStartThreadInApp: switching to untrusted code");
+
+  NaClLog(1, "[NaClAppThreadLauncher] Nap %d is ready to launch! child registers: \n", nap->cage_id);
+  NaClLogThreadContext(natp);
+  NaClAppThreadPrintInfo(natp);
+  CHECK(thread_idx == nacl_user[thread_idx]->tls_idx);
+
+  /*
+   * After this NaClAppThreadSetSuspendState() call, we should not
+   * claim any mutexes, otherwise we risk deadlock.
+   */
+  NaClAppThreadSetSuspendState(natp, NACL_APP_THREAD_TRUSTED, NACL_APP_THREAD_UNTRUSTED);
+
+#if NACL_WINDOWS
+  /* This sets up a stack containing a return address that has unwind info. */
+  NaClSwitchSavingStackPtr(context, &context->trusted_stack_ptr, NaClSwitchToApp);
+#else
+  NaClSwitchToApp(natp);
+#endif
+}
 
 void WINAPI NaClAppThreadLauncher(void *state) {
   struct NaClAppThread *natp = (struct NaClAppThread *) state;
   uint32_t thread_idx;
   NaClLog(4, "NaClAppThreadLauncher: entered\n");
 
   NaClSignalStackRegister(natp->signal_stack);
 
-  NaClLog(4, "      natp = 0x%016"NACL_PRIxPTR"\n", (uintptr_t) natp);
-  NaClLog(4, " prog_ctr  = 0x%016"NACL_PRIxNACL_REG"\n", natp->user.prog_ctr);
-  NaClLog(4, "stack_ptr  = 0x%016"NACL_PRIxPTR"\n",
+  NaClLog(1, "     natp  = 0x%016"NACL_PRIxPTR"\n", (uintptr_t)natp);
+  NaClLog(1, " prog_ctr  = 0x%016"NACL_PRIxNACL_REG"\n", natp->user.prog_ctr);
+  NaClLog(1, "stack_ptr  = 0x%016"NACL_PRIxPTR"\n",
           NaClGetThreadCtxSp(&natp->user));
 
   thread_idx = NaClGetThreadIdx(natp);
   CHECK(0 < thread_idx);
   CHECK(thread_idx < NACL_THREAD_MAX);
@@ -74,51 +292,115 @@ void WINAPI NaClAppThreadLauncher(void *state) {
    * claim any mutexes, otherwise we risk deadlock.
    */
   NaClAppThreadSetSuspendState(natp, NACL_APP_THREAD_TRUSTED,
                                NACL_APP_THREAD_UNTRUSTED);
 
+  NaClLog(1, "%s\n", "[NaCl Main Loader] NaCl Loader: user program about to start running inside the cage!");
+  /* NaClVmmapDebug(&natp->nap->mem_map, "parent vmmap:"); */
   NaClStartThreadInApp(natp, natp->user.prog_ctr);
 }
 
+static INLINE int GetChildIdx(const volatile sig_atomic_t *id_list, int nmemb, volatile sig_atomic_t cage_id) {
+  int ret;
+  /* return the index if match found */
+  for (ret = 0; ret < nmemb; ret++) {
+    if (cage_id == id_list[ret]) {
+      return ret;
+    }
+  }
+  /* otherwise return an error value */
+  return -1;
+}
 
 /*
  * natp should be thread_self(), called while holding no locks.
  */
 void NaClAppThreadTeardown(struct NaClAppThread *natp) {
-  struct NaClApp  *nap;
+  struct NaClApp  *nap_master = ((struct NaClAppThread *)master_ctx)->nap;
+  struct NaClApp  *nap = natp->nap;
+  struct NaClApp  *nap_parent = nap->parent;
   size_t          thread_idx;
 
   /*
    * mark this thread as dead; doesn't matter if some other thread is
    * asking us to commit suicide.
    */
-  NaClLog(3, "NaClAppThreadTeardown(0x%08"NACL_PRIxPTR")\n",
-          (uintptr_t) natp);
-  nap = natp->nap;
-  if (NULL != nap->debug_stub_callbacks) {
-    NaClLog(3, " notifying the debug stub of the thread exit\n");
+  NaClLog(1, "[NaClAppThreadTeardown] cage id: %d\n", nap->cage_id);
+
+  if (nap_master && nap_parent) {
+    /*
+     * remove self from parent's list of children
+     */
+    for (struct NaClApp *nap_cur = nap_master; nap_cur; nap_cur = nap_parent) {
+      int list_idx = GetChildIdx(nap_cur->children_ids, nap_cur->num_children, nap->cage_id);
+      NaClLog(1, "[parent nap %d] starting cleanup: cage_id = %d\n", nap_cur->cage_id, nap->cage_id);
+      NaClXMutexLock(&nap_cur->children_mu);
+      switch (list_idx) {
+      case -1:
+        NaClLog(1, "[parent %d] index not found in id list: cage_id = %d\n", nap_cur->cage_id, nap->cage_id);
+        break;
+      default:
+        nap_cur->children_ids[list_idx] = 0;
+        NaClLog(1, "[parent %d] new child count: %d\n", nap_cur->cage_id, --nap_cur->num_children);
+        if (!DynArraySet(&nap_cur->children, nap->cage_id, NULL)) {
+          NaClLog(1, "[parent %d] nap list removal failed: cage_id = %d\n", nap_cur->cage_id, nap->cage_id);
+        }
+      }
+      NaClXCondVarBroadcast(&nap_cur->children_cv);
+      NaClXMutexUnlock(&nap_cur->children_mu);
+      /* break after parent's cleanup */
+      if (nap_cur == nap_parent) {
+        break;
+      }
+    }
+  }
+
+  /* cleanup list of children */
+  NaClXMutexLock(&nap->children_mu);
+  NaClLog(1, "Thread children count: %d\n", nap->num_children);
+  while (nap->num_children > 0) {
+    NaClXCondVarWait(&nap->children_cv, &nap->children_mu);
+  }
+  NaClXCondVarBroadcast(&nap->children_cv);
+  NaClXMutexUnlock(&nap->children_mu);
+
+  /* wait for master thread */
+  if (nap_master && nap != nap_master) {
+    NaClXMutexLock(&nap_master->children_mu);
+    NaClLog(1, "Master children count: %d\n", nap_master->num_children);
+    while (nap_master->num_children > 0) {
+      NaClXCondVarWait(&nap_master->children_cv, &nap_master->children_mu);
+    }
+    NaClXCondVarBroadcast(&nap_master->children_cv);
+    NaClXMutexUnlock(&nap_master->children_mu);
+  }
+
+  if (nap->debug_stub_callbacks) {
+    NaClLog(1, "%s\n", " notifying the debug stub of the thread exit");
     /*
      * This must happen before deallocating the ID natp->thread_num.
      * We have the invariant that debug stub lock should be acquired before
      * nap->threads_mu lock. Hence we must not hold threads_mu lock while
      * calling debug stub hooks.
      */
     nap->debug_stub_callbacks->thread_exit_hook(natp);
   }
 
-  NaClLog(3, " getting thread table lock\n");
+  NaClLog(1, "%s\n", " getting thread table lock");
   NaClXMutexLock(&nap->threads_mu);
-  NaClLog(3, " getting thread lock\n");
+  NaClLog(1, "%s\n", " getting thread lock");
   NaClXMutexLock(&natp->mu);
+
   /*
    * Remove ourselves from the ldt-indexed global tables.  The ldt
    * entry is released as part of NaClAppThreadDelete(), and if
    * another thread is immediately created (from some other running
    * thread) we want to be sure that any ldt-based lookups will not
    * reach this dying thread's data.
    */
   thread_idx = NaClGetThreadIdx(natp);
+
   /*
    * On x86-64 and ARM, clearing nacl_user entry ensures that we will
    * fault if another syscall is made with this thread_idx.  In
    * particular, thread_idx 0 is never used.
    */
@@ -133,50 +415,51 @@ void NaClAppThreadTeardown(struct NaClAppThread *natp) {
    * teardown, the signal handler does not dereference a dangling
    * NaClAppThread pointer.
    */
   NaClTlsSetCurrentThread(NULL);
 
-  NaClLog(3, " removing thread from thread table\n");
+  NaClLog(1, "%s\n", " removing thread from thread table");
   /* Deallocate the ID natp->thread_num. */
   NaClRemoveThreadMu(nap, natp->thread_num);
-  NaClLog(3, " unlocking thread\n");
+  NaClLog(1, "%s\n", " unlocking thread");
   NaClXMutexUnlock(&natp->mu);
-  NaClLog(3, " unlocking thread table\n");
+  NaClLog(1, "%s\n", " unlocking thread table");
   NaClXMutexUnlock(&nap->threads_mu);
-  NaClLog(3, " unregistering signal stack\n");
+  NaClLog(1, "%s\n", " unregistering signal stack");
   NaClSignalStackUnregister();
-  NaClLog(3, " freeing thread object\n");
+  NaClLog(1, "%s\n", " freeing thread object");
   NaClAppThreadDelete(natp);
-  NaClLog(3, " NaClThreadExit\n");
+  NaClLog(1, "%s\n", " NaClThreadExit");
+
   NaClThreadExit();
-  NaClLog(LOG_FATAL,
-          "NaClAppThreadTeardown: NaClThreadExit() should not return\n");
+  NaClLog(LOG_FATAL, "NaClAppThreadTeardown: NaClThreadExit() should not return\n");
   /* NOTREACHED */
 }
 
-
 struct NaClAppThread *NaClAppThreadMake(struct NaClApp *nap,
                                         uintptr_t      usr_entry,
                                         uintptr_t      usr_stack_ptr,
                                         uint32_t       user_tls1,
                                         uint32_t       user_tls2) {
-  struct NaClAppThread *natp;
-  uint32_t tls_idx;
+ struct NaClAppThread *natp;
+ uint32_t tls_idx;
 
-  natp = NaClAlignedMalloc(sizeof *natp, __alignof(struct NaClAppThread));
-  if (natp == NULL) {
-    return NULL;
-  }
+ natp = NaClAlignedMalloc(sizeof *natp, __alignof(struct NaClAppThread));
+ if (natp == NULL) {
+  return NULL;
+ }
 
-  NaClLog(4, "         natp = 0x%016"NACL_PRIxPTR"\n", (uintptr_t) natp);
-  NaClLog(4, "          nap = 0x%016"NACL_PRIxPTR"\n", (uintptr_t) nap);
-  NaClLog(4, "usr_stack_ptr = 0x%016"NACL_PRIxPTR"\n", usr_stack_ptr);
+  NaClLog(1, "         natp = 0x%016"NACL_PRIxPTR"\n", (uintptr_t)natp);
+  NaClLog(1, "          nap = 0x%016"NACL_PRIxPTR"\n", (uintptr_t)nap);
+  NaClLog(1, "    usr_entry = 0x%016"NACL_PRIxPTR"\n", usr_entry);
+  NaClLog(1, "usr_stack_ptr = 0x%016"NACL_PRIxPTR"\n", usr_stack_ptr);
 
   /*
    * Set these early, in case NaClTlsAllocate() wants to examine them.
    */
   natp->nap = nap;
+
   natp->thread_num = -1;  /* illegal index */
   natp->host_thread_is_defined = 0;
   memset(&natp->host_thread, 0, sizeof(natp->host_thread));
 
   /*
@@ -229,29 +512,243 @@ struct NaClAppThread *NaClAppThreadMake(struct NaClApp *nap,
  cleanup_free:
   NaClAlignedFree(natp);
   return NULL;
 }
 
+int NaClAppForkThreadSpawn(struct NaClApp           *nap_parent,
+                           struct NaClAppThread     *natp_parent,
+                           struct NaClApp           *nap_child,
+                           uintptr_t                usr_entry,
+                           uintptr_t                usr_stack_ptr,
+                           uint32_t                 user_tls1,
+                           uint32_t                 user_tls2) {
+  void *stack_ptr_parent;
+  void *stack_ptr_child;
+  size_t stack_ptr_offset;
+  size_t base_ptr_offset;
+  struct NaClAppThread *natp_child;
+  struct NaClThreadContext child_ctx;
+  struct NaClThreadContext parent_ctx;
+
+  if (!nap_parent->running) {
+    return 0;
+  }
+
+  NaClXMutexLock(&nap_parent->mu);
+  NaClXMutexLock(&nap_child->mu);
+
+  /* make a copy of parent thread context */
+  parent_ctx = natp_parent->user;
+
+  /*
+   * make space to copy the parent stack
+   */
+  nap_child->stack_size = nap_parent->stack_size;
+  stack_ptr_parent = (void *)NaClUserToSysAddr(nap_parent, NaClGetInitialStackTop(nap_parent));
+  stack_ptr_child = (void *)NaClUserToSysAddr(nap_child, NaClGetInitialStackTop(nap_child));
+  stack_ptr_offset = parent_ctx.rsp - (uintptr_t)stack_ptr_parent;
+  base_ptr_offset = parent_ctx.rbp - parent_ctx.rsp;
+  usr_stack_ptr = NaClSysToUserStackAddr(nap_child, (uintptr_t)stack_ptr_child);
+  natp_child = NaClAppThreadMake(nap_child, usr_entry, usr_stack_ptr, user_tls1, user_tls2);
+  if (!natp_child) {
+    return 0;
+  }
+
+  /* save child trampoline addresses and set cage_id */
+  child_ctx = natp_child->user;
+  /* copy parent page tables and execution context */
+  NaClCopyExecutionContext(nap_parent, nap_child);
+  NaClLog(1, "fork_num: [%d], child cage_id: [%d], parent cage id: [%d]\n",
+          fork_num,
+          nap_child->cage_id,
+          nap_parent->cage_id);
+  /* copy parent thread context */
+  NaClLog(1, "%s\n", "Thread context of child before copy");
+  NaClLogThreadContext(natp_child);
+  natp_child->user = natp_parent->user;
+  NaClLog(1, "%s\n", "Thread context of child after copy");
+  NaClLogThreadContext(natp_child);
+
+  /*
+   *  Argument passing convention in AMD64, from
+   *
+   *    http://www.x86-64.org/documentation/abi.pdf
+   *
+   *  for system call parameters, are as follows.  All syscall arguments
+   *  are of INTEGER type (section 3.2.3).  They are assigned, from
+   *  left-to-right, to the registers
+   *
+   *    rdi, rsi, rdx, rcx, r8, r9
+   *
+   *  and any additional arguments are passed on the stack, pushed onto
+   *  the stack in right-to-left order.  Note that this means that the
+   *  syscall with the maximum number of arguments, mmap, passes all its
+   *  arguments in registers.
+   *
+   *  Argument passing convention for Microsoft, from wikipedia, is
+   *  different.  The first four arguments go in
+   *
+   *    rcx, rdx, r8, r9
+   *
+   *  respectively, with the caller responsible for allocating 32 bytes
+   *  of "shadow space" for the first four arguments, an additional 4
+   *  arguments are on the stack.  Presumably this is to make stdargs
+   *  easier to implement: the callee can always write those four
+   *  registers to 8(%rsp), ..., 24(%rsp) resp (%rsp value assumed to be
+   *  at fn entry/start of prolog, before push %rbp), and then use the
+   *  effective address of 8(%rsp) as a pointer to an in-memory argument
+   *  list.  However, because this is always done, presumably called code
+   *  might treat this space as if it's part of the red zone, and it
+   *  would be an error to not allocate this stack space, even if the
+   *  called function is declared to take fewer than 4 arguments.
+   *
+   *  Caller/callee saved
+   *
+   *  - AMD64:
+   *    - caller saved: rax, rcx, rdx, rdi, rsi, r8, r9, r10, r11
+   *    - callee saved: rbx, rbp, r12, r13, r14, r15
+   *
+   *  - Microsoft:
+   *    - caller saved: rax, rcx, rdx, r8, r9, r10, r11
+   *    - callee saved: rbx, rbp, rdi, rsi, r12, r13, r14, r15
+   *
+   *  A conservative approach might be to follow microsoft and save more
+   *  registers, but the presence of shadow space will make assembly code
+   *  incompatible anyway, assembly code that calls must allocate shadow
+   *  space, but then in-memory arguments will be in the wrong location
+   *  wrt %rsp.
+   *
+   *  n.b. -jp:
+   *
+   *  set return value for fork().
+   *
+   *  linux is a unix-like system. however, its kernel uses the
+   *  microsoft system-call convention of passing parameters in
+   *  registers. as with the unix convention, the function number
+   *  is placed in eax. the parameters, however, are not passed on
+   *  the stack but in %rbx, %rcx, %rdx, %rsi, %rdi, %rbp:
+   *
+   *  ; SYS_open's syscall number is 5
+   *  open:
+   *          mov	$5, %eax
+   *          mov	$path, %ebx
+   *          mov	$flags, %ecx
+   *          mov	$mode, %edx
+   *          int	$0x80
+   *
+   *  n.b. fork() return value is stored in %rdx
+   *  instead of %rax like other syscalls,
+   *  _normally_, but in NaCl %rax is used for all
+   *  syscall returns.
+   *
+   *  -jp
+   */
+  natp_child->user.rax = 0;
+  natp_child->user.sysret = 0;
+  natp_child->usr_syscall_args = natp_parent->usr_syscall_args;
+
+  /*
+   * adjust trampolines and %rip
+   */
+  nap_child->mem_start = child_ctx.r15;
+  natp_child->user.r15 = nap_child->mem_start;
+  natp_child->user.rsp = (uintptr_t)stack_ptr_child + stack_ptr_offset;
+  natp_child->user.rbp = child_ctx.rsp + base_ptr_offset;
+
+#if defined(_DEBUG)
+# define NUM_STACK_VALS 16
+# define TYPE_TO_EXAMINE uintptr_t
+# define NaClLogSysMemoryContentType(TYPE, FMT, ADDR)                                            \
+        do {                                                                                     \
+          unsigned char *addr = (unsigned char *)(ADDR);                                         \
+          UNREFERENCED_PARAMETER(addr);                                                          \
+          NaClLog(2, "[Memory] Memory addr:                   %p\n", (void *)addr);                \
+          NaClLog(2, "[Memory] Memory content (byte-swapped): " FMT "\n", (TYPE)OBJ_REP_64(addr)); \
+          NaClLog(2, "[Memory] Memory content (raw):          " FMT "\n", *(TYPE *)addr);          \
+        } while (0)
+  for (size_t i = 0; i < NUM_STACK_VALS; i++) {
+    NaClLog(2, "child_stack[%zu]:\n", i);
+    NaClLogSysMemoryContentType(TYPE_TO_EXAMINE, "0x%016lx", &((TYPE_TO_EXAMINE *)stack_ptr_child)[i]);
+    NaClLog(2, "parent_stack[%zu]:\n", i);
+    NaClLogSysMemoryContentType(TYPE_TO_EXAMINE, "0x%016lx", &((TYPE_TO_EXAMINE *)stack_ptr_parent)[i]);
+  }
+  for (size_t i = 0; i < NUM_STACK_VALS; i++) {
+    uintptr_t child_addr = (uintptr_t)&((TYPE_TO_EXAMINE *)natp_child->user.rsp)[i];
+    uintptr_t parent_addr = (uintptr_t)&((TYPE_TO_EXAMINE *)parent_ctx.rsp)[i];
+    NaClLog(2, "child_rsp[%zu]:\n", i);
+    NaClLogSysMemoryContentType(TYPE_TO_EXAMINE, "0x%016lx", child_addr);
+    NaClLog(2, "parent_rsp[%zu]:\n", i);
+    NaClLogSysMemoryContentType(TYPE_TO_EXAMINE, "0x%016lx", parent_addr);
+  }
+# undef NUM_STACK_VALS
+# undef TYPE_TO_EXAMINE
+# undef NaClLogSysMemoryContentType
+#endif /* defined(_DEBUG) */
+
+  /*
+   * setup TLS slot in the global nacl_user array
+   */
+  natp_child->user.tls_idx = nap_child->cage_id;
+  /* natp_child->user.tls_idx = child_ctx.tls_idx; */
+  if (nacl_user[natp_child->user.tls_idx]) {
+    NaClLog(LOG_FATAL, "nacl_user[%u] not NULL (%p)\n)",
+            natp_child->user.tls_idx,
+            (void *)nacl_user[natp_child->user.tls_idx]);
+  }
+  nacl_user[natp_child->user.tls_idx] = &natp_child->user;
+  NaClTlsSetTlsValue1(natp_child, user_tls1);
+  NaClTlsSetTlsValue2(natp_child, user_tls2);
+
+  /*
+   * We set host_thread_is_defined assuming, for now, that
+   * NaClThreadCtor() will succeed.
+   */
+  natp_child->host_thread_is_defined = 1;
+
+  NaClXCondVarBroadcast(&nap_parent->cv);
+  NaClXMutexUnlock(&nap_parent->mu);
+  NaClXMutexUnlock(&nap_child->mu);
+
+  if (!NaClThreadCtor(&natp_child->host_thread, NaClAppForkThreadLauncher, natp_child, NACL_KERN_STACK_SIZE)) {
+    /*
+    * No other thread saw the NaClAppThread, so it is OK that
+    * host_thread was not initialized despite host_thread_is_defined
+    * being set.
+    */
+    natp_child->host_thread_is_defined = 0;
+    NaClAppThreadDelete(natp_child);
+    return 0;
+  }
+
+  return 1;
+}
 
 int NaClAppThreadSpawn(struct NaClApp *nap,
                        uintptr_t      usr_entry,
                        uintptr_t      usr_stack_ptr,
                        uint32_t       user_tls1,
                        uint32_t       user_tls2) {
   struct NaClAppThread *natp = NaClAppThreadMake(nap, usr_entry, usr_stack_ptr,
                                                  user_tls1, user_tls2);
-  if (natp == NULL) {
+  /*
+   * save master thread context pointer
+   */
+  if (!natp)
     return 0;
+  if (nap->cage_id == 1) {
+    master_ctx = &natp->user;
   }
+  nap->parent = NULL;
+  nap->master = ((struct NaClAppThread *)master_ctx)->nap;
+
   /*
    * We set host_thread_is_defined assuming, for now, that
    * NaClThreadCtor() will succeed.
    */
   natp->host_thread_is_defined = 1;
-  if (!NaClThreadCtor(&natp->host_thread, NaClAppThreadLauncher, (void *) natp,
-                      NACL_KERN_STACK_SIZE)) {
-    /*
+  if (!NaClThreadCtor(&natp->host_thread, NaClAppThreadLauncher, natp, NACL_KERN_STACK_SIZE)) {
+     /*
      * No other thread saw the NaClAppThread, so it is OK that
      * host_thread was not initialized despite host_thread_is_defined
      * being set.
      */
     natp->host_thread_is_defined = 0;
@@ -259,16 +756,14 @@ int NaClAppThreadSpawn(struct NaClApp *nap,
     return 0;
   }
   return 1;
 }
 
-
+/*
+* n.b. the thread must not be still running, else this crashes the system
+*/
 void NaClAppThreadDelete(struct NaClAppThread *natp) {
-  /*
-   * the thread must not be still running, else this crashes the system
-   */
-
   if (natp->host_thread_is_defined) {
     NaClThreadDtor(&natp->host_thread);
   }
   free(natp->suspended_registers);
   NaClMutexDtor(&natp->suspend_mu);
@@ -276,5 +771,14 @@ void NaClAppThreadDelete(struct NaClAppThread *natp) {
   natp->signal_stack = NULL;
   NaClTlsFree(natp);
   NaClMutexDtor(&natp->mu);
   NaClAlignedFree(natp);
 }
+
+void NaClAppThreadPrintInfo(struct NaClAppThread *natp) {
+  NaClLog(1, "[NaClAppThreadPrintInfo] "
+          "cage id = %d, prog_ctr = %#x, new_prog_ctr = %#x, sysret = %#x\n",
+          natp->nap->cage_id,
+          (unsigned)natp->user.prog_ctr,
+          (unsigned)natp->user.new_prog_ctr,
+          (unsigned)natp->user.sysret);
+}
diff --git a/src/trusted/service_runtime/nacl_app_thread.h b/src/trusted/service_runtime/nacl_app_thread.h
index 62915239d22e0e505c..0ffed0d5115690288d 100644
--- a/src/trusted/service_runtime/nacl_app_thread.h
+++ b/src/trusted/service_runtime/nacl_app_thread.h
@@ -148,10 +148,13 @@ struct NaClAppThread {
    * Protected by mu
    */
   int                       dynamic_delete_generation;
 };
 
+struct NaClApp *NaClChildNapCtor(struct NaClAppThread *natp);
+
+void WINAPI NaClAppForkThreadLauncher(void *state);
 void WINAPI NaClAppThreadLauncher(void *state);
 
 void NaClAppThreadTeardown(struct NaClAppThread *natp);
 
 /*
@@ -177,10 +180,18 @@ int NaClAppThreadSpawn(struct NaClApp *nap,
                        uintptr_t      usr_entry,
                        uintptr_t      usr_stack_ptr,
                        uint32_t       user_tls1,
                        uint32_t       user_tls2) NACL_WUR;
 
+int NaClAppForkThreadSpawn(struct NaClApp           *nap_parent,
+                           struct NaClAppThread     *natp_parent,
+                           struct NaClApp           *nap_child,
+                           uintptr_t                usr_entry,
+                           uintptr_t                usr_stack_ptr,
+                           uint32_t                 user_tls1,
+                           uint32_t                 user_tls2) NACL_WUR;
+
 void NaClAppThreadDelete(struct NaClAppThread *natp);
 
 /*
  * This function can be called from the thread hosting the
  * NaClAppThread.  It can be used to switch between the states
@@ -194,8 +205,10 @@ static INLINE struct NaClAppThread *NaClAppThreadFromThreadContext(
     struct NaClThreadContext *ntcp) {
   NACL_COMPILE_TIME_ASSERT(offsetof(struct NaClAppThread, user) == 0);
   return (struct NaClAppThread *) ntcp;
 }
 
+void NaClAppThreadPrintInfo(struct NaClAppThread *natp);
+
 EXTERN_C_END
 
 #endif  /* NATIVE_CLIENT_SERVICE_RUNTIME_NACL_APP_THREAD_H__ */
diff --git a/src/trusted/service_runtime/nacl_globals.c b/src/trusted/service_runtime/nacl_globals.c
index 9db140d42f084ce8bc..a2c0dcb8ba57efe716 100644
--- a/src/trusted/service_runtime/nacl_globals.c
+++ b/src/trusted/service_runtime/nacl_globals.c
@@ -15,10 +15,11 @@
 #include "native_client/src/shared/platform/nacl_threads.h"
 #include "native_client/src/trusted/service_runtime/arch/sel_ldr_arch.h"
 #include "native_client/src/trusted/service_runtime/nacl_app.h"
 #include "native_client/src/trusted/service_runtime/nacl_app_thread.h"
 #include "native_client/src/trusted/service_runtime/nacl_globals.h"
+#include "native_client/src/trusted/service_runtime/include/bits/nacl_syscalls.h"
 
 struct NaClThreadContext    *nacl_user[NACL_THREAD_MAX] = {NULL};
 #if NACL_WINDOWS
 uint32_t                    nacl_thread_ids[NACL_THREAD_MAX] = {0};
 #endif
@@ -27,12 +28,15 @@ uint32_t                    nacl_thread_ids[NACL_THREAD_MAX] = {0};
  * Hack for gdb.  This records xlate_base in a place where (1) gdb can find it,
  * and (2) gdb doesn't need debug info (it just needs symbol info).
  */
 uintptr_t                   nacl_global_xlate_base;
 
+int nacl_syscall_counter;
+int nacl_syscall_trace_level_counter;
+int nacl_syscall_invoked_times[NACL_MAX_SYSCALLS];
+double nacl_syscall_execution_time[NACL_MAX_SYSCALLS];
+
 void NaClGlobalModuleInit(void) {
   NaClInitGlobals();
 }
 
-
-void  NaClGlobalModuleFini(void) {
-}
+void NaClGlobalModuleFini(void) { /* no-op */ }
diff --git a/src/trusted/service_runtime/nacl_globals.h b/src/trusted/service_runtime/nacl_globals.h
index 0944bef997e1ba5b7d..81d6284c274b28c843 100644
--- a/src/trusted/service_runtime/nacl_globals.h
+++ b/src/trusted/service_runtime/nacl_globals.h
@@ -6,24 +6,106 @@
 
 /*
  * NaCl Server Runtime globals.
  */
 
+// yiwen: enable system call timing with SYSCALL_TIMING
+// #define SYSCALL_TIMING
+
+// yiwen: enable printing out debug info inside functions in NaCl runtime
+#ifdef _DEBUG
+# define DEBUG_INFO_ENABLED
+#endif
+
+// yiwen: enable printing out system call tracing info for NaCl irt calls
+// #define NACL_SYSCALL_TRACE_ENABLED
+
+
 #ifndef NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_NACL_GLOBALS_H__
 #define NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_NACL_GLOBALS_H__
 
 #include "native_client/src/include/portability.h"
 #include "native_client/src/shared/platform/nacl_check.h"
 #include "native_client/src/trusted/service_runtime/arch/sel_ldr_arch.h"
+#include "native_client/src/trusted/service_runtime/include/bits/nacl_syscalls.h"
 #include "native_client/src/trusted/service_runtime/nacl_app_thread.h"
+#include "native_client/src/trusted/service_runtime/nacl_config.h"
+#include "native_client/src/shared/platform/lind_platform.h"
 
 EXTERN_C_BEGIN
+/* snprintf length limit for each argv string */
+#define ARG_LIMIT (1u << 12)
+#define SHM_SIZE (1u << 13)
+#define PROT_RW (NACL_ABI_PROT_READ|NACL_ABI_PROT_WRITE)
+#define PROT_RX (NACL_ABI_PROT_READ|NACL_ABI_PROT_EXEC)
+#define F_ANON_PRIV (NACL_ABI_MAP_PRIVATE|NACL_ABI_MAP_ANONYMOUS)
+#ifndef SIZE_T_MAX
+# define SIZE_T_MAX (~(size_t)0)
+#endif
+#define LD_FILE "/lib/glibc/runnable-ld.so"
+#define UNTRUSTED_ADDR_MASK 0xffffffffu
+
+/* extract uint64_t object representation */
+#define OBJ_REP_64(X) (((uint64_t)(X)[0] << (0 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[1] << (1 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[2] << (2 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[3] << (3 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[4] << (4 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[5] << (5 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[6] << (6 * CHAR_BIT))	\
+                     | ((uint64_t)(X)[7] << (7 * CHAR_BIT)))
+
+enum {
+        PIPE_NUM_MAX = 1u << 4,
+        CACHED_LIB_NUM_MAX = 1u << 5,
+        CAGING_LIB_PATH_MAX = 1u << 6,
+        FILE_DESC_MAX = 1u << 8,
+        CHILD_NUM_MAX = 1u << 8,
+        CAGING_FD_NUM  = 1u << 8,
+        PIPE_BUF_MAX = 1u << 16
+};
+
+// yiwen: define struct for storing the <file_path, mem_addr> relation
+//        which is being used by our "shared libs caching" mechanism
+struct CachedLibTable {
+  char path[CAGING_LIB_PATH_MAX];
+  void *mem_addr;
+};
+
 struct NaClThreadContext;
 struct NaClAppThread;
 struct NaClMutex;
 struct NaClApp;
 
+/*
+ * always points at original program context
+ */
+extern struct NaClThreadContext *master_ctx;
+
+extern int nacl_syscall_counter;
+extern int nacl_syscall_invoked_times[NACL_MAX_SYSCALLS];
+extern int nacl_syscall_trace_level_counter;
+extern double nacl_syscall_execution_time[NACL_MAX_SYSCALLS];
+extern int lind_syscall_counter;
+extern int lind_syscall_invoked_times[NACL_MAX_SYSCALLS];
+extern double lind_syscall_execution_time[NACL_MAX_SYSCALLS];
+
+extern int cage;
+extern double time_counter;
+extern double time_start;
+extern double time_end;
+
+// yiwen: this is the lookup table used, when checking if a lib has already been loaded previously,
+//        and will contain the shared memory address for the lib if it has been loaded before.
+extern struct CachedLibTable cached_lib_table[CACHED_LIB_NUM_MAX];
+extern int cached_lib_num;
+
+// yiwen: global pipe buffer
+extern char pipe_buffer[PIPE_NUM_MAX][PIPE_BUF_MAX];
+extern int pipe_mutex[PIPE_NUM_MAX];
+extern int pipe_transfer_over[PIPE_NUM_MAX];
+
 #if NACL_WINDOWS
 __declspec(dllexport)
 /*
  * This array is exported so that it can be used by a debugger.  However, it is
  * not a stable interface and it may change or be removed in the future.  A
@@ -54,12 +136,21 @@ void  NaClGlobalModuleInit(void);
 void  NaClGlobalModuleFini(void);
 
 /* this is defined in src/trusted/service_runtime/arch/<arch>/ sel_rt.h */
 void NaClInitGlobals(void);
 
-static INLINE struct NaClAppThread *NaClAppThreadGetFromIndex(
-    uint32_t thread_index) {
+static INLINE void NaClPatchAddr(uintptr_t child_bits, uintptr_t parent_bits, uintptr_t *start, size_t cnt) {
+  for (size_t i = 0; i < cnt; i++) {
+    if ((parent_bits >> NACL_PAGESHIFT) != (start[i] >> NACL_PAGESHIFT))
+      continue;
+    NaClLog(1, "patching %p\n", (void *)start[i]);
+    start[i] = child_bits | (start[i] & UNTRUSTED_ADDR_MASK);
+    NaClLog(1, "new addr %p\n", (void *)start[i]);
+  }
+}
+
+static INLINE struct NaClAppThread *NaClAppThreadGetFromIndex(uint32_t thread_index) {
   DCHECK(thread_index < NACL_THREAD_MAX);
   return NaClAppThreadFromThreadContext(nacl_user[thread_index]);
 }
 
 /* hack for gdb */
diff --git a/src/trusted/service_runtime/nacl_syscall_common.c b/src/trusted/service_runtime/nacl_syscall_common.c
index 6f16f2c3eca3674f44..4a1ca0b9cbf9ccb3aa 100644
--- a/src/trusted/service_runtime/nacl_syscall_common.c
+++ b/src/trusted/service_runtime/nacl_syscall_common.c
@@ -2,18 +2,37 @@
  * Copyright (c) 2012 The Native Client Authors. All rights reserved.
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file.
  */
 
+#ifdef _POSIX_C_SOURCE
+#  undef _POSIX_C_SOURCE
+#endif
+#ifdef _XOPEN_SOURCE
+#  undef _XOPEN_SOURCE
+#endif
+
 /*
  * NaCl service run-time, non-platform specific system call helper routines.
  */
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <unistd.h>
+
+#ifdef _POSIX_C_SOURCE
+#  undef _POSIX_C_SOURCE
+#endif
+#ifdef _XOPEN_SOURCE
+#  undef _XOPEN_SOURCE
+#endif
 
 #include <stdio.h>
 #include <Python.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <time.h>
 
 #include "native_client/src/trusted/service_runtime/nacl_syscall_common.h"
 
 #include "native_client/src/include/nacl_assert.h"
 #include "native_client/src/include/nacl_macros.h"
@@ -24,10 +43,11 @@
 #include "native_client/src/shared/platform/nacl_check.h"
 #include "native_client/src/shared/platform/nacl_clock.h"
 #include "native_client/src/shared/platform/nacl_exit.h"
 #include "native_client/src/shared/platform/nacl_host_desc.h"
 #include "native_client/src/shared/platform/nacl_host_dir.h"
+#include "native_client/src/shared/platform/nacl_log.h"
 #include "native_client/src/shared/platform/nacl_sync_checked.h"
 #include "native_client/src/shared/platform/nacl_time.h"
 
 #include "native_client/src/trusted/desc/nacl_desc_base.h"
 #include "native_client/src/trusted/desc/nacl_desc_cond.h"
@@ -64,44 +84,117 @@
 #include "native_client/src/trusted/service_runtime/sel_memory.h"
 #include "native_client/src/trusted/service_runtime/thread_suspension.h"
 #include "native_client/src/trusted/service_runtime/win/debug_exception_handler.h"
 
 #if NACL_WINDOWS
-#include "native_client/src/trusted/service_runtime/win/debug_exception_handler.h"
-#include "native_client/src/shared/platform/win/xlate_system_error.h"
+#  include "native_client/src/trusted/service_runtime/win/debug_exception_handler.h"
+#  include "native_client/src/shared/platform/win/xlate_system_error.h"
 #endif
 
 #include "native_client/src/trusted/validator/ncvalidate.h"
 #include "native_client/src/trusted/validator/validation_metadata.h"
+#include "native_client/src/trusted/service_runtime/env_cleanser.h"
+#include "native_client/src/trusted/service_runtime/lind_syscalls.h"
+#include "native_client/src/trusted/service_runtime/nacl_all_modules.h"
+#include "native_client/src/trusted/service_runtime/nacl_app.h"
+#include "native_client/src/trusted/service_runtime/load_file.h"
+
+
+#define kKnownInvalidDescNumber (-1)
+#define kdefault_io_buffer_bytes_to_log 64ull
+#define kMaxUsableFileSize (SIZE_MAX >> 1)
+
+#define MIN(a, b) ((size_t)((a < b) ? a : b))
 
 struct NaClDescQuotaInterface;
 
-static size_t const kdefault_io_buffer_bytes_to_log = 64;
+struct NaClSyscallTableEntry nacl_syscall[NACL_MAX_SYSCALLS];
 
-static int32_t MunmapInternal(struct NaClApp *nap,
-                              uintptr_t sysaddr, size_t length);
+#if NACL_WINDOWS
+  static int32_t MunmapInternal(struct NaClApp *nap, uintptr_t sysaddr, size_t length) {
+    uintptr_t addr;
+    uintptr_t endaddr = sysaddr + length;
+    uintptr_t usraddr;
+    for (addr = sysaddr; addr < endaddr; addr += NACL_MAP_PAGESIZE) {
+      struct NaClVmmapEntry const *entry;
+      uintptr_t                   page_num;
+      uintptr_t                   offset;
 
-/*
- * OSX defines SIZE_T_MAX in i386/limits.h; Linux has SIZE_MAX;
- * Windows has none.
- *
- * TODO(bsy): remove when we put SIZE_T_MAX in a common header file.
- */
-#if !defined(SIZE_T_MAX)
-# define SIZE_T_MAX   (~(size_t) 0)
-#endif
+      usraddr = NaClSysToUser(nap, addr);
 
-static const size_t kMaxUsableFileSize = (SIZE_T_MAX >> 1);
+      entry = NaClVmmapFindPage(&nap->mem_map, usraddr >> NACL_PAGESHIFT);
+      if (!entry) {
+        continue;
+      }
+      NaClLog(2, "NaClSysMunmap: addr 0x%08x, desc 0x%08"NACL_PRIxPTR"\n",
+              addr, (uintptr_t)entry->desc);
 
-static INLINE size_t  size_min(size_t a, size_t b) {
-  return (a < b) ? a : b;
-}
-
-static int const kKnownInvalidDescNumber = -1;
-
-struct NaClSyscallTableEntry nacl_syscall[NACL_MAX_SYSCALLS] = {{0}};
+      page_num = usraddr - (entry->page_num << NACL_PAGESHIFT);
+      offset = (uintptr_t) entry->offset + page_num;
 
+      if (entry->desc &&
+          offset < (uintptr_t) entry->file_size) {
+        if (!UnmapViewOfFile((void *) addr)) {
+          NaClLog(1, "MunmapInternal: UnmapViewOfFile failed to at addr"
+                  " 0x%08"NACL_PRIxPTR", error %d\n",
+                  addr, GetLastError());
+        }
+        /*
+        * Fill the address space hole that we opened
+        * with UnmapViewOfFile().
+        */
+        if (!VirtualAlloc((void *) addr, NACL_MAP_PAGESIZE, MEM_RESERVE,
+                          PAGE_READWRITE)) {
+          NaClLog(LOG_FATAL, "MunmapInternal: "
+                  "failed to fill hole with VirtualAlloc(), error %d\n",
+                  GetLastError());
+        }
+      } else {
+        /*
+         * Anonymous memory; we just decommit it and thus
+         * make it inaccessible.
+         */
+        if (!VirtualFree((void *) addr,
+                         NACL_MAP_PAGESIZE,
+                         MEM_DECOMMIT)) {
+          int error = GetLastError();
+          NaClLog(LOG_FATAL,
+                  ("MunmapInternal: Could not VirtualFree MEM_DECOMMIT"
+                   " addr 0x%08x, error %d (0x%x)\n"),
+                  addr, error, error);
+        }
+      }
+      NaClVmmapRemove(&nap->mem_map,
+                      usraddr >> NACL_PAGESHIFT,
+                      NACL_PAGES_PER_MAP);
+    }
+    return 0;
+  }
+#else /* NACL_WINDOWS */
+  static int32_t MunmapInternal(struct NaClApp *nap, uintptr_t sysaddr, size_t length) {
+    UNREFERENCED_PARAMETER(nap);
+    NaClLog(3, "MunmapInternal(0x%08"NACL_PRIxPTR", 0x%"NACL_PRIxS")\n", sysaddr, length);
+    /*
+     * Overwrite current mapping with inaccessible, anonymous
+     * zero-filled pages, which should be copy-on-write and thus
+     * relatively cheap.  Do not open up an address space hole.
+     */
+    if (MAP_FAILED == mmap((void *) sysaddr,
+                           length,
+                           PROT_NONE,
+                           MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
+                           -1,
+                           (off_t) 0)) {
+      NaClLog(2, "mmap to put in anonymous memory failed, errno = %d\n", errno);
+      return -NaClXlateErrno(errno);
+    }
+    NaClVmmapRemove(&nap->mem_map,
+                    NaClSysToUser(nap, sysaddr) >> NACL_PAGESHIFT,
+                    length >> NACL_PAGESHIFT);
+    return 0;
+  }
+#endif /* NACL_WINDOWS */
 
 int32_t NaClSysNotImplementedDecoder(struct NaClAppThread *natp) {
   NaClCopyDropLock(natp->nap);
   return -NACL_ABI_ENOSYS;
 }
@@ -226,11 +319,11 @@ int32_t NaClSysBrk(struct NaClAppThread *natp,
       /* go ahead and extend ent to cover, and make pages accessible */
       start_new_region = (ent->page_num + ent->npages) << NACL_PAGESHIFT;
       ent->npages = (last_internal_page - ent->page_num + 1);
       region_size = (((last_internal_page + 1) << NACL_PAGESHIFT)
                      - start_new_region);
-      if (0 != NaClMprotect((void *) NaClUserToSys(nap, start_new_region),
+      if (NaClMprotect((void *) NaClUserToSys(nap, start_new_region),
                             region_size,
                             PROT_READ | PROT_WRITE)) {
         NaClLog(LOG_FATAL,
                 ("Could not mprotect(0x%08"NACL_PRIxPTR", "
                  "0x%08"NACL_PRIxPTR", "
@@ -300,13 +393,11 @@ int32_t NaClOpenAclCheck(struct NaClApp *nap,
   if (3 < NaClLogGetVerbosity()) {
     NaClLog(0, "O_ACCMODE: 0%o\n", flags & NACL_ABI_O_ACCMODE);
     NaClLog(0, "O_RDONLY = %d\n", NACL_ABI_O_RDONLY);
     NaClLog(0, "O_WRONLY = %d\n", NACL_ABI_O_WRONLY);
     NaClLog(0, "O_RDWR   = %d\n", NACL_ABI_O_RDWR);
-#define FLOG(VAR, BIT) do {\
-      NaClLog(1, "%s: %s\n", #BIT, (VAR & BIT) ? "yes" : "no");\
-    } while (0)
+#define FLOG(VAR, BIT) NaClLog(1, "%s: %s\n", #BIT, ((VAR) & (BIT)) ? "yes" : "no")
     FLOG(flags, NACL_ABI_O_CREAT);
     FLOG(flags, NACL_ABI_O_TRUNC);
     FLOG(flags, NACL_ABI_O_APPEND);
 #undef FLOG
   }
@@ -348,18 +439,14 @@ int32_t NaClIoctlAclCheck(struct NaClApp  *nap,
   return -NACL_ABI_EINVAL;
 }
 
 int32_t NaClSysGetpid(struct NaClAppThread *natp) {
   int32_t pid;
-  UNREFERENCED_PARAMETER(natp);
+  struct NaClApp *nap = natp->nap;
 
-  if (NaClAclBypassChecks) {
-    pid = GETPID();
-  } else {
-    pid = -NACL_ABI_EACCES;
-  }
-  NaClLog(4, "NaClSysGetpid: returning %d\n", pid);
+  pid = nap->cage_id;
+  NaClLog(1, "NaClSysGetpid: returning %d\n", pid);
 
   return pid;
 }
 
 int32_t NaClSysExit(struct NaClAppThread  *natp,
@@ -386,20 +473,16 @@ int32_t NaClSysThreadExit(struct NaClAppThread  *natp,
   /*
    * NB: NaClThreads are never joinable, but the abstraction for NaClApps
    * are.
    */
 
-  if (NULL != stack_flag) {
-    NaClLog(4,
-            "NaClSysThreadExit: stack_flag is %"NACL_PRIxPTR"\n",
-            (uintptr_t) stack_flag);
-    if (!NaClCopyOutToUser(natp->nap, (uintptr_t) stack_flag,
-                           &zero, sizeof zero)) {
-      NaClLog(4,
-              ("NaClSysThreadExit: ignoring invalid"
-               " stack_flag 0x%"NACL_PRIxPTR"\n"),
-              (uintptr_t) stack_flag);
+  if (stack_flag) {
+    NaClLog(2, "aClSysThreadExit: stack_flag is %"NACL_PRIxPTR"\n", (uintptr_t)stack_flag);
+    if (!NaClCopyOutToUser(natp->nap, (uintptr_t) stack_flag, &zero, sizeof zero)) {
+      NaClLog(2, "NaClSysThreadExit: ignoring invalid"
+               " stack_flag 0x%"NACL_PRIxPTR"\n",
+               (uintptr_t)stack_flag);
     }
   }
 
   NaClAppThreadTeardown(natp);
   /* NOTREACHED */
@@ -435,11 +518,11 @@ int32_t NaClSysNameService(struct NaClAppThread *natp,
       retval = -NACL_ABI_EFAULT;
     }
   } else {
     struct NaClDesc *desc_obj_ptr = NaClGetDesc(nap, desc);
 
-    if (NULL == desc_obj_ptr) {
+    if (!desc_obj_ptr) {
       retval = -NACL_ABI_EBADF;
       goto done;
     }
     if (NACL_DESC_CONN_CAP != NACL_VTBL(NaClDesc, desc_obj_ptr)->typeTag &&
         NACL_DESC_CONN_CAP_FD != NACL_VTBL(NaClDesc, desc_obj_ptr)->typeTag) {
@@ -456,58 +539,93 @@ int32_t NaClSysNameService(struct NaClAppThread *natp,
 
  done:
   return retval;
 }
 
-int32_t NaClSysDup(struct NaClAppThread *natp,
-                   int                  oldfd) {
+int32_t NaClSysDup(struct NaClAppThread *natp, int oldfd) {
   struct NaClApp  *nap = natp->nap;
-  int             retval;
+  int             ret, newfd;
   struct NaClDesc *old_nd;
 
-  NaClLog(3, "NaClSysDup(0x%08"NACL_PRIxPTR", %d)\n",
-          (uintptr_t) natp, oldfd);
-  old_nd = NaClGetDesc(nap, oldfd);
-  if (NULL == old_nd) {
-    retval = -NACL_ABI_EBADF;
+  NaClLog(1, "NaClSysDup(0x%08"NACL_PRIxPTR", %d)\n", (uintptr_t)natp, oldfd);
+
+  if (nap->fd > FILE_DESC_MAX) {
+    ret = -NACL_ABI_EBADF;
     goto done;
   }
-  retval = NaClSetAvail(nap, old_nd);
+  if (!(old_nd = NaClGetDesc(nap, oldfd))) {
+    ret= -NACL_ABI_EBADF;
+    goto done;
+  }
+  ret = newfd = NaClSetAvail(nap, old_nd);
+  NaClSetDesc(nap, newfd, old_nd);
+  fd_cage_table[nap->cage_id][newfd] = fd_cage_table[nap->cage_id][oldfd];
+  nap->fd++;
+
 done:
-  return retval;
+  return ret;
 }
 
 int32_t NaClSysDup2(struct NaClAppThread  *natp,
                     int                   oldfd,
                     int                   newfd) {
-  struct NaClApp  *nap = natp->nap;
-  int             retval;
-  struct NaClDesc *old_nd;
+  struct NaClApp *nap = natp->nap;
+  int            ret;
 
-  NaClLog(3, "NaClSysDup(0x%08"NACL_PRIxPTR", %d, %d)\n",
-          (uintptr_t) natp, oldfd, newfd);
-  if (newfd < 0) {
-    retval = -NACL_ABI_EINVAL;
+  NaClLog(1, "%s\n", "[dup2] Entered dup2!");
+  NaClLog(1, "[dup2] cage id = %d \n", nap->cage_id);
+  NaClLog(1, "[dup2] oldfd = %d \n", oldfd);
+  NaClLog(1, "[dup2] newfd = %d \n", newfd);
+
+  if (oldfd == newfd) {
+    ret = oldfd;
     goto done;
   }
-  /*
-   * TODO(bsy): is this a reasonable largest sane value?  The
-   * descriptor array shouldn't get too large.
-   */
-  if (newfd >= NACL_MAX_FD) {
-    retval = -NACL_ABI_EINVAL;
+  if (nap->fd > FILE_DESC_MAX) {
+    ret = -NACL_ABI_EBADF;
     goto done;
   }
-  old_nd = NaClGetDesc(nap, oldfd);
-  if (NULL == old_nd) {
-    retval = -NACL_ABI_EBADF;
-    goto done;
-  }
-  NaClSetDesc(nap, newfd, old_nd);
-  retval = newfd;
+  fd_cage_table[nap->cage_id][newfd] = fd_cage_table[nap->cage_id][oldfd];
+  ret = newfd;
+  nap->fd++;
+
 done:
-  return retval;
+  return ret;
+}
+
+// yiwen: my dup3 implementation
+int32_t NaClSysDup3(struct NaClAppThread  *natp,
+                    int                   oldfd,
+                    int                   newfd,
+                    int                   flags) {
+  struct NaClApp  *nap = natp->nap;
+  int             ret;
+
+  NaClLog(1, "%s\n", "[dup3] Entered dup3!");
+  NaClLog(1, "[dup3] cage id = %d \n", nap->cage_id);
+  NaClLog(1, "[dup3] oldfd = %d \n", oldfd);
+  NaClLog(1, "[dup3] newfd = %d \n", newfd);
+
+  /*
+   * TODO: implement flags -jp
+   */
+  UNREFERENCED_PARAMETER(flags);
+
+  if (oldfd == newfd) {
+    ret = -NACL_ABI_EINVAL;
+    goto done;
+  }
+  if (nap->fd++ > FILE_DESC_MAX) {
+    ret = -NACL_ABI_EBADF;
+    goto done;
+  }
+  fd_cage_table[nap->cage_id][nap->fd] = fd_cage_table[nap->cage_id][oldfd];
+  ret = newfd;
+  nap->fd++;
+
+done:
+  return ret;
 }
 
 static uint32_t CopyPathFromUser(struct NaClApp *nap,
                                  char           *dest,
                                  size_t         num_bytes,
@@ -536,34 +654,53 @@ int32_t NaClSysOpen(struct NaClAppThread  *natp,
   struct NaClApp       *nap = natp->nap;
   uint32_t             retval = -NACL_ABI_EINVAL;
   char                 path[NACL_CONFIG_PATH_MAX];
   nacl_host_stat_t     stbuf;
   int                  allowed_flags;
+  const char           glibc_prefix[] = "/lib/glibc/";
+  const char           tls_prefix[] = "/lib/glibc/tls/";
+  const size_t         tls_start_idx = strlen(glibc_prefix);
+  const size_t         tls_end_idx = strlen(tls_prefix);
 
-  NaClLog(3, "NaClSysOpen(0x%08"NACL_PRIxPTR", "
+  int                  fd_retval; // this is the virtual fd returned to the cage
+
+  NaClLog(2, "NaClSysOpen(0x%08"NACL_PRIxPTR", "
           "0x%08"NACL_PRIxPTR", 0x%x, 0x%x)\n",
-          (uintptr_t) natp, (uintptr_t) pathname, flags, mode);
+          (uintptr_t)natp, (uintptr_t)pathname, flags, mode);
 
-  retval = CopyPathFromUser(nap, path, sizeof path, (uintptr_t) pathname);
-  if (0 != retval)
+  retval = CopyPathFromUser(nap, path, sizeof path, (uintptr_t)pathname);
+
+  /*
+   * TODO:
+   * fix this hacky method to remove incorrect
+   * linker searches for shared libraries in
+   * /lib/glibc/tls/ (doesn't exist)
+   *
+   * -jp
+   */
+  if (!memcmp(path, tls_prefix, sizeof tls_prefix - 1)) {
+    memmove(path + tls_start_idx, path + tls_end_idx, strlen(path) + tls_end_idx + 1);
+  }
+
+  if (retval) {
     goto cleanup;
+  }
 
   allowed_flags = (NACL_ABI_O_ACCMODE | NACL_ABI_O_CREAT
                    | NACL_ABI_O_TRUNC | NACL_ABI_O_APPEND);
-  if (0 != (flags & ~allowed_flags)) {
-    NaClLog(LOG_WARNING, "Invalid open flags 0%o, ignoring extraneous bits\n",
-            flags);
+  if (flags & ~allowed_flags) {
+    NaClLog(1, "Invalid open flags 0%o, ignoring extraneous bits\n", flags);
     flags &= allowed_flags;
   }
-  if (0 != (mode & ~0600)) {
+  if (mode & ~0600) {
     NaClLog(1, "IGNORING Invalid access mode bits 0%o\n", mode);
     mode &= 0600;
   }
 
   retval = NaClOpenAclCheck(nap, path, flags, mode);
-  if (0 != retval) {
-    NaClLog(3, "Open ACL check rejected \"%s\".\n", path);
+  if (retval) {
+    NaClLog(2, "Open ACL check rejected \"%s\".\n", path);
     goto cleanup;
   }
 
   /*
    * Perform a stat to determine whether the file is a directory.
@@ -576,72 +713,96 @@ int32_t NaClSysOpen(struct NaClAppThread  *natp,
    * path refers to can change.
    */
   retval = NaClHostDescStat(path, &stbuf);
 
   /* Windows does not have S_ISDIR(m) macro */
-  if (0 == retval && S_IFDIR == (S_IFDIR & stbuf.st_mode)) {
+  if (!retval && S_IFDIR == (S_IFDIR & stbuf.st_mode)) {
     struct NaClHostDir  *hd;
 
     hd = malloc(sizeof *hd);
-    if (NULL == hd) {
+    if (!hd) {
       retval = -NACL_ABI_ENOMEM;
       goto cleanup;
     }
     retval = NaClHostDirOpen(hd, path);
     NaClLog(1, "NaClHostDirOpen(0x%08"NACL_PRIxPTR", %s) returned %d\n",
             (uintptr_t) hd, path, retval);
-    if (0 == retval) {
-      retval = NaClSetAvail(nap,
-                            ((struct NaClDesc *) NaClDescDirDescMake(hd)));
-      NaClLog(1, "Entered directory into open file table at %d\n",
-              retval);
+    if (!retval) {
+      retval = NaClSetAvail(nap, ((struct NaClDesc *) NaClDescDirDescMake(hd)));
+      NaClLog(1, "Entered directory into open file table at %d\n", retval);
     }
   } else {
     struct NaClHostDesc  *hd;
 
     hd = malloc(sizeof *hd);
-    if (NULL == hd) {
+    if (!hd) {
       retval = -NACL_ABI_ENOMEM;
       goto cleanup;
     }
     retval = NaClHostDescOpen(hd, path, flags, mode);
-    NaClLog(1,
-            "NaClHostDescOpen(0x%08"NACL_PRIxPTR", %s, 0%o, 0%o) returned %d\n",
+    NaClLog(1, "NaClHostDescOpen(0x%08"NACL_PRIxPTR", %s, 0%o, 0%o) returned %d\n",
             (uintptr_t) hd, path, flags, mode, retval);
-    if (0 == retval) {
-      retval = NaClSetAvail(nap,
-                            ((struct NaClDesc *) NaClDescIoDescMake(hd)));
+    if (!retval) {
+      retval = NaClSetAvail(nap, ((struct NaClDesc *) NaClDescIoDescMake(hd)));
       NaClLog(1, "Entered into open file table at %d\n", retval);
     }
   }
+
 cleanup:
-  return retval;
+  // yiwen: now translate the real fds to virtual fds and return them to the cage
+  fd_cage_table[nap->cage_id][nap->fd] = retval;
+  fd_retval = nap->fd;
+  nap->fd++;
+
+  // yiwen: register the fd and lib_path info for the cage, in lib_table[CACHED_LIB_NUM_MAX]
+  //        this will be used when trying to check if a lib has been cached in our system
+  // yiwen: do sanity check for the given fd first before our registration
+  if (fd_retval > CACHED_LIB_NUM_MAX) {
+     strncpy(nap->lib_table[fd_retval].path, path, strlen(path) + 1);
+     nap->num_lib++;
+  }
+
+  NaClLog(1, "[*** Debug ***][Open] fd = %d, filepath = %s \n", fd_retval, path);
+
+  return fd_retval;
 }
 
-int32_t NaClSysClose(struct NaClAppThread *natp,
-                     int                  d) {
+int32_t NaClSysClose(struct NaClAppThread *natp, int d) {
   struct NaClApp  *nap = natp->nap;
-  int             retval = -NACL_ABI_EBADF;
-  struct NaClDesc *ndp;
+  struct NaClDesc *ndp = NULL;
+  int             ret = -NACL_ABI_EBADF;
+  int             fd = 0;
 
-  NaClLog(3, "Entered NaClSysClose(0x%08"NACL_PRIxPTR", %d)\n",
+  NaClLog(1, "Entered NaClSysClose(0x%08"NACL_PRIxPTR", %d)\n",
           (uintptr_t) natp, d);
 
   NaClFastMutexLock(&nap->desc_mu);
-  ndp = NaClGetDescMu(nap, d);
-  if (NULL != ndp) {
-    NaClSetDescMu(nap, d, NULL);  /* Unref the desc_tbl */
+
+  /*
+   * only close master fds
+   *
+   * FIXME: maybe there is a better way to avoid
+   * segfaults trying to close child fds... -jp
+   */
+  if (nap->cage_id > 1) {
+     NaClLog(1, "cage_id: %d\n", nap->cage_id);
+     ret = 0;
+     goto out;
   }
-  NaClFastMutexUnlock(&nap->desc_mu);
-  NaClLog(5, "Invoking Close virtual function of object 0x%08"NACL_PRIxPTR"\n",
-          (uintptr_t) ndp);
-  if (NULL != ndp) {
+  fd = fd_cage_table[nap->cage_id][d];
+
+  /* Unref the desc_tbl */
+  if ((ndp = NaClGetDescMu(nap, fd))) {
+    NaClLog(1, "Invoking Close virtual function of object 0x%08"NACL_PRIxPTR"\n", (uintptr_t) ndp);
+    NaClSetDescMu(nap, d, NULL);
     NaClDescUnref(ndp);
-    retval = 0;
+    ret = 0;
   }
 
-  return retval;
+out:
+  NaClFastMutexUnlock(&nap->desc_mu);
+  return ret;
 }
 
 int32_t NaClSysGetdents(struct NaClAppThread *natp,
                         int                  d,
                         void                 *dirp,
@@ -650,18 +811,21 @@ int32_t NaClSysGetdents(struct NaClAppThread *natp,
   int32_t         retval = -NACL_ABI_EINVAL;
   ssize_t         getdents_ret;
   uintptr_t       sysaddr;
   struct NaClDesc *ndp;
 
-  NaClLog(3,
-          ("Entered NaClSysGetdents(0x%08"NACL_PRIxPTR", "
-           "%d, 0x%08"NACL_PRIxPTR", "
-           "%"NACL_PRIdS"[0x%"NACL_PRIxS"])\n"),
+  int fd;
+
+  NaClLog(1, "Entered NaClSysGetdents(0x%08"NACL_PRIxPTR","
+          " %d, 0x%08"NACL_PRIxPTR","
+          " %"NACL_PRIdS"[0x%"NACL_PRIxS"])\n",
           (uintptr_t) natp, d, (uintptr_t) dirp, count, count);
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
+  fd = fd_cage_table[nap->cage_id][d];
+
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   /*
@@ -720,25 +884,26 @@ cleanup:
 int32_t NaClSysRead(struct NaClAppThread  *natp,
                     int                   d,
                     void                  *buf,
                     size_t                count) {
   struct NaClApp  *nap = natp->nap;
+  int             fd = fd_cage_table[nap->cage_id][d];
   int32_t         retval = -NACL_ABI_EINVAL;
   ssize_t         read_result = -NACL_ABI_EINVAL;
   uintptr_t       sysaddr;
   struct NaClDesc *ndp;
   size_t          log_bytes;
   char const      *ellipsis = "";
 
-  NaClLog(3,
-          ("Entered NaClSysRead(0x%08"NACL_PRIxPTR", "
+  NaClLog(2, "Entered NaClSysRead(0x%08"NACL_PRIxPTR", "
            "%d, 0x%08"NACL_PRIxPTR", "
-           "%"NACL_PRIdS"[0x%"NACL_PRIxS"])\n"),
+           "%"NACL_PRIdS"[0x%"NACL_PRIxS"])\n",
           (uintptr_t) natp, d, (uintptr_t) buf, count, count);
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
+  ndp = NaClGetDesc(nap, fd);
+  NaClLog(2, " ndp = %"NACL_PRIxPTR"\n", (uintptr_t) ndp);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t) buf, count);
@@ -758,12 +923,18 @@ int32_t NaClSysRead(struct NaClAppThread  *natp,
   }
 
   NaClVmIoWillStart(nap,
                     (uint32_t) (uintptr_t) buf,
                     (uint32_t) (((uintptr_t) buf) + count - 1));
-  read_result = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
-                 Read)(ndp, (void *) sysaddr, count);
+  read_result = ((struct NaClDescVtbl const *)ndp->base.vtbl)->Read(ndp, (void *)sysaddr, count);
+  /* special case for pipe() */
+  if (read_result == -NACL_ABI_ENOSYS) {
+    read_result = read(fd, (void *)sysaddr, count);
+    if (read_result < 0) {
+      read_result = -errno;
+    }
+  }
   NaClVmIoHasEnded(nap,
                     (uint32_t) (uintptr_t) buf,
                     (uint32_t) (((uintptr_t) buf) + count - 1));
   if (read_result > 0) {
     NaClLog(4, "read returned %"NACL_PRIdS" bytes\n", read_result);
@@ -794,26 +965,26 @@ cleanup:
 int32_t NaClSysWrite(struct NaClAppThread *natp,
                      int                  d,
                      void                 *buf,
                      size_t               count) {
   struct NaClApp  *nap = natp->nap;
+  int             fd = fd_cage_table[nap->cage_id][d];
   int32_t         retval = -NACL_ABI_EINVAL;
   ssize_t         write_result = -NACL_ABI_EINVAL;
   uintptr_t       sysaddr;
   char const      *ellipsis = "";
   struct NaClDesc *ndp;
   size_t          log_bytes;
 
-  NaClLog(3,
-          "Entered NaClSysWrite(0x%08"NACL_PRIxPTR", "
+  NaClLog(2, "Entered NaClSysWrite(0x%08"NACL_PRIxPTR", "
           "%d, 0x%08"NACL_PRIxPTR", "
           "%"NACL_PRIdS"[0x%"NACL_PRIxS"])\n",
           (uintptr_t) natp, d, (uintptr_t) buf, count, count);
 
-  ndp = NaClGetDesc(nap, d);
-  NaClLog(4, " ndp = %"NACL_PRIxPTR"\n", (uintptr_t) ndp);
-  if (NULL == ndp) {
+  ndp = NaClGetDesc(nap, fd);
+  NaClLog(2, " ndp = %"NACL_PRIxPTR"\n", (uintptr_t) ndp);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t) buf, count);
@@ -821,46 +992,48 @@ int32_t NaClSysWrite(struct NaClAppThread *natp,
     NaClDescUnref(ndp);
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
 
-  log_bytes = count;
-  if (log_bytes > INT32_MAX) {
-    log_bytes = INT32_MAX;
-    ellipsis = "...";
-  }
-  if (NaClLogGetVerbosity() < 10) {
-    if (log_bytes > kdefault_io_buffer_bytes_to_log) {
-      log_bytes = kdefault_io_buffer_bytes_to_log;
-      ellipsis = "...";
-    }
-  }
-  NaClLog(8, "In NaClSysWrite(%d, %.*s%s, %"NACL_PRIdS")\n",
-          d, (int) log_bytes, (char *) sysaddr, ellipsis, count);
-
   /*
    * The maximum length for read and write is INT32_MAX--anything larger and
    * the return value would overflow. Passing larger values isn't an error--
    * we'll just clamp the request size if it's too large.
    */
-  if (count > INT32_MAX) {
-    count = INT32_MAX;
+  count = count > INT32_MAX ? INT32_MAX : count;
+  log_bytes = count;
+  if (log_bytes == INT32_MAX)
+    ellipsis = "...";
+  UNREFERENCED_PARAMETER(ellipsis);
+  if (NaClLogGetVerbosity() < 10 && log_bytes > kdefault_io_buffer_bytes_to_log) {
+     log_bytes = kdefault_io_buffer_bytes_to_log;
+     ellipsis = "...";
   }
+  UNREFERENCED_PARAMETER(log_bytes);
+  UNREFERENCED_PARAMETER(ellipsis);
+  NaClLog(2, "In NaClSysWrite(%d, %.*s%s, %"NACL_PRIdS")\n",
+          d, (int)log_bytes, (char *)sysaddr, ellipsis, count);
 
   NaClVmIoWillStart(nap,
-                    (uint32_t) (uintptr_t) buf,
-                    (uint32_t) (((uintptr_t) buf) + count - 1));
-  write_result = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
-                  Write)(ndp, (void *) sysaddr, count);
+                    (uint32_t)(uintptr_t)buf,
+                    (uint32_t)(((uintptr_t)buf) + count - 1));
+  write_result = ((struct NaClDescVtbl const *)ndp->base.vtbl)->Write(ndp, (void *)sysaddr, count);
+  /* special case for pipe() */
+  if (write_result == -NACL_ABI_ENOSYS) {
+    write_result = write(fd, (void *)sysaddr, count);
+    if (write_result < 0) {
+      write_result = -errno;
+    }
+  }
   NaClVmIoHasEnded(nap,
-                   (uint32_t) (uintptr_t) buf,
-                   (uint32_t) (((uintptr_t) buf) + count - 1));
+                   (uint32_t)(uintptr_t)buf,
+                   (uint32_t)(((uintptr_t)buf) + count - 1));
 
   NaClDescUnref(ndp);
 
   /* This cast is safe because we clamped count above.*/
-  retval = (int32_t) write_result;
+  retval = (int32_t)write_result;
 
 cleanup:
   return retval;
 }
 
@@ -875,18 +1048,20 @@ int32_t NaClSysLseek(struct NaClAppThread *natp,
   struct NaClApp  *nap = natp->nap;
   nacl_abi_off_t  offset;
   nacl_off64_t    retval64;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *ndp;
+  int             fd;
 
-  NaClLog(3,
-          ("Entered NaClSysLseek(0x%08"NACL_PRIxPTR", %d,"
-           " 0x%08"NACL_PRIxPTR", %d)\n"),
+  NaClLog(2, "Entered NaClSysLseek(0x%08"NACL_PRIxPTR", %d,"
+           " 0x%08"NACL_PRIxPTR", %d)\n",
           (uintptr_t) natp, d, (uintptr_t) offp, whence);
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
+  fd = fd_cage_table[nap->cage_id][d];
+
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   if (!NaClCopyInFromUser(nap, &offset, (uintptr_t) offp, sizeof offset)) {
@@ -919,16 +1094,16 @@ int32_t NaClSysIoctl(struct NaClAppThread *natp,
                      void                 *arg) {
   struct NaClApp  *nap = natp->nap;
   int             retval = -NACL_ABI_EINVAL;
   uintptr_t       sysaddr;
   struct NaClDesc *ndp;
+  int             fd;
 
-  NaClLog(3,
-          ("Entered NaClSysIoctl(0x%08"NACL_PRIxPTR
-           ", %d, %d, 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp, d, request,
-          (uintptr_t) arg);
+  NaClLog(2, "Entered NaClSysIoctl(0x%08"NACL_PRIxPTR
+           ", %d, %d, 0x%08"NACL_PRIxPTR")\n",
+           (uintptr_t)natp, d, request,
+           (uintptr_t)arg);
   /*
    * Note that NaClUserToSysAddrRange is not feasible right now, since
    * the size of the arg argument depends on the request.  We do not
    * have an enumeration of allowed ioctl requests yet.
    *
@@ -940,20 +1115,22 @@ int32_t NaClSysIoctl(struct NaClAppThread *natp,
    ****************************************
    * NOTE: sysaddr may be kNaClBadAddress *
    ****************************************
    */
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
-    NaClLog(4, "bad desc\n");
+  fd = fd_cage_table[nap->cage_id][d];
+
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
+    NaClLog(2, "%s\n", "bad desc");
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = NaClIoctlAclCheck(nap, ndp, request, arg);
-  if (0 != retval) {
-    NaClLog(3, "Ioctl ACL check rejected descriptor %d\n", d);
+  if (retval) {
+    NaClLog(2, "Ioctl ACL check rejected descriptor %d\n", d);
     goto cleanup_unref;
   }
 
   /*
    * We need a virtual function that, given request, returns max
@@ -980,31 +1157,32 @@ int32_t NaClSysFstat(struct NaClAppThread *natp,
                      struct nacl_abi_stat *nasp) {
   struct NaClApp        *nap = natp->nap;
   int32_t               retval = -NACL_ABI_EINVAL;
   struct NaClDesc       *ndp;
   struct nacl_abi_stat  result;
+  int                   fd;
 
-  NaClLog(3,
-          ("Entered NaClSysFstat(0x%08"NACL_PRIxPTR
-           ", %d, 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp,
-          d, (uintptr_t) nasp);
+  NaClLog(2, "Entered NaClSysFstat(0x%08"NACL_PRIxPTR
+           ", %d, 0x%08"NACL_PRIxPTR")\n",
+           (uintptr_t)natp,
+           d, (uintptr_t)nasp);
 
-  NaClLog(4,
-          " sizeof(struct nacl_abi_stat) = %"NACL_PRIdS" (0x%"NACL_PRIxS")\n",
+  NaClLog(2, "sizeof(struct nacl_abi_stat) = %"NACL_PRIdS" (0x%"NACL_PRIxS")\n",
           sizeof *nasp, sizeof *nasp);
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
-    NaClLog(4, "bad desc\n");
+  fd = fd_cage_table[nap->cage_id][d];
+
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
+    NaClLog(2, "%s\n", "bad desc");
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
             Fstat)(ndp, &result);
-  if (0 == retval) {
+  if (!retval) {
     if (!NaClCopyOutToUser(nap, (uintptr_t) nasp,
                            &result, sizeof result)) {
       retval = -NACL_ABI_EFAULT;
     }
   }
@@ -1020,28 +1198,27 @@ int32_t NaClSysStat(struct NaClAppThread  *natp,
   struct NaClApp      *nap = natp->nap;
   int32_t             retval = -NACL_ABI_EINVAL;
   char                path[NACL_CONFIG_PATH_MAX];
   nacl_host_stat_t    stbuf;
 
-  NaClLog(3,
-          ("Entered NaClSysStat(0x%08"NACL_PRIxPTR", 0x%08"NACL_PRIxPTR","
-           " 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp, (uintptr_t) pathname, (uintptr_t) buf);
+  NaClLog(2, "Entered NaClSysStat(0x%08"NACL_PRIxPTR", 0x%08"NACL_PRIxPTR","
+           " 0x%08"NACL_PRIxPTR")\n",
+          (uintptr_t)natp,(uintptr_t)pathname, (uintptr_t)buf);
 
   retval = CopyPathFromUser(nap, path, sizeof path, (uintptr_t) pathname);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   retval = NaClStatAclCheck(nap, path);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   /*
    * Perform a host stat.
    */
   retval = NaClHostDescStat(path, &stbuf);
-  if (0 == retval) {
+  if (!retval) {
     struct nacl_abi_stat abi_stbuf;
 
     retval = NaClAbiStatHostDescStatXlateCtor(&abi_stbuf,
                                               &stbuf);
     if (!NaClCopyOutToUser(nap, (uintptr_t) buf,
@@ -1064,11 +1241,11 @@ int32_t NaClSysMkdir(struct NaClAppThread *natp,
     retval = -NACL_ABI_EACCES;
     goto cleanup;
   }
 
   retval = CopyPathFromUser(nap, path, sizeof path, pathname);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   retval = NaClHostDescMkdir(path, mode);
 cleanup:
   return retval;
@@ -1084,11 +1261,11 @@ int32_t NaClSysRmdir(struct NaClAppThread *natp,
     retval = -NACL_ABI_EACCES;
     goto cleanup;
   }
 
   retval = CopyPathFromUser(nap, path, sizeof path, pathname);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   retval = NaClHostDescRmdir(path);
 cleanup:
   return retval;
@@ -1104,11 +1281,11 @@ int32_t NaClSysChdir(struct NaClAppThread *natp,
     retval = -NACL_ABI_EACCES;
     goto cleanup;
   }
 
   retval = CopyPathFromUser(nap, path, sizeof path, pathname);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   retval = NaClHostDescChdir(path);
 cleanup:
   return retval;
@@ -1150,11 +1327,11 @@ int32_t NaClSysUnlink(struct NaClAppThread *natp,
     retval = -NACL_ABI_EACCES;
     goto cleanup;
   }
 
   retval = CopyPathFromUser(nap, path, sizeof path, pathname);
-  if (0 != retval)
+  if (retval)
     goto cleanup;
 
   retval = NaClHostDescUnlink(path);
 cleanup:
   return retval;
@@ -1222,62 +1399,65 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
   size_t                      alloc_rounded_length;
   nacl_off64_t                file_size;
   nacl_off64_t                file_bytes;
   nacl_off64_t                host_rounded_file_bytes;
   size_t                      alloc_rounded_file_bytes;
+  int fd;
 
   holding_app_lock = 0;
   ndp = NULL;
 
   allowed_flags = (NACL_ABI_MAP_FIXED | NACL_ABI_MAP_SHARED
                    | NACL_ABI_MAP_PRIVATE | NACL_ABI_MAP_ANONYMOUS);
 
   usraddr = (uintptr_t) start;
 
-  if (0 != (flags & ~allowed_flags)) {
+  if ((flags & ~allowed_flags)) {
     NaClLog(2, "invalid mmap flags 0%o, ignoring extraneous bits\n", flags);
     flags &= allowed_flags;
   }
 
-  if (0 != (flags & NACL_ABI_MAP_ANONYMOUS)) {
+  if ((flags & NACL_ABI_MAP_ANONYMOUS)) {
     /*
      * anonymous mmap, so backing store is just swap: no descriptor is
      * involved, and no memory object will be created to represent the
      * descriptor.
      */
     ndp = NULL;
   } else {
-    ndp = NaClGetDesc(nap, d);
-    if (NULL == ndp) {
+    fd = fd_cage_table[nap->cage_id][d];
+    ndp = NaClGetDesc(nap, fd);
+    if (!ndp) {
       map_result = -NACL_ABI_EBADF;
       goto cleanup;
     }
   }
 
   mapping_code = 0;
   /*
    * Check if application is trying to do dynamic code loading by
    * mmaping a file.
    */
-  if (0 != (NACL_ABI_PROT_EXEC & prot) &&
-      0 != (NACL_ABI_MAP_FIXED & flags) &&
-      NULL != ndp &&
+  if ((NACL_ABI_PROT_EXEC & prot) &&
+      (NACL_ABI_MAP_FIXED & flags) &&
+      ndp &&
       NaClSysCommonAddrRangeInAllowedDynamicCodeSpace(nap, usraddr, length)) {
     if (!nap->enable_dyncode_syscalls) {
-      NaClLog(LOG_WARNING,
-              "NaClSysMmap: PROT_EXEC when dyncode syscalls are disabled.\n");
+#ifdef  _DEBUG
+      NaClLog(1, "%s\n",
+              "NaClSysMmap: PROT_EXEC when dyncode syscalls are disabled.");
+#endif
       map_result = -NACL_ABI_EINVAL;
       goto cleanup;
     }
-    if (0 != (NACL_ABI_PROT_WRITE & prot)) {
-      NaClLog(3,
-              "NaClSysMmap: asked for writable and executable code pages?!?\n");
+    if ((NACL_ABI_PROT_WRITE & prot)) {
+      NaClLog(2, "%s\n", "NaClSysMmap: asked for writable and executable code pages?!?");
       map_result = -NACL_ABI_EINVAL;
       goto cleanup;
     }
     mapping_code = 1;
-  } else if (0 != (prot & NACL_ABI_PROT_EXEC)) {
+  } else if ((prot & NACL_ABI_PROT_EXEC)) {
     map_result = -NACL_ABI_EINVAL;
     goto cleanup;
   }
 
   /*
@@ -1303,42 +1483,40 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
   }
   /*
    * And offset must be a multiple of the allocation unit.
    */
   if (!NaClIsAllocPageMultiple((uintptr_t) offset)) {
-    NaClLog(1,
-            ("NaClSysMmap: file offset 0x%08"NACL_PRIxPTR" not multiple"
-             " of allocation size\n"),
-            (uintptr_t) offset);
+    NaClLog(1, "NaClSysMmap: file offset 0x%08"NACL_PRIxPTR" not multiple"
+            " of allocation size\n",
+            (uintptr_t)offset);
     map_result = -NACL_ABI_EINVAL;
     goto cleanup;
   }
 
-  if (0 == length) {
+  if (!length) {
     map_result = -NACL_ABI_EINVAL;
     goto cleanup;
   }
   alloc_rounded_length = NaClRoundAllocPage(length);
   if (alloc_rounded_length != length) {
     if (mapping_code) {
-      NaClLog(3, "NaClSysMmap: length not a multiple of allocation size\n");
+      NaClLog(2, "%s\n", "NaClSysMmap: length not a multiple of allocation size");
       map_result = -NACL_ABI_EINVAL;
       goto cleanup;
     }
-    NaClLog(1,
-            "NaClSysMmap: rounded length to 0x%"NACL_PRIxS"\n",
+    NaClLog(1, "NaClSysMmap: rounded length to 0x%"NACL_PRIxS"\n",
             alloc_rounded_length);
   }
 
-  if (NULL == ndp) {
+  if (!ndp) {
     /*
      * Note: sentinel values are bigger than the NaCl module addr space.
      */
     file_size                = kMaxUsableFileSize;
     file_bytes               = kMaxUsableFileSize;
     host_rounded_file_bytes  = kMaxUsableFileSize;
-    alloc_rounded_file_bytes = kMaxUsableFileSize;
+    /* alloc_rounded_file_bytes = kMaxUsableFileSize; */
   } else {
     /*
      * We stat the file to figure out its actual size.
      *
      * This is necessary because the POSIXy interface we provide
@@ -1346,11 +1524,11 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
      * interface does not.  We simulate the POSIX behaviour on
      * Windows.
      */
     map_result = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
                   Fstat)(ndp, &stbuf);
-    if (0 != map_result) {
+    if (map_result) {
       goto cleanup;
     }
 
     /*
      * Preemptively refuse to map anything that's not a regular file or
@@ -1402,11 +1580,11 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
      * leave the explicit check below as defensive programming.
      */
     alloc_rounded_file_bytes =
       NaClRoundAllocPage((size_t) host_rounded_file_bytes);
 
-    if (0 == alloc_rounded_file_bytes && 0 != host_rounded_file_bytes) {
+    if (!alloc_rounded_file_bytes && host_rounded_file_bytes) {
       map_result = -NACL_ABI_ENOMEM;
       goto cleanup;
     }
 
     /*
@@ -1428,11 +1606,11 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
             "NaClSysMmap: disallowing partial allocation page extension for"
             " short files\n");
     map_result = -NACL_ABI_EINVAL;
     goto cleanup;
   }
-  length = size_min(alloc_rounded_length, (size_t) host_rounded_file_bytes);
+  length = MIN(alloc_rounded_length, (size_t) host_rounded_file_bytes);
 
   /*
    * Lock the addr space.
    */
   NaClXMutexLock(&nap->mu);
@@ -1443,25 +1621,25 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
 
   if (0 == (flags & NACL_ABI_MAP_FIXED)) {
     /*
      * The user wants us to pick an address range.
      */
-    if (0 == usraddr) {
+    if (!usraddr) {
       /*
        * Pick a hole in addr space of appropriate size, anywhere.
        * We pick one that's best for the system.
        */
       usrpage = NaClVmmapFindMapSpace(&nap->mem_map,
                                       alloc_rounded_length >> NACL_PAGESHIFT);
-      NaClLog(4, "NaClSysMmap: FindMapSpace: page 0x%05"NACL_PRIxPTR"\n",
+      NaClLog(2, "NaClSysMmap: FindMapSpace: page 0x%05"NACL_PRIxPTR"\n",
               usrpage);
-      if (0 == usrpage) {
+      if (!usrpage) {
         map_result = -NACL_ABI_ENOMEM;
         goto cleanup;
       }
       usraddr = usrpage << NACL_PAGESHIFT;
-      NaClLog(4, "NaClSysMmap: new starting addr: 0x%08"NACL_PRIxPTR
+      NaClLog(2, "NaClSysMmap: new starting addr: 0x%08"NACL_PRIxPTR
               "\n", usraddr);
     } else {
       /*
        * user supplied an addr, but it's to be treated as a hint; we
        * find a hole of the right size in the app's address space,
@@ -1469,23 +1647,23 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
        */
       usrpage = NaClVmmapFindMapSpaceAboveHint(&nap->mem_map,
                                                usraddr,
                                                (alloc_rounded_length
                                                 >> NACL_PAGESHIFT));
-      NaClLog(4, "NaClSysMmap: FindSpaceAboveHint: page 0x%05"NACL_PRIxPTR"\n",
+      NaClLog(2, "NaClSysMmap: FindSpaceAboveHint: page 0x%05"NACL_PRIxPTR"\n",
               usrpage);
-      if (0 == usrpage) {
-        NaClLog(4, "NaClSysMmap: hint failed, doing generic allocation\n");
+      if (!usrpage) {
+        NaClLog(2, "%s\n", "NaClSysMmap: hint failed, doing generic allocation");
         usrpage = NaClVmmapFindMapSpace(&nap->mem_map,
                                         alloc_rounded_length >> NACL_PAGESHIFT);
       }
-      if (0 == usrpage) {
+      if (!usrpage) {
         map_result = -NACL_ABI_ENOMEM;
         goto cleanup;
       }
       usraddr = usrpage << NACL_PAGESHIFT;
-      NaClLog(4, "NaClSysMmap: new starting addr: 0x%08"NACL_PRIxPTR"\n",
+      NaClLog(2, "NaClSysMmap: new starting addr: 0x%08"NACL_PRIxPTR"\n",
               usraddr);
     }
   }
 
   /*
@@ -1580,15 +1758,14 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
 
   sysaddr = NaClUserToSys(nap, usraddr);
 
   /* [0, length) */
   if (length > 0) {
-    if (NULL == ndp) {
-      NaClLog(4,
-              ("NaClSysMmap: NaClDescIoDescMap(,,0x%08"NACL_PRIxPTR","
-               "0x%08"NACL_PRIxS",0x%x,0x%x,0x%08"NACL_PRIxPTR")\n"),
-              sysaddr, length, prot, flags, (uintptr_t) offset);
+    if (!ndp) {
+      NaClLog(2, "NaClSysMmap: NaClDescIoDescMap(,,0x%08"NACL_PRIxPTR","
+               "0x%08"NACL_PRIxS",0x%x,0x%x,0x%08"NACL_PRIxPTR")\n",
+               sysaddr, length, prot, flags, (uintptr_t)offset);
       map_result = NaClDescIoDescMapAnon(nap->effp,
                                          (void *) sysaddr,
                                          length,
                                          prot,
                                          flags,
@@ -1650,18 +1827,17 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
        * This mapping is PROT_READ | PROT_WRITE, MAP_PRIVATE so that
        * if validation fails in read-only mode, we can re-run the
        * validator to patch in place.
        */
 
-      image_sys_addr = (*NACL_VTBL(NaClDesc, ndp)->
-                        Map)(ndp,
-                             NaClDescEffectorTrustedMem(),
-                             (void *) NULL,
-                             length,
-                             NACL_ABI_PROT_READ | NACL_ABI_PROT_WRITE,
-                             NACL_ABI_MAP_PRIVATE,
-                             offset);
+      image_sys_addr = NACL_VTBL(NaClDesc, ndp)->Map(ndp,
+                                                     NaClDescEffectorTrustedMem(),
+                                                     NULL,
+                                                     length,
+                                                     NACL_ABI_PROT_READ | NACL_ABI_PROT_WRITE,
+                                                     NACL_ABI_MAP_PRIVATE,
+                                                     offset);
       if (NaClPtrIsNegErrno(&image_sys_addr)) {
         map_result = image_sys_addr;
         goto cleanup;
       }
 
@@ -1767,23 +1943,22 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
       sys_ret = (*NACL_VTBL(NaClDesc, ndp)->
                  UnmapUnsafe)(ndp, (void *) image_sys_addr, length);
 #else
       sys_ret = munmap((void *) image_sys_addr, length);
 #endif
-      if (0 != sys_ret) {
-        NaClLog(LOG_FATAL,
-                "NaClSysMmap: could not unmap text at 0x%"NACL_PRIxPTR","
+      if (sys_ret) {
+        NaClLog(1, "aClSysMmap: could not unmap text at 0x%"NACL_PRIxPTR","
                 " length 0x%"NACL_PRIxS", NaCl errno %d\n",
                 image_sys_addr, length, -sys_ret);
       }
       goto cleanup_no_locks;
     } else {
       /*
        * This is a fix for Windows, where we cannot pass a size that
        * goes beyond the non-page-rounded end of the file.
        */
-      size_t length_to_map = size_min(length, (size_t) file_bytes);
+      size_t length_to_map = MIN(length, (size_t) file_bytes);
 
       NaClLog(4,
               ("NaClSysMmap: (*ndp->Map)(,,0x%08"NACL_PRIxPTR","
                "0x%08"NACL_PRIxS",0x%x,0x%x,0x%08"NACL_PRIxPTR")\n"),
               sysaddr, length, prot, flags, (uintptr_t) offset);
@@ -1870,11 +2045,11 @@ int32_t NaClSysMmapIntern(struct NaClApp        *nap,
   if (holding_app_lock) {
     NaClVmHoleClosingMu(nap);
     NaClXMutexUnlock(&nap->mu);
   }
  cleanup_no_locks:
-  if (NULL != ndp) {
+  if (ndp) {
     NaClDescUnref(ndp);
   }
 
   /*
    * Check to ensure that map_result will fit into a 32-bit value. This is
@@ -1898,162 +2073,67 @@ int32_t NaClSysMmap(struct NaClAppThread  *natp,
                     size_t                length,
                     int                   prot,
                     int                   flags,
                     int                   d,
                     nacl_abi_off_t        *offp) {
-  struct NaClApp  *nap = natp->nap;
-  int32_t         retval;
-  uintptr_t       sysaddr;
-  nacl_abi_off_t  offset;
-  //PyGILState_STATE gstate;
+  struct NaClApp     *nap = natp->nap;
+  int32_t            retval;
+  volatile uintptr_t sysaddr;
+  nacl_abi_off_t     offset;
 
-  NaClLog(3,
-          "Entered NaClSysMmap(0x%08"NACL_PRIxPTR",0x%"NACL_PRIxS","
+  NaClLog(2, "ntered NaClSysMmap(0x%08"NACL_PRIxPTR",0x%"NACL_PRIxS","
           "0x%x,0x%x,%d,0x%08"NACL_PRIxPTR")\n",
-          (uintptr_t) start, length, prot, flags, d, (uintptr_t) offp);
+          (uintptr_t) start, length, prot, flags, d, (uintptr_t)offp);
 
-  if ((nacl_abi_off_t *) 0 == offp) {
+  if (!offp) {
     /*
      * This warning is really targetted towards trusted code,
      * especially tests that didn't notice the argument type change.
      * Unfortunatey, zero is a common and legitimate offset value, and
      * the compiler will not complain since an automatic type
      * conversion works.
      */
-    NaClLog(LOG_WARNING,
-            "NaClSysMmap: NULL pointer used"
+#ifdef  _DEBUG
+    NaClLog(1, "aClSysMmap: NULL pointer used"
             " for offset in/out argument\n");
+#endif
     return -NACL_ABI_EINVAL;
   }
 
-  //gstate = PyGILState_Ensure();
-  sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t) offp, sizeof offset);
+  sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t)offp, sizeof offset);
   if (kNaClBadAddress == sysaddr) {
-    NaClLog(3,
-            "NaClSysMmap: offset in a bad untrusted memory location\n");
+    NaClLog(2, "%s\n", "NaClSysMmap: offset in a bad untrusted memory location");
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
-  offset = *(nacl_abi_off_t volatile *) sysaddr;
-
-  NaClLog(4, " offset = 0x%08"NACL_PRIxNACL_OFF"\n", offset);
-
+  offset = *(nacl_abi_off_t *)sysaddr;
+  NaClLog(2, " offset = 0x%08"NACL_PRIxNACL_OFF"\n", offset);
   retval = NaClSysMmapIntern(nap, start, length, prot, flags, d, offset);
+
 cleanup:
-  //PyGILState_Release(gstate);
   return retval;
 }
 
-#if NACL_WINDOWS
-static int32_t MunmapInternal(struct NaClApp *nap,
-                              uintptr_t sysaddr, size_t length) {
-  uintptr_t addr;
-  uintptr_t endaddr = sysaddr + length;
-  uintptr_t usraddr;
-  for (addr = sysaddr; addr < endaddr; addr += NACL_MAP_PAGESIZE) {
-    struct NaClVmmapEntry const *entry;
-    uintptr_t                   page_num;
-    uintptr_t                   offset;
-
-    usraddr = NaClSysToUser(nap, addr);
-
-    entry = NaClVmmapFindPage(&nap->mem_map, usraddr >> NACL_PAGESHIFT);
-    if (NULL == entry) {
-      continue;
-    }
-    NaClLog(3,
-            ("NaClSysMunmap: addr 0x%08x, desc 0x%08"NACL_PRIxPTR"\n"),
-            addr, (uintptr_t) entry->desc);
-
-    page_num = usraddr - (entry->page_num << NACL_PAGESHIFT);
-    offset = (uintptr_t) entry->offset + page_num;
-
-    if (NULL != entry->desc &&
-        offset < (uintptr_t) entry->file_size) {
-      if (!UnmapViewOfFile((void *) addr)) {
-        NaClLog(LOG_FATAL,
-                ("MunmapInternal: UnmapViewOfFile failed to at addr"
-                 " 0x%08"NACL_PRIxPTR", error %d\n"),
-                addr, GetLastError());
-      }
-      /*
-      * Fill the address space hole that we opened
-      * with UnmapViewOfFile().
-      */
-      if (!VirtualAlloc((void *) addr, NACL_MAP_PAGESIZE, MEM_RESERVE,
-                        PAGE_READWRITE)) {
-        NaClLog(LOG_FATAL, "MunmapInternal: "
-                "failed to fill hole with VirtualAlloc(), error %d\n",
-                GetLastError());
-      }
-    } else {
-      /*
-       * Anonymous memory; we just decommit it and thus
-       * make it inaccessible.
-       */
-      if (!VirtualFree((void *) addr,
-                       NACL_MAP_PAGESIZE,
-                       MEM_DECOMMIT)) {
-        int error = GetLastError();
-        NaClLog(LOG_FATAL,
-                ("MunmapInternal: Could not VirtualFree MEM_DECOMMIT"
-                 " addr 0x%08x, error %d (0x%x)\n"),
-                addr, error, error);
-      }
-    }
-    NaClVmmapRemove(&nap->mem_map,
-                    usraddr >> NACL_PAGESHIFT,
-                    NACL_PAGES_PER_MAP);
-  }
-  return 0;
-}
-#else
-static int32_t MunmapInternal(struct NaClApp *nap,
-                              uintptr_t sysaddr, size_t length) {
-  UNREFERENCED_PARAMETER(nap);
-  NaClLog(3, "MunmapInternal(0x%08"NACL_PRIxPTR", 0x%"NACL_PRIxS")\n",
-          (uintptr_t) sysaddr, length);
-  /*
-   * Overwrite current mapping with inaccessible, anonymous
-   * zero-filled pages, which should be copy-on-write and thus
-   * relatively cheap.  Do not open up an address space hole.
-   */
-  if (MAP_FAILED == mmap((void *) sysaddr,
-                         length,
-                         PROT_NONE,
-                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
-                         -1,
-                         (off_t) 0)) {
-    NaClLog(4, "mmap to put in anonymous memory failed, errno = %d\n", errno);
-    return -NaClXlateErrno(errno);
-  }
-  NaClVmmapRemove(&nap->mem_map,
-                  NaClSysToUser(nap, (uintptr_t) sysaddr) >> NACL_PAGESHIFT,
-                  length >> NACL_PAGESHIFT);
-  return 0;
-}
-#endif
-
 int32_t NaClSysMunmap(struct NaClAppThread  *natp,
                       void                  *start,
                       size_t                length) {
   struct NaClApp *nap = natp->nap;
   int32_t   retval = -NACL_ABI_EINVAL;
   uintptr_t sysaddr;
   int       holding_app_lock = 0;
   size_t    alloc_rounded_length;
 
-  NaClLog(3, "Entered NaClSysMunmap(0x%08"NACL_PRIxPTR", "
+  NaClLog(2, "Entered NaClSysMunmap(0x%08"NACL_PRIxPTR", "
           "0x%08"NACL_PRIxPTR", 0x%"NACL_PRIxS")\n",
           (uintptr_t) natp, (uintptr_t) start, length);
 
   if (!NaClIsAllocPageMultiple((uintptr_t) start)) {
-    NaClLog(4, "start addr not allocation multiple\n");
+    NaClLog(2, "%s\n", "start addr not allocation multiple");
     retval = -NACL_ABI_EINVAL;
     goto cleanup;
   }
-  if (0 == length) {
+  if (!length) {
     /*
      * Without this check we would get the following inconsistent
      * behaviour:
      *  * On Linux, an mmap() of zero length yields a failure.
      *  * On Mac OS X, an mmap() of zero length returns no error,
@@ -2126,20 +2206,20 @@ static int32_t MprotectInternal(struct NaClApp *nap,
     uintptr_t                   offset;
 
     usraddr = NaClSysToUser(nap, addr);
 
     entry = NaClVmmapFindPage(&nap->mem_map, usraddr >> NACL_PAGESHIFT);
-    if (NULL == entry) {
+    if (!entry) {
       continue;
     }
-    NaClLog(3, "MprotectInternal: addr 0x%08x, desc 0x%08"NACL_PRIxPTR"\n",
+    NaClLog(2, "MprotectInternal: addr 0x%08x, desc 0x%08"NACL_PRIxPTR"\n",
             addr, (uintptr_t) entry->desc);
 
     page_num = usraddr - (entry->page_num << NACL_PAGESHIFT);
     offset = (uintptr_t) entry->offset + page_num;
 
-    if (NULL == entry->desc) {
+    if (!entry->desc) {
       flProtect = NaClflProtectMap(prot);
 
       /* Change the page protection */
       if (!VirtualProtect((void *) addr,
                           NACL_MAP_PAGESIZE,
@@ -2166,23 +2246,23 @@ static int32_t MprotectInternal(struct NaClApp *nap,
                                        (desc_flags & NACL_ABI_O_ACCMODE),
                                        /* flMaximumProtect= */ NULL,
                                        &flProtect,
                                        /* dwDesiredAccess= */ NULL,
                                        &err_msg);
-      if (0 == flProtect) {
+      if (!flProtect) {
         /*
          * This shouldn't really happen since we already checked the address
          * space using NaClVmmapCheckExistingMapping, but better be safe.
          */
-        NaClLog(LOG_FATAL, "MprotectInternal: %s\n", err_msg);
+        NaClLog(1, "MprotectInternal: %s\n", err_msg);
       }
 
       file_bytes = entry->file_size - offset;
-      chunk_size = size_min((size_t) file_bytes, NACL_MAP_PAGESIZE);
+      chunk_size = MIN((size_t) file_bytes, NACL_MAP_PAGESIZE);
       rounded_chunk_size = NaClRoundPage(chunk_size);
 
-      NaClLog(4, "VirtualProtect(0x%08x, 0x%"NACL_PRIxS", %x)\n",
+      NaClLog(2, "VirtualProtect(0x%08x, 0x%"NACL_PRIxS", %x)\n",
               addr, rounded_chunk_size, flProtect);
 
       /* Change the page protection */
       if (!VirtualProtect((void *) addr,
                           rounded_chunk_size,
@@ -2224,31 +2304,31 @@ static int32_t MprotectInternal(struct NaClApp *nap,
     size_t entry_len = entry->npages << NACL_PAGESHIFT;
 
     usraddr = entry->page_num << NACL_PAGESHIFT;
     addr = NaClUserToSys(nap, usraddr);
 
-    NaClLog(3, "MprotectInternal: "
+    NaClLog(2, "MprotectInternal: "
             "addr 0x%08"NACL_PRIxPTR", desc 0x%08"NACL_PRIxPTR"\n",
             addr, (uintptr_t) entry->desc);
 
-    if (NULL == entry->desc) {
-      if (0 != mprotect((void *) addr, entry_len, host_prot)) {
-        NaClLog(LOG_FATAL, "MprotectInternal: "
+    if (!entry->desc) {
+      if (mprotect((void *) addr, entry_len, host_prot)) {
+        NaClLog(1, "MprotectInternal: "
                 "mprotect on anonymous memory failed, errno = %d\n", errno);
         return -NaClXlateErrno(errno);
       }
     } else if (entry->offset < entry->file_size) {
       nacl_abi_off64_t  file_bytes;
       size_t            rounded_file_bytes;
       size_t            prot_len;
 
       file_bytes = entry->file_size - entry->offset;
       rounded_file_bytes = NaClRoundPage((size_t) file_bytes);
-      prot_len = size_min(rounded_file_bytes, entry_len);
+      prot_len = MIN(rounded_file_bytes, entry_len);
 
-      if (0 != mprotect((void *) addr, prot_len, host_prot)) {
-        NaClLog(LOG_FATAL, "MprotectInternal: "
+      if (mprotect((void *) addr, prot_len, host_prot)) {
+        NaClLog(1, "MprotectInternal: "
                 "mprotect on file-backed memory failed, errno = %d\n", errno);
         return -NaClXlateErrno(errno);
       }
     }
   }
@@ -2264,23 +2344,23 @@ int32_t NaClSysMprotectInternal(struct NaClApp  *nap,
   int32_t     retval = -NACL_ABI_EINVAL;
   uintptr_t   sysaddr;
   int         holding_app_lock = 0;
 
   if (!NaClIsAllocPageMultiple((uintptr_t) start)) {
-    NaClLog(4, "mprotect: start addr not allocation multiple\n");
+    NaClLog(2, "%s\n", "mprotect: start addr not allocation multiple");
     retval = -NACL_ABI_EINVAL;
     goto cleanup;
   }
   length = NaClRoundAllocPage(length);
   sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t) start, length);
   if (kNaClBadAddress == sysaddr) {
-    NaClLog(4, "mprotect: region not user addresses\n");
+    NaClLog(2, "%s\n", "mprotect: region not user addresses");
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
-  if (0 != (~(NACL_ABI_PROT_READ | NACL_ABI_PROT_WRITE) & prot)) {
-    NaClLog(4, "mprotect: prot has other bits than PROT_{READ|WRITE}\n");
+  if ((~(NACL_ABI_PROT_READ | NACL_ABI_PROT_WRITE) & prot)) {
+    NaClLog(2, "%s\n", "mprotect: prot has other bits than PROT_{READ|WRITE}");
     retval = -NACL_ABI_EACCES;
     goto cleanup;
   }
 
   NaClXMutexLock(&nap->mu);
@@ -2309,11 +2389,11 @@ int32_t NaClSysMprotectInternal(struct NaClApp  *nap,
   NaClVmIoPendingCheck_mu(nap,
                           (uint32_t) (uintptr_t) start,
                           (uint32_t) ((uintptr_t) start + length - 1));
 
   retval = MprotectInternal(nap, sysaddr, length, prot);
-  if (retval == 0 &&
+  if (!retval &&
       !NaClVmmapChangeProt(&nap->mem_map,
                            NaClSysToUser(nap, sysaddr) >> NACL_PAGESHIFT,
                            length >> NACL_PAGESHIFT,
                            prot)) {
     retval = -NACL_ABI_EACCES;
@@ -2350,17 +2430,16 @@ int32_t NaClSysImcMakeBoundSock(struct NaClAppThread *natp,
   struct NaClApp              *nap = natp->nap;
   int32_t                     retval = -NACL_ABI_EINVAL;
   struct NaClDesc             *pair[2];
   int32_t                     usr_pair[2];
 
-  NaClLog(3,
-          ("Entered NaClSysImcMakeBoundSock(0x%08"NACL_PRIxPTR","
-           " 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp, (uintptr_t) sap);
+  NaClLog(2, "Entered NaClSysImcMakeBoundSock(0x%08"NACL_PRIxPTR","
+           " 0x%08"NACL_PRIxPTR")\n",
+           (uintptr_t)natp, (uintptr_t)sap);
 
   retval = NaClCommonDescMakeBoundSock(pair);
-  if (0 != retval) {
+  if (retval) {
     goto cleanup;
   }
 
   usr_pair[0] = NaClSetAvail(nap, pair[0]);
   usr_pair[1] = NaClSetAvail(nap, pair[1]);
@@ -2390,54 +2469,54 @@ cleanup:
 }
 
 int32_t NaClSysImcAccept(struct NaClAppThread  *natp,
                          int                   d) {
   struct NaClApp  *nap = natp->nap;
-  int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *ndp;
+  struct NaClDesc *result_desc;
+  int32_t         retval;
+  int             fd;
 
-  NaClLog(3, "Entered NaClSysImcAccept(0x%08"NACL_PRIxPTR", %d)\n",
-          (uintptr_t) natp, d);
-
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
-    retval = -NACL_ABI_EBADF;
-  } else {
-    struct NaClDesc *result_desc;
-    retval = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
-              AcceptConn)(ndp, &result_desc);
-    if (retval == 0) {
-      retval = NaClSetAvail(nap, result_desc);
-    }
-    NaClDescUnref(ndp);
+  NaClLog(1, "Entered NaClSysImcAccept(0x%08"NACL_PRIxPTR", %d)\n", (uintptr_t)natp, d);
+  fd = fd_cage_table[nap->cage_id][d];
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
+    retval = -NACL_ABI_EINVAL;
+    goto out;
   }
+  retval = ((struct NaClDescVtbl const *)ndp->base.vtbl)->AcceptConn(ndp, &result_desc);
+  if (!retval) {
+    retval = NaClSetAvail(nap, result_desc);
+  }
+  NaClDescUnref(ndp);
 
+out:
   return retval;
 }
 
 int32_t NaClSysImcConnect(struct NaClAppThread *natp,
                           int                  d) {
   struct NaClApp  *nap = natp->nap;
-  int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *ndp;
+  struct NaClDesc *result;
+  int32_t         retval;
+  int             fd;
 
-  NaClLog(3, "Entered NaClSysImcConnectAddr(0x%08"NACL_PRIxPTR", %d)\n",
-          (uintptr_t) natp, d);
-
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
+  NaClLog(1, "Entered NaClSysImcConnectAddr(0x%08"NACL_PRIxPTR", %d)\n", (uintptr_t)natp, d);
+  fd = fd_cage_table[nap->cage_id][d];
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
-  } else {
-    struct NaClDesc *result;
-    retval = (*((struct NaClDescVtbl const *) ndp->base.vtbl)->
-              ConnectAddr)(ndp, &result);
-    if (retval == 0) {
-      retval = NaClSetAvail(nap, result);
-    }
-    NaClDescUnref(ndp);
+    goto out;
   }
+  retval = ((struct NaClDescVtbl const *)ndp->base.vtbl)->ConnectAddr(ndp, &result);
+  if (!retval) {
+    retval = NaClSetAvail(nap, result);
+  }
+  NaClDescUnref(ndp);
 
+out:
   return retval;
 }
 
 /*
  * This function converts addresses from user addresses to system
@@ -2447,11 +2526,11 @@ int32_t NaClSysImcConnect(struct NaClAppThread *natp,
 int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
                           int                          d,
                           struct NaClAbiNaClImcMsgHdr *nanimhp,
                           int                          flags) {
   struct NaClApp                *nap = natp->nap;
-  int32_t                       retval = -NACL_ABI_EINVAL;
+  int32_t                       retval;
   ssize_t                       ssize_retval;
   uintptr_t                     sysaddr;
   /* copy of user-space data for validation */
   struct NaClAbiNaClImcMsgHdr   kern_nanimh;
   struct NaClAbiNaClImcMsgIoVec kern_naiov[NACL_ABI_IMC_IOVEC_MAX];
@@ -2460,19 +2539,19 @@ int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
   /* kernel-side representatin of descriptors */
   struct NaClDesc               *kern_desc[NACL_ABI_IMC_USER_DESC_MAX];
   struct NaClImcTypedMsgHdr     kern_msg_hdr;
   struct NaClDesc               *ndp;
   size_t                        i;
+  int                           fd;
 
-  NaClLog(3,
-          ("Entered NaClSysImcSendmsg(0x%08"NACL_PRIxPTR", %d,"
-           " 0x%08"NACL_PRIxPTR", 0x%x)\n"),
-          (uintptr_t) natp, d, (uintptr_t) nanimhp, flags);
+  NaClLog(2, "Entered NaClSysImcSendmsg(0x%08"NACL_PRIxPTR", %d,"
+           " 0x%08"NACL_PRIxPTR", 0x%x)\n",
+           (uintptr_t)natp, d, (uintptr_t)nanimhp, flags);
 
   if (!NaClCopyInFromUser(nap, &kern_nanimh, (uintptr_t) nanimhp,
                           sizeof kern_nanimh)) {
-    NaClLog(4, "NaClImcMsgHdr not in user address space\n");
+    NaClLog(2, "%s\n", "NaClImcMsgHdr not in user address space");
     retval = -NACL_ABI_EFAULT;
     goto cleanup_leave;
   }
   /* copy before validating contents */
 
@@ -2485,57 +2564,57 @@ int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
    * nrd xfer library's checks should never fire when called from the
    * service runtime, but the nrd xfer library might be called from
    * other code.
    */
   if (kern_nanimh.iov_length > NACL_ABI_IMC_IOVEC_MAX) {
-    NaClLog(4, "gather/scatter array too large\n");
+    NaClLog(2, "%s\n", "gather/scatter array too large");
     retval = -NACL_ABI_EINVAL;
     goto cleanup_leave;
   }
   if (kern_nanimh.desc_length > NACL_ABI_IMC_USER_DESC_MAX) {
-    NaClLog(4, "handle vector too long\n");
+    NaClLog(2, "%s\n", "handle vector too long");
     retval = -NACL_ABI_EINVAL;
     goto cleanup_leave;
   }
 
   if (kern_nanimh.iov_length > 0) {
-    if (!NaClCopyInFromUser(nap, kern_naiov, (uintptr_t) kern_nanimh.iov,
+    if (!NaClCopyInFromUser(nap, kern_naiov, (uintptr_t)kern_nanimh.iov,
                             (kern_nanimh.iov_length * sizeof kern_naiov[0]))) {
-      NaClLog(4, "gather/scatter array not in user address space\n");
+      NaClLog(2, "%s\n", "gather/scatter array not in user address space");
       retval = -NACL_ABI_EFAULT;
       goto cleanup_leave;
     }
 
     for (i = 0; i < kern_nanimh.iov_length; ++i) {
       sysaddr = NaClUserToSysAddrRange(nap,
-                                       (uintptr_t) kern_naiov[i].base,
+                                       (uintptr_t)kern_naiov[i].base,
                                        kern_naiov[i].length);
       if (kNaClBadAddress == sysaddr) {
         retval = -NACL_ABI_EFAULT;
         goto cleanup_leave;
       }
-      kern_iov[i].base = (void *) sysaddr;
+      kern_iov[i].base = (void *)sysaddr;
       kern_iov[i].length = kern_naiov[i].length;
     }
   }
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
+  fd = fd_cage_table[nap->cage_id][d];
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
     retval = -NACL_ABI_EBADF;
     goto cleanup_leave;
   }
 
   /*
    * make things easier for cleaup exit processing
    */
   memset(kern_desc, 0, sizeof kern_desc);
-  retval = -NACL_ABI_EINVAL;
 
   kern_msg_hdr.iov = kern_iov;
   kern_msg_hdr.iov_length = kern_nanimh.iov_length;
 
-  if (0 == kern_nanimh.desc_length) {
+  if (!kern_nanimh.desc_length) {
     kern_msg_hdr.ndescv = 0;
     kern_msg_hdr.ndesc_length = 0;
   } else {
     if (!NaClCopyInFromUser(nap, usr_desc, kern_nanimh.descv,
                             kern_nanimh.desc_length * sizeof usr_desc[0])) {
@@ -2548,11 +2627,11 @@ int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
         kern_desc[i] = (struct NaClDesc *) NaClDescInvalidMake();
       } else {
         /* NaCl modules are ILP32, so this works on ILP32 and LP64 systems */
         kern_desc[i] = NaClGetDesc(nap, usr_desc[i]);
       }
-      if (NULL == kern_desc[i]) {
+      if (!kern_desc[i]) {
         retval = -NACL_ABI_EBADF;
         goto cleanup;
       }
     }
     kern_msg_hdr.ndescv = kern_desc;
@@ -2577,11 +2656,11 @@ int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
   if (NaClSSizeIsNegErrno(&ssize_retval)) {
     /*
      * NaClWouldBlock uses TSD (for both the errno-based and
      * GetLastError()-based implementations), so this is threadsafe.
      */
-    if (0 != (flags & NACL_DONT_WAIT) && NaClWouldBlock()) {
+    if ((flags & NACL_DONT_WAIT) && NaClWouldBlock()) {
       retval = -NACL_ABI_EAGAIN;
     } else if (-NACL_ABI_EMSGSIZE == ssize_retval) {
       /*
        * Allow the caller to handle the case when imc_sendmsg fails because
        * the message is too large for the system to send in one piece.
@@ -2603,18 +2682,18 @@ int32_t NaClSysImcSendmsg(struct NaClAppThread         *natp,
     retval = (int32_t)ssize_retval;
   }
 
 cleanup:
   for (i = 0; i < kern_nanimh.desc_length; ++i) {
-    if (NULL != kern_desc[i]) {
+    if (kern_desc[i]) {
       NaClDescUnref(kern_desc[i]);
       kern_desc[i] = NULL;
     }
   }
   NaClDescUnref(ndp);
 cleanup_leave:
-  NaClLog(3, "NaClSysImcSendmsg: returning %d\n", retval);
+  NaClLog(2, "NaClSysImcSendmsg: returning %d\n", retval);
   return retval;
 }
 
 int32_t NaClSysImcRecvmsg(struct NaClAppThread         *natp,
                           int                          d,
@@ -2632,15 +2711,15 @@ int32_t NaClSysImcRecvmsg(struct NaClAppThread         *natp,
   int32_t                               usr_desc[NACL_ABI_IMC_USER_DESC_MAX];
   struct NaClImcTypedMsgHdr             recv_hdr;
   struct NaClDesc                       *new_desc[NACL_ABI_IMC_DESC_MAX];
   nacl_abi_size_t                       num_user_desc;
   struct NaClDesc                       *invalid_desc = NULL;
+  int                                   fd;
 
-  NaClLog(3,
-          ("Entered NaClSysImcRecvMsg(0x%08"NACL_PRIxPTR", %d,"
-           " 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp, d, (uintptr_t) nanimhp);
+  NaClLog(2, "Entered NaClSysImcRecvMsg(0x%08"NACL_PRIxPTR", %d,"
+           " 0x%08"NACL_PRIxPTR")\n",
+           (uintptr_t)natp, d, (uintptr_t)nanimhp);
 
   /*
    * First, we validate user-supplied message headers before
    * allocating a receive buffer.
    */
@@ -2694,22 +2773,22 @@ int32_t NaClSysImcRecvmsg(struct NaClAppThread         *natp,
       kern_iov[i].length = kern_naiov[i].length;
     }
   }
 
   if (kern_nanimh.desc_length > 0) {
-    sysaddr = NaClUserToSysAddrRange(nap,
-                                     (uintptr_t) kern_nanimh.descv,
+    sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t)kern_nanimh.descv,
                                      kern_nanimh.desc_length * sizeof(int32_t));
     if (kNaClBadAddress == sysaddr) {
       retval = -NACL_ABI_EFAULT;
       goto cleanup_leave;
     }
   }
 
-  ndp = NaClGetDesc(nap, d);
-  if (NULL == ndp) {
-    NaClLog(4, "receiving descriptor invalid\n");
+  fd = fd_cage_table[nap->cage_id][d];
+  ndp = NaClGetDesc(nap, fd);
+  if (!ndp) {
+    NaClLog(1, "%s\n", "receiving descriptor invalid");
     retval = -NACL_ABI_EBADF;
     goto cleanup_leave;
   }
 
   recv_hdr.iov = kern_iov;
@@ -2784,31 +2863,31 @@ int32_t NaClSysImcRecvmsg(struct NaClAppThread         *natp,
     } else {
       usr_desc[i] = NaClSetAvail(nap, new_desc[i]);
     }
     new_desc[i] = NULL;
   }
-  if (0 != num_user_desc &&
-      !NaClCopyOutToUser(nap, (uintptr_t) kern_nanimh.descv, usr_desc,
+  if (num_user_desc &&
+      !NaClCopyOutToUser(nap, (uintptr_t)kern_nanimh.descv, usr_desc,
                          num_user_desc * sizeof usr_desc[0])) {
-    NaClLog(LOG_FATAL,
-            ("NaClSysImcRecvMsg: in/out ptr (descv %"NACL_PRIxPTR
-             ") became invalid at copyout?\n"),
+    NaClLog(1, "NaClSysImcRecvMsg: in/out ptr (descv %"NACL_PRIxPTR
+            ") became invalid at copyout?\n",
             (uintptr_t) kern_nanimh.descv);
   }
 
   kern_nanimh.desc_length = num_user_desc;
-  if (!NaClCopyOutToUser(nap, (uintptr_t) nanimhp, &kern_nanimh,
+  if (!NaClCopyOutToUser(nap, (uintptr_t)nanimhp, &kern_nanimh,
                          sizeof kern_nanimh)) {
-    NaClLog(LOG_FATAL,
+    NaClLog(1, "%s\n",
             "NaClSysImcRecvMsg: in/out ptr (iov) became"
-            " invalid at copyout?\n");
+            " invalid at copyout?");
   }
+
+cleanup:
   /* copy out updated desc count, flags */
- cleanup:
   if (retval < 0) {
     for (i = 0; i < NACL_ARRAY_SIZE(new_desc); ++i) {
-      if (NULL != new_desc[i]) {
+      if (new_desc[i]) {
         NaClDescUnref(new_desc[i]);
         new_desc[i] = NULL;
       }
     }
   }
@@ -2824,41 +2903,39 @@ int32_t NaClSysImcMemObjCreate(struct NaClAppThread  *natp,
   struct NaClApp        *nap = natp->nap;
   int32_t               retval = -NACL_ABI_EINVAL;
   struct NaClDescImcShm *shmp;
   off_t                 size_as_off;
 
-  NaClLog(3,
-          ("Entered NaClSysImcMemObjCreate(0x%08"NACL_PRIxPTR
-           " 0x%08"NACL_PRIxS")\n"),
-          (uintptr_t) natp, size);
+  NaClLog(2, "Entered NaClSysImcMemObjCreate(0x%08"NACL_PRIxPTR
+           " 0x%08"NACL_PRIxS")\n",
+           (uintptr_t)natp, size);
 
-  if (0 != (size & (NACL_MAP_PAGESIZE - 1))) {
+  if (size & (NACL_MAP_PAGESIZE - 1)) {
     return -NACL_ABI_EINVAL;
   }
   /*
    * TODO(bsy): policy about maximum shm object size should be
    * enforced here.
    */
-  size_as_off = (off_t) size;
+  size_as_off = (off_t)size;
   if (size_as_off < 0) {
     return -NACL_ABI_EINVAL;
   }
 
-  shmp = NULL;
-
   shmp = malloc(sizeof *shmp);
-  if (NULL == shmp) {
+  if (!shmp) {
     retval = -NACL_ABI_ENOMEM;
     goto cleanup;
   }
 
-  if (!NaClDescImcShmAllocCtor(shmp, size_as_off, /* executable= */ 0)) {
-    retval = -NACL_ABI_ENOMEM;  /* is this reasonable? */
+  if (!NaClDescImcShmAllocCtor(shmp, size_as_off, /* executable= */0)) {
+    /* is this reasonable? */
+    retval = -NACL_ABI_ENOMEM;
     goto cleanup;
   }
 
-  retval = NaClSetAvail(nap, (struct NaClDesc *) shmp);
+  retval = NaClSetAvail(nap, (struct NaClDesc *)shmp);
   shmp = NULL;
 
 cleanup:
   free(shmp);
 
@@ -2870,17 +2947,16 @@ int32_t NaClSysImcSocketPair(struct NaClAppThread *natp,
   struct NaClApp          *nap = natp->nap;
   int32_t                 usr_pair[2];
   struct NaClDesc         *pair[2];
   int32_t                 retval;
 
-  NaClLog(3,
-          ("Entered NaClSysImcSocketPair(0x%08"NACL_PRIxPTR
-           " 0x%08"NACL_PRIx32")\n"),
-          (uintptr_t) natp, descs_out);
+  NaClLog(2, "Entered NaClSysImcSocketPair(0x%08"NACL_PRIxPTR
+           " 0x%08"NACL_PRIx32")\n",
+           (uintptr_t)natp, descs_out);
 
   retval = NaClCommonDescSocketPair(pair);
-  if (0 != retval) {
+  if (retval) {
     goto cleanup;
   }
 
   usr_pair[0] = NaClSetAvail(nap, pair[0]);
   usr_pair[1] = NaClSetAvail(nap, pair[1]);
@@ -3000,11 +3076,11 @@ int32_t NaClSysSecondTlsSet(struct NaClAppThread *natp,
 int32_t NaClSysSecondTlsGet(struct NaClAppThread *natp) {
   return NaClTlsGetTlsValue2(natp);
 }
 
 int NaClSysThreadNice(struct NaClAppThread *natp,
-                      const int            nice) {
+                      int                  nice) {
   /* Note: implementation of nacl_thread_nice is OS dependent. */
   UNREFERENCED_PARAMETER(natp);
   return nacl_thread_nice(nice);
 }
 
@@ -3038,17 +3114,16 @@ int32_t NaClSysMutexLock(struct NaClAppThread  *natp,
                          int32_t               mutex_handle) {
   struct NaClApp        *nap = natp->nap;
   int32_t               retval = -NACL_ABI_EINVAL;
   struct NaClDesc       *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysMutexLock(0x%08"NACL_PRIxPTR", %d)\n"),
-          (uintptr_t) natp, mutex_handle);
+  NaClLog(2, "Entered NaClSysMutexLock(0x%08"NACL_PRIxPTR", %d)\n",
+          (uintptr_t)natp, mutex_handle);
 
   desc = NaClGetDesc(nap, mutex_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->Lock)(desc);
@@ -3062,17 +3137,16 @@ int32_t NaClSysMutexUnlock(struct NaClAppThread  *natp,
                            int32_t               mutex_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysMutexUnlock(0x%08"NACL_PRIxPTR", %d)\n"),
-          (uintptr_t) natp, mutex_handle);
+  NaClLog(2, "Entered NaClSysMutexUnlock(0x%08"NACL_PRIxPTR", %d)\")",
+          (uintptr_t)natp, mutex_handle);
 
   desc = NaClGetDesc(nap, mutex_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->Unlock)(desc);
@@ -3086,17 +3160,16 @@ int32_t NaClSysMutexTrylock(struct NaClAppThread   *natp,
                             int32_t                 mutex_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysMutexTrylock(0x%08"NACL_PRIxPTR", %d)\n"),
-          (uintptr_t) natp, mutex_handle);
+  NaClLog(2, "Entered NaClSysMutexTrylock(0x%08"NACL_PRIxPTR", %d)\n",
+          (uintptr_t)natp, mutex_handle);
 
   desc = NaClGetDesc(nap, mutex_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->TryLock)(desc);
@@ -3124,13 +3197,12 @@ int32_t NaClSysCondCreate(struct NaClAppThread *natp) {
 
   retval = NaClSetAvail(nap, (struct NaClDesc *)desc);
   desc = NULL;
 cleanup:
   free(desc);
-  NaClLog(3,
-          ("NaClSysCondCreate(0x%08"NACL_PRIxPTR") = %d\n"),
-          (uintptr_t) natp, retval);
+  NaClLog(2, "NaClSysCondCreate(0x%08"NACL_PRIxPTR") = %d\n",
+           (uintptr_t)natp, retval);
   return retval;
 }
 
 int32_t NaClSysCondWait(struct NaClAppThread *natp,
                         int32_t              cond_handle,
@@ -3138,23 +3210,22 @@ int32_t NaClSysCondWait(struct NaClAppThread *natp,
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *cv_desc;
   struct NaClDesc *mutex_desc;
 
-  NaClLog(3,
-          ("Entered NaClSysCondWait(0x%08"NACL_PRIxPTR", %d, %d)\n"),
-          (uintptr_t) natp, cond_handle, mutex_handle);
+  NaClLog(2, "Entered NaClSysCondWait(0x%08"NACL_PRIxPTR", %d, %d)\n",
+           (uintptr_t)natp, cond_handle, mutex_handle);
 
   cv_desc = NaClGetDesc(nap, cond_handle);
 
-  if (NULL == cv_desc) {
+  if (!cv_desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   mutex_desc = NaClGetDesc(nap, mutex_handle);
-  if (NULL == mutex_desc) {
+  if (!mutex_desc) {
     NaClDescUnref(cv_desc);
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
@@ -3171,17 +3242,16 @@ int32_t NaClSysCondSignal(struct NaClAppThread *natp,
                           int32_t              cond_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysCondSignal(0x%08"NACL_PRIxPTR", %d)\n"),
-          (uintptr_t) natp, cond_handle);
+  NaClLog(2, "Entered NaClSysCondSignal(0x%08"NACL_PRIxPTR", %d)\n",
+           (uintptr_t)natp, cond_handle);
 
   desc = NaClGetDesc(nap, cond_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->Signal)(desc);
@@ -3194,17 +3264,16 @@ int32_t NaClSysCondBroadcast(struct NaClAppThread  *natp,
                              int32_t               cond_handle) {
   struct NaClApp  *nap = natp->nap;
   struct NaClDesc *desc;
   int32_t         retval = -NACL_ABI_EINVAL;
 
-  NaClLog(3,
-          ("Entered NaClSysCondBroadcast(0x%08"NACL_PRIxPTR", %d)\n"),
-          (uintptr_t) natp, cond_handle);
+  NaClLog(2, "Entered NaClSysCondBroadcast(0x%08"NACL_PRIxPTR", %d)\n",
+          (uintptr_t)natp, cond_handle);
 
   desc = NaClGetDesc(nap, cond_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->Broadcast)(desc);
@@ -3222,39 +3291,36 @@ int32_t NaClSysCondTimedWaitAbs(struct NaClAppThread     *natp,
   int32_t                  retval = -NACL_ABI_EINVAL;
   struct NaClDesc          *cv_desc;
   struct NaClDesc          *mutex_desc;
   struct nacl_abi_timespec trusted_ts;
 
-  NaClLog(3,
-          ("Entered NaClSysCondTimedWaitAbs(0x%08"NACL_PRIxPTR
-           ", %d, %d, 0x%08"NACL_PRIxPTR")\n"),
-          (uintptr_t) natp, cond_handle, mutex_handle, (uintptr_t) ts);
+  NaClLog(2, "Entered NaClSysCondTimedWaitAbs(0x%08"NACL_PRIxPTR
+           ", %d, %d, 0x%08"NACL_PRIxPTR")\n",
+           (uintptr_t)natp, cond_handle, mutex_handle, (uintptr_t)ts);
 
   if (!NaClCopyInFromUser(nap, &trusted_ts,
                           (uintptr_t) ts, sizeof trusted_ts)) {
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
+
   /* TODO(gregoryd): validate ts - do we have a limit for time to wait? */
 
   cv_desc = NaClGetDesc(nap, cond_handle);
-  if (NULL == cv_desc) {
+  if (!cv_desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   mutex_desc = NaClGetDesc(nap, mutex_handle);
-  if (NULL == mutex_desc) {
+  if (!mutex_desc) {
     NaClDescUnref(cv_desc);
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
-  retval = (*((struct NaClDescVtbl const *) cv_desc->base.vtbl)->
-            TimedWaitAbs)(cv_desc,
-                          mutex_desc,
-                          &trusted_ts);
+  retval = ((struct NaClDescVtbl const *)cv_desc->base.vtbl)->TimedWaitAbs(cv_desc, mutex_desc, &trusted_ts);
   NaClDescUnref(cv_desc);
   NaClDescUnref(mutex_desc);
 cleanup:
   return retval;
 }
@@ -3289,18 +3355,17 @@ int32_t NaClSysSemWait(struct NaClAppThread *natp,
                        int32_t              sem_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysSemWait(0x%08"NACL_PRIxPTR
-           ", %d)\n"),
-          (uintptr_t) natp, sem_handle);
+  NaClLog(2, "Entered NaClSysSemWait(0x%08"NACL_PRIxPTR
+           ", %d)\n",
+          (uintptr_t)natp, sem_handle);
 
   desc = NaClGetDesc(nap, sem_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   /*
@@ -3319,23 +3384,22 @@ int32_t NaClSysSemPost(struct NaClAppThread *natp,
                        int32_t              sem_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysSemPost(0x%08"NACL_PRIxPTR
-           ", %d)\n"),
-          (uintptr_t) natp, sem_handle);
+  NaClLog(2, "Entered NaClSysSemPost(0x%08"NACL_PRIxPTR
+           ", %d)\n",
+           (uintptr_t)natp, sem_handle);
 
   desc = NaClGetDesc(nap, sem_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
-  retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->Post)(desc);
+  retval = ((struct NaClDescVtbl const *) desc->base.vtbl)->Post(desc);
   NaClDescUnref(desc);
 cleanup:
   return retval;
 }
 
@@ -3343,18 +3407,17 @@ int32_t NaClSysSemGetValue(struct NaClAppThread *natp,
                            int32_t              sem_handle) {
   struct NaClApp  *nap = natp->nap;
   int32_t         retval = -NACL_ABI_EINVAL;
   struct NaClDesc *desc;
 
-  NaClLog(3,
-          ("Entered NaClSysSemGetValue(0x%08"NACL_PRIxPTR
-           ", %d)\n"),
-          (uintptr_t) natp, sem_handle);
+  NaClLog(2, "Entered NaClSysSemGetValue(0x%08"NACL_PRIxPTR
+           ", %d)\n",
+           (uintptr_t)natp, sem_handle);
 
   desc = NaClGetDesc(nap, sem_handle);
 
-  if (NULL == desc) {
+  if (!desc) {
     retval = -NACL_ABI_EBADF;
     goto cleanup;
   }
 
   retval = (*((struct NaClDescVtbl const *) desc->base.vtbl)->GetValue)(desc);
@@ -3370,17 +3433,16 @@ int32_t NaClSysNanosleep(struct NaClAppThread     *natp,
   struct nacl_abi_timespec  t_sleep;
   struct nacl_abi_timespec  t_rem;
   struct nacl_abi_timespec  *remptr;
   int                       retval = -NACL_ABI_EINVAL;
 
-  NaClLog(3,
-          ("Entered NaClSysNanosleep(0x%08"NACL_PRIxPTR
-           ", 0x%08"NACL_PRIxPTR", 0x%08"NACL_PRIxPTR"x)\n"),
-          (uintptr_t) natp, (uintptr_t) req, (uintptr_t) rem);
+  NaClLog(2, "Entered NaClSysNanosleep(0x%08"NACL_PRIxPTR
+           ", 0x%08"NACL_PRIxPTR", 0x%08"NACL_PRIxPTR"x)\n",
+           (uintptr_t)natp, (uintptr_t)req, (uintptr_t)rem);
 
   /* do the check before we sleep */
-  if (NULL != rem && kNaClBadAddress ==
+  if (rem && kNaClBadAddress ==
       NaClUserToSysAddrRange(nap, (uintptr_t) rem, sizeof *rem)) {
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
 
@@ -3388,37 +3450,34 @@ int32_t NaClSysNanosleep(struct NaClAppThread     *natp,
                           (uintptr_t) req, sizeof t_sleep)) {
     retval = -NACL_ABI_EFAULT;
     goto cleanup;
   }
 
-  remptr = (NULL == rem) ? NULL : &t_rem;
-  /* NULL != remptr \equiv NULL != rem */
+  remptr = !rem ? NULL : &t_rem;
 
   /*
    * We assume that we do not need to normalize the time request values.
    *
    * If bogus values can cause the underlying OS to get into trouble,
    * then we need more checking here.
    */
-  NaClLog(4, "NaClSysNanosleep(time = %"NACL_PRId64".%09"NACL_PRId64" S)\n",
+  NaClLog(2, "NaClSysNanosleep(time = %"NACL_PRId64".%09"NACL_PRId64" S)\n",
           (int64_t) t_sleep.tv_sec, (int64_t) t_sleep.tv_nsec);
   retval = NaClNanosleep(&t_sleep, remptr);
-  NaClLog(4, "NaClNanosleep returned %d\n", retval);
+  NaClLog(2, "NaClNanosleep returned %d\n", retval);
 
-  if (-EINTR == retval && NULL != rem &&
-      !NaClCopyOutToUser(nap, (uintptr_t) rem, remptr, sizeof *remptr)) {
-    NaClLog(LOG_FATAL, "NaClSysNanosleep: check rem failed at copyout\n");
+  if (-NACL_ABI_EINTR == retval && rem && !NaClCopyOutToUser(nap, (uintptr_t)rem, remptr, sizeof *remptr)) {
+    NaClLog(1, "%s\n", "NaClSysNanosleep: check rem failed at copyout\n");
   }
 
 cleanup:
-  NaClLog(4, "nanosleep done.\n");
+  NaClLog(2, "%s\n", "nanosleep done.");
   return retval;
 }
 
 int32_t NaClSysSchedYield(struct NaClAppThread *natp) {
   UNREFERENCED_PARAMETER(natp);
-
   NaClThreadYield();
   return 0;
 }
 
 int32_t NaClSysExceptionHandler(struct NaClAppThread *natp,
@@ -3446,11 +3505,11 @@ int32_t NaClSysExceptionHandler(struct NaClAppThread *natp,
       rv = -NACL_ABI_ENOSYS;
       goto unlock_exit;
     }
   }
 
-  if (0 != old_handler &&
+  if (old_handler &&
       !NaClCopyOutToUser(nap, (uintptr_t) old_handler,
                          &nap->exception_handler,
                          sizeof nap->exception_handler)) {
     rv = -NACL_ABI_EFAULT;
     goto unlock_exit;
@@ -3651,11 +3710,11 @@ int32_t NaClSysGetTimeOfDay(struct NaClAppThread      *natp,
    * TODO(bsy) Do we make the zoneinfo directory available to
    * applications?
    */
 
   retval = NaClGetTimeOfDay(&now);
-  if (0 != retval) {
+  if (retval) {
     return retval;
   }
 #if !NACL_WINDOWS
   /*
    * Coarsen the time to the same level we get on Windows -
@@ -3665,59 +3724,282 @@ int32_t NaClSysGetTimeOfDay(struct NaClAppThread      *natp,
     now.nacl_abi_tv_usec = (now.nacl_abi_tv_usec / 10) * 10;
   }
 #endif
   CHECK(now.nacl_abi_tv_usec >= 0);
   CHECK(now.nacl_abi_tv_usec < NACL_MICROS_PER_UNIT);
-  if (!NaClCopyOutToUser(natp->nap, (uintptr_t) tv, &now, sizeof now)) {
+  if (!NaClCopyOutToUser(natp->nap, (uintptr_t)tv, &now, sizeof now)) {
     return -NACL_ABI_EFAULT;
   }
   return 0;
 }
 
+/* convenience typedef */
+typedef int clock_func(nacl_clockid_t, struct nacl_abi_timespec *);
+
 static int NaClIsValidClockId(int clk_id) {
+  int ret = 0;
   switch (clk_id) {
-    case NACL_ABI_CLOCK_REALTIME:
-    case NACL_ABI_CLOCK_MONOTONIC:
-    case NACL_ABI_CLOCK_PROCESS_CPUTIME_ID:
-    case NACL_ABI_CLOCK_THREAD_CPUTIME_ID:
-      return 1;
+  case NACL_ABI_CLOCK_REALTIME:
+  case NACL_ABI_CLOCK_MONOTONIC:
+  case NACL_ABI_CLOCK_PROCESS_CPUTIME_ID:
+  case NACL_ABI_CLOCK_THREAD_CPUTIME_ID:
+    ret = 1;
   }
-  return 0;
+  return ret;
 }
 
 int32_t NaClSysClockGetCommon(struct NaClAppThread  *natp,
                               int                   clk_id,
                               uint32_t              ts_addr,
-                              int                   (*timefunc)(
-                                  nacl_clockid_t            clk_id,
-                                  struct nacl_abi_timespec  *tp)) {
+                              clock_func            *time_func) {
   struct NaClApp            *nap = natp->nap;
   int                       retval = -NACL_ABI_EINVAL;
   struct nacl_abi_timespec  out_buf;
 
   if (!NaClIsValidClockId(clk_id)) {
     goto done;
   }
-  retval = (*timefunc)((nacl_clockid_t) clk_id, &out_buf);
-  if (0 == retval) {
-    if (!NaClCopyOutToUser(nap, (uintptr_t) ts_addr,
-                           &out_buf, sizeof out_buf)) {
-      retval = -NACL_ABI_EFAULT;
-    }
+  retval = time_func((nacl_clockid_t) clk_id, &out_buf);
+  if (!retval && !NaClCopyOutToUser(nap, (uintptr_t)ts_addr, &out_buf, sizeof out_buf)) {
+    retval = -NACL_ABI_EFAULT;
   }
+
  done:
   return retval;
 }
 
 int32_t NaClSysClockGetRes(struct NaClAppThread *natp,
                            int                  clk_id,
                            uint32_t             tsp) {
-  return NaClSysClockGetCommon(natp, clk_id, (uintptr_t) tsp,
-                                     NaClClockGetRes);
+  return NaClSysClockGetCommon(natp, clk_id, (uintptr_t) tsp, NaClClockGetRes);
 }
 
 int32_t NaClSysClockGetTime(struct NaClAppThread  *natp,
                             int                   clk_id,
                             uint32_t              tsp) {
-  return NaClSysClockGetCommon(natp, clk_id, (uintptr_t) tsp,
-                                     NaClClockGetTime);
+  return NaClSysClockGetCommon(natp, clk_id, (uintptr_t) tsp, NaClClockGetTime);
+}
+
+/*
+ * TODO: find a cleaner way to implement pipe() -jp
+ */
+int32_t NaClSysPipe(struct NaClAppThread  *natp, uint32_t *pipedes) {
+  struct NaClApp *nap = natp->nap;
+  struct NaClDesc *ndp;
+  int32_t ret = 0;
+  int pipe_fds[2];
+  int nacl_fds[2];
+  int flags;
+
+  if (pipe(pipe_fds) < 0) {
+    ret = -NACL_ABI_EFAULT;
+    goto out;
+  }
+
+  /* sanitize fds */
+  for (size_t i = 0; i < 2; i ++) {
+    if (nap->fd > FILE_DESC_MAX) {
+      ret = -NACL_ABI_EFAULT;
+      goto out;
+    }
+    /* set flags for the read and write ends of the pipe */
+    switch (i) {
+    case 0:
+      flags = NACL_ABI_O_RDONLY;
+      break;
+    case 1:
+      flags = NACL_ABI_O_WRONLY|NACL_ABI_O_APPEND;
+      break;
+    default:
+      /* something went terribly wrong */
+      ret = -NACL_ABI_EFAULT;
+      goto out;
+    }
+    ndp = NaClDescIoDescFromDescAllocCtor(pipe_fds[i], flags);
+    NaClSetDesc(nap, pipe_fds[i], ndp);
+    fd_cage_table[nap->cage_id][nap->fd] = pipe_fds[i];
+    nacl_fds[i] = nap->fd;
+    nap->fd++;
+  }
+
+  /* copy out sanitized fds */
+  if (!NaClCopyOutToUser(nap, (uintptr_t)pipedes, nacl_fds, sizeof nacl_fds)) {
+      ret = -NACL_ABI_EFAULT;
+  }
+
+out:
+  return ret;
+}
+
+int32_t NaClSysFork(struct NaClAppThread *natp) {
+  struct NaClApp *nap = natp->nap;
+  struct NaClApp *nap_child = NULL;
+  int ret;
+  char **child_argv;
+  int child_argc;
+
+  NaClLog(1, "%s\n", "[NaClSysFork] NaCl fork starts!");
+
+  /* parent */
+  child_argc = 3 + nap->command_num;
+  child_argv = calloc(child_argc + 2, sizeof *child_argv);
+  child_argv[0] = "NaClMain";
+  child_argv[1] = "--library-path";
+  child_argv[2] = "/lib/glibc";
+  if (nap->binary_path) {
+     child_argv[3] = nap->binary_path;
+     NaClLog(1, "[NaClSysFork] binary path: %s \n", nap->binary_path);
+  }
+  if (nap->command_num > 1) {
+     child_argv[4] = nap->binary_command;
+     NaClLog(1, "[NaClSysFork] binary command: %s \n", nap->binary_command);
+  }
+  NaClLogThreadContext(natp);
+  nap_child = NaClChildNapCtor(natp);
+  ret = nap_child->cage_id;
+  if (!NaClCreateMainForkThread(nap, natp, nap_child, child_argc, child_argv, NULL)) {
+    NaClLog(1, "%s\n", "[NaClSysFork] forking program failed!");
+    ret = -NACL_ABI_ENOMEM;
+    goto out;
+  }
+  NaClLog(1, "[fork_num = %u, cage_id = %u, parent_id = %u]\n", fork_num, nap_child->cage_id, nap->cage_id);
+
+out:
+  return ret;
+}
+
+/*
+ * TODO: implement execv()
+ */
+int32_t NaClSysExecv(struct NaClAppThread *natp) {
+  UNREFERENCED_PARAMETER(natp);
+  return -NACL_ABI_ENOSYS;
+}
+
+/*
+ * TODO: implement execve()
+ */
+int32_t NaClSysExecve(struct NaClAppThread  *natp, void *path, void *argv, void *envp) {
+  UNREFERENCED_PARAMETER(natp);
+  UNREFERENCED_PARAMETER(path);
+  UNREFERENCED_PARAMETER(argv);
+  UNREFERENCED_PARAMETER(envp);
+  return -NACL_ABI_ENOSYS;
+}
+
+#define WAIT_ANY (-1)
+#define WAIT_ANY_PG 0
+
+int32_t NaClSysWaitpid(struct NaClAppThread  *natp,
+                       uint32_t pid,
+                       uint32_t *stat_loc,
+                       uint32_t options) {
+  volatile int cage_id = pid;
+  /* seconds between thread switching */
+  NACL_TIMESPEC_T const timeout = {1, 0};
+  struct NaClApp *nap = natp->nap;
+  struct NaClApp *nap_child = NULL;
+  uintptr_t sysaddr = NaClUserToSysAddrRange(nap, (uintptr_t)stat_loc, 4);
+  int *stat_loc_ptr = (int *)sysaddr;
+  int pid_max = 0;
+  int ret = 0;
+
+  NaClLog(1, "%s\n", "[NaClSysWaitpid] entered waitpid!");
+
+  CHECK(nap->num_children < NACL_THREAD_MAX);
+  *stat_loc_ptr = 0;
+  for (int i = 0; i < nap->num_children; i++)
+    pid_max = pid_max < nap->children_ids[i] ? nap->children_ids[i] : pid_max;
+  if (!nap->num_children || cage_id > pid_max) {
+    ret = -NACL_ABI_ECHILD;
+    goto out;
+  }
+
+  /*
+   * explicit child pid given
+   */
+  if (cage_id > 0 && cage_id <= pid_max) {
+    /* make sure children exists */
+    NaClXMutexLock(&nap->children_mu);
+    nap_child = DynArrayGet(&nap->children, cage_id);
+    if (!nap_child) {
+      ret = -NACL_ABI_ECHILD;
+      NaClXCondVarBroadcast(&nap->children_cv);
+      NaClXMutexUnlock(&nap->children_mu);
+      goto out;
+    }
+    NaClLog(1, "Thread children count: %d\n", nap->num_children);
+    /* wait for child to finish */
+    while (DynArrayGet(&nap->children, cage_id)) {
+      NaClXCondVarTimedWaitRelative(&nap->children_cv, &nap->children_mu, &timeout);
+      /* NaClXCondVarWait(&nap->children_cv, &nap->children_mu); */
+    }
+    NaClXCondVarBroadcast(&nap->children_cv);
+    NaClXMutexUnlock(&nap->children_mu);
+    goto out;
+  }
+
+  /*
+   * TODO: implement pid == WAIT_ANY_PG (0) and pid == WAIT_ANY (-1) behavior
+   *
+   * -jp
+   */
+  if (cage_id <= 0) {
+    volatile int cur_idx = 0;
+    for (;;) {
+      /* make sure children exist */
+      NaClXMutexLock(&nap->children_mu);
+      if (!nap->num_children) {
+        ret = -NACL_ABI_ECHILD;
+        NaClXCondVarBroadcast(&nap->children_cv);
+        NaClXMutexUnlock(&nap->children_mu);
+        goto out;
+      }
+      /* wait for next child to exit */
+      cage_id = nap->children_ids[cur_idx];
+      if (cage_id && (nap_child = DynArrayGet(&nap->children, cage_id))) {
+        NaClLog(1, "Thread children count: %d\n", nap->num_children);
+        NaClXCondVarTimedWaitRelative(&nap->children_cv, &nap->children_mu, &timeout);
+        /* exit if selected child has finished */
+        if (!DynArrayGet(&nap->children, cage_id)) {
+          ret = cage_id;
+          NaClXCondVarBroadcast(&nap->children_cv);
+          NaClXMutexUnlock(&nap->children_mu);
+          goto out;
+        }
+      }
+      if (++cur_idx >= nap->num_children) {
+        cur_idx = 0;
+      }
+      NaClXCondVarBroadcast(&nap->children_cv);
+      NaClXMutexUnlock(&nap->children_mu);
+    }
+  }
+
+out:
+  if (nap_child) {
+    *stat_loc_ptr = nap_child->exit_status;
+  }
+  NaClLog(1, "[NaClSysWaitpid] pid = %d \n", cage_id);
+  NaClLog(1, "[NaClSysWaitpid] status = %d \n", *stat_loc_ptr);
+  NaClLog(1, "[NaClSysWaitpid] options = %d \n", options);
+  NaClLog(1, "[NaClSysWaitpid] ret = %d \n", ret);
+
+  return ret;
+}
+
+int32_t NaClSysWait(struct NaClAppThread  *natp, uint32_t *stat_loc) {
+  struct NaClApp *nap = natp->nap;
+  int ret;
+
+  NaClLog(1, "%s\n", "[NaClSysWait] entered wait! \n");
+
+  if (!nap->num_children) {
+    ret = -NACL_ABI_ECHILD;
+    goto out;
+  }
+  ret = NaClSysWaitpid(natp, WAIT_ANY, stat_loc, 0);
+
+out:
+  NaClLog(1, "[NaClSysWait] ret = %d \n", ret);
+  return ret;
 }
diff --git a/src/trusted/service_runtime/nacl_syscall_common.h b/src/trusted/service_runtime/nacl_syscall_common.h
index cfdc7e7712db0a681d..2964819bf13ef896b4 100644
--- a/src/trusted/service_runtime/nacl_syscall_common.h
+++ b/src/trusted/service_runtime/nacl_syscall_common.h
@@ -66,10 +66,15 @@ int32_t NaClSysDup(struct NaClAppThread *natp,
 
 int32_t NaClSysDup2(struct NaClAppThread  *natp,
                     int                   oldfd,
                     int                   newfd);
 
+int32_t NaClSysDup3(struct NaClAppThread  *natp,
+                    int                   oldfd,
+                    int                   newfd,
+                    int                   flags);
+
 int32_t NaClSysOpen(struct NaClAppThread  *natp,
                     char                  *pathname,
                     int                   flags,
                     int                   mode);
 
@@ -103,25 +108,25 @@ int32_t NaClSysFstat(struct NaClAppThread *natp,
 int32_t NaClSysStat(struct NaClAppThread *natp,
                     const char           *path,
                     struct nacl_abi_stat *nasp);
 
 int32_t NaClSysMkdir(struct NaClAppThread *natp,
-                     uint32_t             path,
+                     uint32_t             pathname,
                      int                  mode);
 
 int32_t NaClSysRmdir(struct NaClAppThread *natp,
-                     uint32_t             path);
+                     uint32_t             pathname);
 
 int32_t NaClSysChdir(struct NaClAppThread *natp,
-                     uint32_t             path);
+                     uint32_t             pathname);
 
 int32_t NaClSysGetcwd(struct NaClAppThread *natp,
                       uint32_t             buffer,
                       int                  len);
 
 int32_t NaClSysUnlink(struct NaClAppThread *natp,
-                      uint32_t             path);
+                      uint32_t             pathname);
 
 /* bool */
 int NaClSysCommonAddrRangeContainsExecutablePages(struct NaClApp *nap,
                                                   uintptr_t usraddr,
                                                   size_t length);
@@ -223,11 +228,11 @@ int32_t NaClSysSecondTlsSet(struct NaClAppThread *natp,
                             uint32_t             new_value);
 
 int32_t NaClSysSecondTlsGet(struct NaClAppThread *natp);
 
 int32_t NaClSysThreadNice(struct NaClAppThread *natp,
-                          const int nice);
+                          int                  nice);
 
 /* mutex */
 
 int32_t NaClSysMutexCreate(struct NaClAppThread *natp);
 
@@ -299,8 +304,16 @@ int32_t NaClSysExceptionClearFlag(struct NaClAppThread *natp);
 
 int32_t NaClSysTestInfoLeak(struct NaClAppThread *natp);
 
 int32_t NaClSysTestCrash(struct NaClAppThread *natp, int crash_type);
 
+int32_t NaClSysPipe(struct NaClAppThread  *natp, uint32_t *pipedes);
+int32_t NaClSysFork(struct NaClAppThread  *natp);
+int32_t NaClSysExecv(struct NaClAppThread  *natp);
+int32_t NaClSysExecve(struct NaClAppThread  *natp, void* path, void* argv, void* envp);
+int32_t NaClSysWaitpid(struct NaClAppThread  *natp, uint32_t pid, uint32_t *stat_loc, uint32_t options);
+
+int32_t NaClSysWait(struct NaClAppThread  *natp, uint32_t *stat_loc);
+
 EXTERN_C_END
 
 #endif  /* NATIVE_CLIENT_SERVICE_RUNTIME_NACL_SYSCALL_COMMON_H__ */
diff --git a/src/trusted/service_runtime/nacl_syscall_handlers.h b/src/trusted/service_runtime/nacl_syscall_handlers.h
index e93cb38993053a070b..73d39d4b8fb0b9a2e8 100644
--- a/src/trusted/service_runtime/nacl_syscall_handlers.h
+++ b/src/trusted/service_runtime/nacl_syscall_handlers.h
@@ -7,10 +7,12 @@
 
 #ifndef SERVICE_RUNTIME_NACL_SYSCALL_HANDLERS_H__
 #define SERVICE_RUNTIME_NACL_SYSCALL_HANDLERS_H__ 1
 
 #include "native_client/src/include/nacl_base.h"
+#include "native_client/src/trusted/service_runtime/nacl_app_thread.h"
+#include "native_client/src/trusted/service_runtime/include/bits/nacl_syscalls.h"
 
 struct NaClAppThread;
 
 struct NaClSyscallTableEntry {
   int32_t (*handler)(struct NaClAppThread *natp);
@@ -19,8 +21,13 @@ struct NaClSyscallTableEntry {
 /* these are defined in the platform specific code */
 extern struct NaClSyscallTableEntry nacl_syscall[];
 
 void NaClSyscallTableInit(void);
 
+extern int nacl_syscall_counter;
+extern int nacl_syscall_trace_level_counter;
+extern int nacl_syscall_invoked_times[NACL_MAX_SYSCALLS];
+extern double nacl_syscall_execution_time[NACL_MAX_SYSCALLS];
+
 EXTERN_C_END
 
 #endif
diff --git a/src/trusted/service_runtime/nacl_syscall_handlers_gen.py b/src/trusted/service_runtime/nacl_syscall_handlers_gen.py
index 089d545b48b96ebb96..982d56251b6af99d9d 100755
--- a/src/trusted/service_runtime/nacl_syscall_handlers_gen.py
+++ b/src/trusted/service_runtime/nacl_syscall_handlers_gen.py
@@ -19,10 +19,11 @@
 #
 import getopt
 import re
 import sys
 
+
 AUTOGEN_COMMENT = """\
 /*
  * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
  *
  * Automatically generated code.  See nacl_syscall_handlers_gen.py
@@ -48,12 +49,51 @@ void NaClSyscallTableInit() {
 
 
 IMPLEMENTATION_SKELETON = """\
 /* this function was automagically generated */
 static int32_t %(name)sDecoder(struct NaClAppThread *natp) {
-%(members)s\
+  #ifdef SYSCALL_TIMING
+  int32_t retval;
+  clock_t nacl_sys_begin;
+  clock_t nacl_sys_finish;
+  #endif
+  #ifdef NACL_SYSCALL_TRACE_ENABLED
+  struct NaClApp *nap = natp->nap;
+  int32_t retval;
+#if %(arglist_not_empty)d
+  unsigned int i = 0;
+#endif
+  #endif
+  %(members)s\
+
+  #ifdef SYSCALL_TIMING
+  nacl_syscall_counter++;
+  nacl_syscall_invoked_times[%(num)s]++;
+  nacl_sys_begin = clock();
+  retval = %(name)s(natp%(arglist)s);
+  nacl_sys_finish = clock();
+  nacl_syscall_execution_time[%(num)s] += (double)(nacl_sys_finish - nacl_sys_begin) / CLOCKS_PER_SEC;
+  return retval;
+  #endif
+  #ifdef NACL_SYSCALL_TRACE_ENABLED
+  printf("[NaClSysCallInterface] cage id = %%d, syscall_num = %(num)s [enter][syscall_depth = %%d]\\n", nap->cage_id, nacl_syscall_trace_level_counter);
+  printf("==> %(num)s(");
+#if %(arglist_not_empty)d
+  for (i = 0; i < sizeof(p)/4; i++) {
+    printf("%%x,", *((uint32_t *)&p+i));
+  }
+#endif
+  printf(")\\n");
+  nacl_syscall_trace_level_counter++;
+  retval = %(name)s(natp%(arglist)s);
+  nacl_syscall_trace_level_counter--;
+  printf("[NaClSysCallInterface] cage id = %%d, syscall_num = %(num)s [exit][syscall_depth = %%d] \\n", nap->cage_id, nacl_syscall_trace_level_counter);
+  return retval;
+  #endif
+
   return %(name)s(natp%(arglist)s);
+
 }
 
 /*
  * Check that the function being wrapped has the same type as the type
  * declared in SYSCALL_LIST.
@@ -98,10 +138,11 @@ ARG_REGISTERS = {
 SYSCALL_LIST = [
     ('NACL_sys_null', 'NaClSysNull', []),
     ('NACL_sys_nameservice', 'NaClSysNameService', ['int *desc_in_out']),
     ('NACL_sys_dup', 'NaClSysDup', ['int oldfd']),
     ('NACL_sys_dup2', 'NaClSysDup2', ['int oldfd', 'int newfd']),
+    ('NACL_sys_dup3', 'NaClSysDup3', ['int oldfd', 'int newfd', 'int flags']),
     ('NACL_sys_open', 'NaClSysOpen',
      ['char *pathname', 'int flags', 'int mode']),
     ('NACL_sys_close', 'NaClSysClose', ['int d']),
     ('NACL_sys_read', 'NaClSysRead',
      ['int d', 'void *buf', 'size_t count']),
@@ -201,10 +242,16 @@ SYSCALL_LIST = [
      ['uint32_t stack_addr', 'uint32_t stack_size']),
     ('NACL_sys_exception_clear_flag', 'NaClSysExceptionClearFlag', []),
     ('NACL_sys_test_infoleak', 'NaClSysTestInfoLeak', []),
     ('NACL_sys_test_crash', 'NaClSysTestCrash', ['int crash_type']),
     ('NACL_sys_lind_syscall', 'NaClSysLindSyscall', ['uint32_t callNum', 'uint32_t inNum', 'void *inArgs', 'uint32_t outNum', 'void *outArgs']),
+    ('NACL_sys_pipe', 'NaClSysPipe', ['uint32_t *pipedes']),
+    ('NACL_sys_fork', 'NaClSysFork', []),
+    ('NACL_sys_execv', 'NaClSysExecv', []),
+    ('NACL_sys_execve', 'NaClSysExecve', ['void *path', 'void *argv', 'void *envp']),
+    ('NACL_sys_waitpid', 'NaClSysWaitpid', ['uint32_t pid', 'uint32_t *stat_loc', 'uint32_t options']),
+    ('NACL_sys_wait', 'NaClSysWait', ['uint32_t *stat_loc']),
     ]
 
 
 # Syscall arguments MUST be declared in a simple-to-parse manner!
 # They must match the following regexp:
@@ -295,12 +342,14 @@ def PrintSyscallTableInitializer(protos, ostr):
 
 
 def PrintImplSkel(architecture, protos, ostr):
   print >>ostr, AUTOGEN_COMMENT
   for syscall_number, func_name, alist in protos:
-    values = { 'name' : func_name,
+    values = { 'num' : syscall_number,
+               'name' : func_name,
                'arglist' : ArgList(architecture, alist),
+               'arglist_not_empty' : 1 if ArgList(architecture, alist) else 0,
                'arg_type_list' :
                    ', '.join(['struct NaClAppThread *natp'] + alist),
                'members' : MemoryArgStruct(architecture, func_name, alist),
                }
     print >>ostr, IMPLEMENTATION_SKELETON % values
diff --git a/src/trusted/service_runtime/posix/sel_memory.c b/src/trusted/service_runtime/posix/sel_memory.c
index 879356323900a444c6..c268580e0f79b6f16e 100644
--- a/src/trusted/service_runtime/posix/sel_memory.c
+++ b/src/trusted/service_runtime/posix/sel_memory.c
@@ -54,10 +54,18 @@ static int NaClPageAllocInternalFlags(void **p, size_t size, int map_flags) {
     *p = addr;
   }
   return (NULL == addr) ? -ENOMEM : 0;
 }
 
+void *NaClPageAllocFlags(void **p, size_t size, int map_flags) {
+    if (*p)
+        map_flags |= MAP_FIXED;
+    if (NaClPageAllocInternalFlags(p, size, map_flags) < 0)
+        return NULL;
+    return *p;
+}
+
 /*
  * Note that NaClPageAlloc does not allocate pages that satisify
  * NaClIsAllocPageMultiple.  On linux/osx, the system does not impose
  * any such restrictions, and we only need to enforce the restriction
  * on NaCl app code to ensure that the app code is portable across all
diff --git a/src/trusted/service_runtime/sel_addrspace.c b/src/trusted/service_runtime/sel_addrspace.c
index 85fc940522ef4f996b..ea06d8d4c2dbbb29c9 100644
--- a/src/trusted/service_runtime/sel_addrspace.c
+++ b/src/trusted/service_runtime/sel_addrspace.c
@@ -45,19 +45,18 @@ NaClErrorCode NaClAllocAddrSpaceAslr(struct NaClApp *nap,
    * any detail level higher than LOG_INFO is disabled in the release
    * builds.  This was to reduce logging overhead, so as to eliminate
    * at least a function call as well as possibly a TLS/TSD read if
    * module-specific logging verbosity level comparisons are needed.
    */
-  NaClLog(LOG_INFO,
-          ("Native Client module will be loaded at"
-           " base address 0x%016"NACL_PRIxPTR"\n"),
+  NaClLog(1, "Native Client module will be loaded at"
+          " base address 0x%016"NACL_PRIxPTR"\n",
           nap->mem_start);
 
   hole_start = NaClRoundAllocPage(nap->data_end);
 
   if (nap->stack_size >= ((uintptr_t) 1U) << nap->addr_bits) {
-    NaClLog(LOG_FATAL, "NaClAllocAddrSpace: stack too large!");
+    NaClLog(1, "%s\n", "NaClAllocAddrSpace: stack too large!");
   }
   stack_start = (((uintptr_t) 1U) << nap->addr_bits) - nap->stack_size;
   stack_start = NaClTruncAllocPage(stack_start);
 
   if (stack_start < hole_start) {
@@ -127,11 +126,10 @@ NaClErrorCode NaClMemoryProtection(struct NaClApp *nap) {
                PROT_NONE,
                NACL_ABI_MAP_PRIVATE,
                NULL,
                0,
                0);
-
   start_addr = nap->mem_start + NACL_SYSCALL_START_ADDR;
   /*
    * The next pages up to NACL_TRAMPOLINE_END are the trampolines.
    * Immediately following that is the loaded text section.
    * These are collectively marked as PROT_READ | PROT_EXEC.
@@ -143,15 +141,14 @@ NaClErrorCode NaClMemoryProtection(struct NaClApp *nap) {
           start_addr, region_size,
           start_addr + region_size);
   if (0 != (err = NaClMprotect((void *) start_addr,
                                region_size,
                                PROT_READ | PROT_EXEC))) {
-    NaClLog(LOG_ERROR,
-            ("NaClMemoryProtection: "
-             "NaClMprotect(0x%08"NACL_PRIxPTR", "
-             "0x%08"NACL_PRIxS", 0x%x) failed, "
-             "error %d (trampoline + code)\n"),
+    NaClLog(1, "NaClMemoryProtection: "
+            "NaClMprotect(0x%08"NACL_PRIxPTR", "
+            "0x%08"NACL_PRIxS", 0x%x) failed, "
+            "error %d (trampoline + code)\n",
             start_addr, region_size, PROT_READ | PROT_EXEC,
             err);
     return LOAD_MPROTECT_FAIL;
   }
   NaClVmmapAdd(&nap->mem_map,
@@ -213,15 +210,14 @@ NaClErrorCode NaClMemoryProtection(struct NaClApp *nap) {
             start_addr, region_size,
             start_addr + region_size);
     if (0 != (err = NaClMprotect((void *) start_addr,
                                  region_size,
                                  PROT_READ))) {
-      NaClLog(LOG_ERROR,
-              ("NaClMemoryProtection: "
-               "NaClMprotect(0x%08"NACL_PRIxPTR", "
-               "0x%08"NACL_PRIxS", 0x%x) failed, "
-               "error %d (rodata)\n"),
+      NaClLog(1, "NaClMemoryProtection: "
+              "NaClMprotect(0x%08"NACL_PRIxPTR", "
+              "0x%08"NACL_PRIxS", 0x%x) failed, "
+              "error %d (rodata)\n",
               start_addr, region_size, PROT_READ,
               err);
       return LOAD_MPROTECT_FAIL;
     }
     NaClVmmapAdd(&nap->mem_map,
@@ -249,15 +245,14 @@ NaClErrorCode NaClMemoryProtection(struct NaClApp *nap) {
             start_addr, region_size,
             start_addr + region_size);
     if (0 != (err = NaClMprotect((void *) start_addr,
                                  region_size,
                                  PROT_READ | PROT_WRITE))) {
-      NaClLog(LOG_ERROR,
-              ("NaClMemoryProtection: "
-               "NaClMprotect(0x%08"NACL_PRIxPTR", "
-               "0x%08"NACL_PRIxS", 0x%x) failed, "
-               "error %d (data)\n"),
+      NaClLog(1, "NaClMemoryProtection: "
+              "NaClMprotect(0x%08"NACL_PRIxPTR", "
+              "0x%08"NACL_PRIxS", 0x%x) failed, "
+              "error %d (data)\n",
               start_addr, region_size, PROT_READ | PROT_WRITE,
               err);
       return LOAD_MPROTECT_FAIL;
     }
     NaClVmmapAdd(&nap->mem_map,
@@ -282,15 +277,14 @@ NaClErrorCode NaClMemoryProtection(struct NaClApp *nap) {
           start_addr, region_size,
           start_addr + region_size);
   if (0 != (err = NaClMprotect((void *) start_addr,
                                NaClRoundAllocPage(nap->stack_size),
                                PROT_READ | PROT_WRITE))) {
-    NaClLog(LOG_ERROR,
-            ("NaClMemoryProtection: "
+    NaClLog(1, "NaClMemoryProtection: "
              "NaClMprotect(0x%08"NACL_PRIxPTR", "
              "0x%08"NACL_PRIxS", 0x%x) failed, "
-             "error %d (stack)\n"),
+             "error %d (stack)\n",
             start_addr, region_size, PROT_READ | PROT_WRITE,
             err);
     return LOAD_MPROTECT_FAIL;
   }
 
diff --git a/src/trusted/service_runtime/sel_ldr.c b/src/trusted/service_runtime/sel_ldr.c
index 15f3ea60ba1c3fd663..5e887605429852fde4 100644
--- a/src/trusted/service_runtime/sel_ldr.c
+++ b/src/trusted/service_runtime/sel_ldr.c
@@ -32,10 +32,11 @@
 #include "native_client/src/trusted/fault_injection/test_injection.h"
 #include "native_client/src/trusted/gio/gio_nacl_desc.h"
 #include "native_client/src/trusted/gio/gio_shm.h"
 #include "native_client/src/trusted/interval_multiset/nacl_interval_range_tree_intern.h"
 #include "native_client/src/trusted/service_runtime/arch/sel_ldr_arch.h"
+#include "native_client/src/trusted/service_runtime/include/bits/mman.h"
 #include "native_client/src/trusted/service_runtime/include/bits/nacl_syscalls.h"
 #include "native_client/src/trusted/service_runtime/include/sys/fcntl.h"
 #include "native_client/src/trusted/service_runtime/include/sys/stat.h"
 #include "native_client/src/trusted/service_runtime/include/sys/time.h"
 #include "native_client/src/trusted/service_runtime/nacl_app.h"
@@ -44,10 +45,11 @@
 #include "native_client/src/trusted/service_runtime/nacl_globals.h"
 #include "native_client/src/trusted/service_runtime/nacl_resource.h"
 #include "native_client/src/trusted/service_runtime/nacl_reverse_quota_interface.h"
 #include "native_client/src/trusted/service_runtime/nacl_syscall_common.h"
 #include "native_client/src/trusted/service_runtime/nacl_syscall_handlers.h"
+#include "native_client/src/trusted/service_runtime/nacl_text.h"
 #include "native_client/src/trusted/service_runtime/nacl_valgrind_hooks.h"
 #include "native_client/src/trusted/service_runtime/name_service/default_name_service.h"
 #include "native_client/src/trusted/service_runtime/name_service/name_service.h"
 #include "native_client/src/trusted/service_runtime/sel_addrspace.h"
 #include "native_client/src/trusted/service_runtime/sel_ldr.h"
@@ -55,12 +57,32 @@
 #include "native_client/src/trusted/service_runtime/sel_ldr_thread_interface.h"
 #include "native_client/src/trusted/simple_service/nacl_simple_rservice.h"
 #include "native_client/src/trusted/simple_service/nacl_simple_service.h"
 #include "native_client/src/trusted/threading/nacl_thread_interface.h"
 
+double time_counter = 0.0;
+double time_start = 0.0;
+double time_end = 0.0;
+int cage = 1001;
+
+/*
+ * `fd_cage_table[cage_id][fd] = real fd`
+ *
+ * The [fd] idx is the virtual fd visible to the cages.
+ *
+ * -jp
+ */
+volatile sig_atomic_t fork_num;
+struct Pipe pipe_table[PIPE_NUM_MAX];
+int fd_cage_table[CAGING_FD_NUM][CAGING_FD_NUM];
+int cached_lib_num;
+
+// yiwen: lookup table for <file_path, mem_addr>
+struct CachedLibTable cached_lib_table[CACHED_LIB_NUM_MAX];
+
 static int IsEnvironmentVariableSet(char const *env_name) {
-  return NULL != getenv(env_name);
+  return !!getenv(env_name);
 }
 
 static int ShouldEnableDyncodeSyscalls(void) {
   return !IsEnvironmentVariableSet("NACL_DISABLE_DYNCODE_SYSCALLS");
 }
@@ -69,43 +91,35 @@ static int ShouldEnableDynamicLoading(void) {
   return !IsEnvironmentVariableSet("NACL_DISABLE_DYNAMIC_LOADING");
 }
 
 int NaClAppWithSyscallTableCtor(struct NaClApp               *nap,
                                 struct NaClSyscallTableEntry *table) {
-  struct NaClDescEffectorLdr  *effp;
+  struct NaClDescEffectorLdr  *effp = NULL;
 
   /* The validation cache will be injected later, if it exists. */
   nap->validation_cache = NULL;
 
   nap->validator = NaClCreateValidator();
 
   /* Get the set of features that the CPU we're running on supports. */
   /* These may be adjusted later in sel_main.c for fixed-feature CPU mode. */
-  nap->cpu_features = (NaClCPUFeatures *) malloc(
-      nap->validator->CPUFeatureSize);
-  if (NULL == nap->cpu_features) {
+  nap->cpu_features = malloc(nap->validator->CPUFeatureSize);
+  if (!nap->cpu_features) {
     goto cleanup_none;
   }
   nap->validator->GetCurrentCPUFeatures(nap->cpu_features);
   nap->fixed_feature_cpu_mode = 0;
-
   nap->addr_bits = NACL_MAX_ADDR_BITS;
-
   nap->stack_size = NACL_DEFAULT_STACK_MAX;
   nap->initial_nexe_max_code_bytes = 0;
-
   nap->aux_info = NULL;
-
   nap->mem_start = 0;
 
-#if (NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 \
-     && NACL_BUILD_SUBARCH == 32)
+#if NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 && NACL_BUILD_SUBARCH == 32
   nap->pcrel_thunk = 0;
   nap->pcrel_thunk_end = 0;
-#endif
-#if (NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 \
-     && NACL_BUILD_SUBARCH == 64)
+#elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 && NACL_BUILD_SUBARCH == 64
   nap->nacl_syscall_addr = 0;
   nap->get_tls_fast_path1_addr = 0;
   nap->get_tls_fast_path2_addr = 0;
 #endif
 
@@ -113,84 +127,81 @@ int NaClAppWithSyscallTableCtor(struct NaClApp               *nap,
   nap->dynamic_text_start = 0;
   nap->dynamic_text_end = 0;
   nap->rodata_start = 0;
   nap->data_start = 0;
   nap->data_end = 0;
-
   nap->initial_entry_pt = 0;
   nap->user_entry_pt = 0;
 
   if (!DynArrayCtor(&nap->threads, 2)) {
     goto cleanup_cpu_features;
   }
   if (!DynArrayCtor(&nap->desc_tbl, 2)) {
     goto cleanup_threads;
   }
-  if (!NaClVmmapCtor(&nap->mem_map)) {
+  if (!DynArrayCtor(&nap->children, 2)) {
     goto cleanup_desc_tbl;
   }
+  if (!NaClVmmapCtor(&nap->mem_map)) {
+    goto cleanup_children;
+  }
 
-  nap->mem_io_regions = (struct NaClIntervalMultiset *) malloc(
-      sizeof(struct NaClIntervalRangeTree));
-  if (NULL == nap->mem_io_regions) {
+  nap->mem_io_regions = malloc(sizeof *nap->mem_io_regions);
+  if (!nap->mem_io_regions) {
     goto cleanup_mem_map;
   }
 
-  if (!NaClIntervalRangeTreeCtor((struct NaClIntervalRangeTree *)
-                                 nap->mem_io_regions)) {
+  if (!NaClIntervalRangeTreeCtor((struct NaClIntervalRangeTree *)nap->mem_io_regions)) {
     free(nap->mem_io_regions);
     nap->mem_io_regions = NULL;
     goto cleanup_mem_map;
   }
 
-  effp = (struct NaClDescEffectorLdr *) malloc(sizeof *effp);
-  if (NULL == effp) {
+  effp = malloc(sizeof *effp);
+  if (!effp) {
     goto cleanup_mem_io_regions;
   }
   if (!NaClDescEffectorLdrCtor(effp, nap)) {
     goto cleanup_effp_free;
   }
   nap->effp = (struct NaClDescEffector *) effp;
-
   nap->enable_dyncode_syscalls = ShouldEnableDyncodeSyscalls();
   nap->use_shm_for_dynamic_text = ShouldEnableDynamicLoading();
   nap->text_shm = NULL;
+
   if (!NaClMutexCtor(&nap->dynamic_load_mutex)) {
     goto cleanup_effp_free;
   }
+  if (!NaClMutexCtor(&nap->children_mu)) {
+    goto cleanup_dynamic_load_mutex;
+  }
   nap->dynamic_page_bitmap = NULL;
-
   nap->dynamic_regions = NULL;
   nap->num_dynamic_regions = 0;
   nap->dynamic_regions_allocated = 0;
   nap->dynamic_delete_generation = 0;
-
   nap->dynamic_mapcache_offset = 0;
   nap->dynamic_mapcache_size = 0;
   nap->dynamic_mapcache_ret = 0;
-
   nap->service_port = NULL;
   nap->service_address = NULL;
   nap->secure_service_port = NULL;
   nap->secure_service_address = NULL;
   nap->bootstrap_channel = NULL;
   nap->secure_service = NULL;
   nap->irt_loaded = 0;
   nap->main_exe_prevalidated = 0;
-
-  nap->manifest_proxy = NULL;
-  nap->kernel_service = NULL;
   nap->resource_phase = NACL_RESOURCE_PHASE_START;
+
   if (!NaClResourceNaClAppInit(&nap->resources, nap)) {
     goto cleanup_dynamic_load_mutex;
   }
   nap->reverse_client = NULL;
   nap->reverse_channel_initialization_state =
       NACL_REVERSE_CHANNEL_UNINITIALIZED;
-
   if (!NaClMutexCtor(&nap->mu)) {
-    goto cleanup_dynamic_load_mutex;
+    goto cleanup_children_mutex;
   }
   if (!NaClCondVarCtor(&nap->cv)) {
     goto cleanup_mu;
   }
 
@@ -198,17 +209,15 @@ int NaClAppWithSyscallTableCtor(struct NaClApp               *nap,
   nap->vm_hole_may_exist = 0;
   nap->threads_launching = 0;
 #endif
 
   nap->syscall_table = table;
-
   nap->module_load_status = LOAD_STATUS_UNKNOWN;
   nap->module_may_start = 0;  /* only when secure_service != NULL */
-
   nap->name_service = (struct NaClNameService *) malloc(
       sizeof *nap->name_service);
-  if (NULL == nap->name_service) {
+  if (!nap->name_service) {
     goto cleanup_cv;
   }
   if (!NaClNameServiceCtor(nap->name_service,
                            NaClAddrSpSquattingThreadIfFactoryFunction,
                            (void *) nap)) {
@@ -298,19 +307,23 @@ int NaClAppWithSyscallTableCtor(struct NaClApp               *nap,
   NaClRefCountUnref((struct NaClRefCount *) nap->name_service);
  cleanup_cv:
   NaClCondVarDtor(&nap->cv);
  cleanup_mu:
   NaClMutexDtor(&nap->mu);
+ cleanup_children_mutex:
+  NaClMutexDtor(&nap->children_mu);
  cleanup_dynamic_load_mutex:
   NaClMutexDtor(&nap->dynamic_load_mutex);
  cleanup_effp_free:
   free(nap->effp);
  cleanup_mem_io_regions:
   NaClIntervalMultisetDelete(nap->mem_io_regions);
   nap->mem_io_regions = NULL;
  cleanup_mem_map:
   NaClVmmapDtor(&nap->mem_map);
+ cleanup_children:
+  DynArrayDtor(&nap->children);
  cleanup_desc_tbl:
   DynArrayDtor(&nap->desc_tbl);
  cleanup_threads:
   DynArrayDtor(&nap->threads);
  cleanup_cpu_features:
@@ -379,11 +392,11 @@ GENERIC_STORE(32)
 GENERIC_STORE(64)
 
 #undef GENERIC_STORE
 
 struct NaClPatchInfo *NaClPatchInfoCtor(struct NaClPatchInfo *self) {
-  if (NULL != self) {
+  if (self) {
     memset(self, 0, sizeof *self);
   }
   return self;
 }
 
@@ -528,11 +541,11 @@ void  NaClMemRegionPrinter(void                   *state,
           entry->page_num << NACL_PAGESHIFT);
   gprintf(gp,   "end vaddr   0x%"NACL_PRIxPTR"\n",
           (entry->page_num + entry->npages) << NACL_PAGESHIFT);
   gprintf(gp,   "prot   0x%08x\n", entry->prot);
   gprintf(gp,   "%sshared/backed by a file\n",
-          (NULL == entry->desc) ? "not " : "");
+          (!entry->desc) ? "not " : "");
 }
 
 void  NaClAppPrintDetails(struct NaClApp  *nap,
                           struct Gio      *gp) {
   NaClXMutexLock(&nap->mu);
@@ -566,11 +579,11 @@ void  NaClAppPrintDetails(struct NaClApp  *nap,
 struct NaClDesc *NaClGetDescMu(struct NaClApp *nap,
                                int            d) {
   struct NaClDesc *result;
 
   result = (struct NaClDesc *) DynArrayGet(&nap->desc_tbl, d);
-  if (NULL != result) {
+  if (result) {
     NaClDescRef(result);
   }
 
   return result;
 }
@@ -583,11 +596,11 @@ void NaClSetDescMu(struct NaClApp   *nap,
   result = (struct NaClDesc *) DynArrayGet(&nap->desc_tbl, d);
   NaClDescSafeUnref(result);
 
   if (!DynArraySet(&nap->desc_tbl, d, ndp)) {
     NaClLog(LOG_FATAL,
-            "NaClSetDesc: could not set descriptor %d to 0x%08"
+            "NaClSetDesc: could not set descriptor %d to 0x%#08"
             NACL_PRIxPTR"\n",
             d,
             (uintptr_t) ndp);
   }
 }
@@ -648,10 +661,11 @@ int NaClAddThreadMu(struct NaClApp        *nap,
     NaClLog(LOG_FATAL,
             "NaClAddThreadMu: DynArraySet at position %"NACL_PRIuS" failed\n",
             pos);
   }
   ++nap->num_threads;
+
   return (int) pos;
 }
 
 int NaClAddThread(struct NaClApp        *nap,
                   struct NaClAppThread  *natp) {
@@ -664,21 +678,21 @@ int NaClAddThread(struct NaClApp        *nap,
   return pos;
 }
 
 void NaClRemoveThreadMu(struct NaClApp  *nap,
                         int             thread_num) {
-  if (NULL == DynArrayGet(&nap->threads, thread_num)) {
-    NaClLog(LOG_FATAL,
+  if (!DynArrayGet(&nap->threads, thread_num)) {
+     NaClLog(LOG_FATAL,
             "NaClRemoveThreadMu:: thread to be removed is not in the table\n");
   }
   if (nap->num_threads == 0) {
-    NaClLog(LOG_FATAL,
+     NaClLog(LOG_FATAL,
             "NaClRemoveThreadMu:: num_threads cannot be 0!!!\n");
   }
   --nap->num_threads;
   if (!DynArraySet(&nap->threads, thread_num, (struct NaClAppThread *) NULL)) {
-    NaClLog(LOG_FATAL,
+     NaClLog(LOG_FATAL,
             "NaClRemoveThreadMu:: DynArraySet at position %d failed\n",
             thread_num);
   }
 }
 
@@ -699,19 +713,24 @@ void NaClAddHostDescriptor(struct NaClApp *nap,
                            int            flag,
                            int            nacl_desc) {
   struct NaClDescIoDesc *dp;
 
   NaClLog(4,
-          "NaClAddHostDescriptor: host %d as nacl desc %d, flag 0x%x\n",
+          "NaClAddHostDescriptor: host %d as nacl desc %d, flag %#x\n",
           host_os_desc,
           nacl_desc,
           flag);
   dp = NaClDescIoDescMake(NaClHostDescPosixMake(host_os_desc, flag));
-  if (NULL == dp) {
+  if (!dp) {
     NaClLog(LOG_FATAL, "NaClAddHostDescriptor: NaClDescIoDescMake failed\n");
   }
-  NaClSetDesc(nap, nacl_desc, (struct NaClDesc *) dp);
+  NaClSetDesc(nap, nacl_desc, (struct NaClDesc *)dp);
+  if (host_os_desc >= FILE_DESC_MAX) {
+    NaClLog(LOG_FATAL, "NaClAddHostDescriptor: fd %d is too large for fd_maps\n", host_os_desc);
+    return;
+  }
+  nap->fd_maps[host_os_desc] = (struct NaClDesc *)dp;
 }
 
 void NaClAddImcHandle(struct NaClApp  *nap,
                       NaClHandle      h,
                       int             nacl_desc) {
@@ -721,11 +740,11 @@ void NaClAddImcHandle(struct NaClApp  *nap,
           ("NaClAddImcHandle: importing NaClHandle %"NACL_PRIxPTR
            " as nacl desc %d\n"),
           (uintptr_t) h,
           nacl_desc);
   dp = (struct NaClDescImcDesc *) malloc(sizeof *dp);
-  if (NACL_FI_ERROR_COND("NaClAddImcHandle__malloc", NULL == dp)) {
+  if (NACL_FI_ERROR_COND("NaClAddImcHandle__malloc", !dp)) {
     NaClLog(LOG_FATAL, "NaClAddImcHandle: no memory\n");
   }
   if (NACL_FI_ERROR_COND("NaClAddImcHandle__ctor",
                          !NaClDescImcDescCtor(dp, h))) {
     NaClLog(LOG_FATAL, ("NaClAddImcHandle: cannot construct"
@@ -763,37 +782,44 @@ static struct {
  * control values can be handled in which phases by allowing the
  * NaClResourceOpen to fail, and only in the last phase do we check
  * that the redirection succeeded in *some* phase.
  */
 static void NaClProcessRedirControl(struct NaClApp *nap) {
+  char const      *env = NULL;
+  struct NaClDesc *ndp = NULL;
+  int d = 0;
+  char const *env_name = NULL;
+  int nacl_flags = 0;
+  int mode = 0;
 
-  size_t          ix;
-  char const      *env;
-  struct NaClDesc *ndp;
+  for (size_t ix = 0; ix < NACL_ARRAY_SIZE(g_nacl_redir_control); ix++, ndp = NULL) {
+    CHECK(ix < INT_MAX);
+    d = g_nacl_redir_control[ix].d;
+    env_name = g_nacl_redir_control[ix].env_name;
+    nacl_flags = g_nacl_redir_control[ix].nacl_flags;
+    mode = g_nacl_redir_control[ix].mode;
 
-  for (ix = 0; ix < NACL_ARRAY_SIZE(g_nacl_redir_control); ++ix) {
-    ndp = NULL;
-    if (NULL != (env = getenv(g_nacl_redir_control[ix].env_name))) {
-      NaClLog(4, "getenv(%s) -> %s\n", g_nacl_redir_control[ix].env_name, env);
-      ndp = NaClResourceOpen((struct NaClResource *) &nap->resources,
+    if ((env = getenv(env_name))) {
+      NaClLog(1, "getenv(%s) -> %s\n", env_name, env);
+      ndp = NaClResourceOpen((struct NaClResource *)&nap->resources,
                              env,
-                             g_nacl_redir_control[ix].nacl_flags,
-                             g_nacl_redir_control[ix].mode);
-      NaClLog(4, " NaClResourceOpen returned %"NACL_PRIxPTR"\n",
-              (uintptr_t) ndp);
+                             nacl_flags,
+                             mode);
+      NaClLog(1, " NaClResourceOpen returned %"NACL_PRIxPTR"\n", (uintptr_t) ndp);
     }
 
-    if (NULL != ndp) {
-      NaClLog(4, "Setting descriptor %d\n", (int) ix);
-      NaClSetDesc(nap, (int) ix, ndp);
-    } else if (NACL_RESOURCE_PHASE_START == nap->resource_phase) {
-      /*
-       * Environment not set or redirect failed -- handle default inheritance.
-       */
-      NaClAddHostDescriptor(nap, g_nacl_redir_control[ix].d,
-                            g_nacl_redir_control[ix].nacl_flags, (int) ix);
+    if (ndp) {
+      NaClLog(1, "Setting descriptor %d\n", (int)ix);
+      NaClSetDesc(nap, (int)ix, ndp);
+      continue;
     }
+
+     /*
+      * Environment not set or redirect failed -- handle default inheritance.
+      */
+    if (NACL_RESOURCE_PHASE_START == nap->resource_phase)
+      NaClAddHostDescriptor(nap, d, nacl_flags, (int)ix);
   }
 }
 
 /*
  * Process default descriptor inheritance.  This means dup'ing
@@ -815,25 +841,20 @@ void NaClAppInitialDescriptorHookup(struct NaClApp  *nap) {
   NaClProcessRedirControl(nap);
   NaClLog(4, "... done.\n");
 }
 
 void NaClCreateServiceSocket(struct NaClApp *nap) {
-  struct NaClDesc *secure_pair[2];
-  struct NaClDesc *pair[2];
+  struct NaClDesc *secure_pair[2] = {0};
+  struct NaClDesc *pair[2] = {0};
 
   NaClLog(3, "Entered NaClCreateServiceSocket\n");
 
   if (NACL_FI_ERROR_COND("NaClCreateServiceSocket__secure_boundsock",
                          0 != NaClCommonDescMakeBoundSock(secure_pair))) {
     NaClLog(LOG_FATAL, "Cound not create secure service socket\n");
   }
-  NaClLog(4,
-          "got bound socket at 0x%08"NACL_PRIxPTR", "
-          "addr at 0x%08"NACL_PRIxPTR"\n",
-          (uintptr_t) secure_pair[0],
-          (uintptr_t) secure_pair[1]);
-
+  NaClLog(1, "got bound socket at %p, addr at %p\n", (void *)secure_pair[0], (void *)secure_pair[1]);
   NaClDescSafeUnref(nap->secure_service_port);
   nap->secure_service_port = secure_pair[0];
 
   NaClDescSafeUnref(nap->secure_service_address);
   nap->secure_service_address = secure_pair[1];
@@ -868,60 +889,59 @@ void NaClCreateServiceSocket(struct NaClApp *nap) {
  * reference to it at nap->bootstrap_channel, then send the
  * service_address over that channel.
  */
 void NaClSetUpBootstrapChannel(struct NaClApp  *nap,
                                NaClHandle      inherited_desc) {
-  struct NaClDescImcDesc      *channel;
-  struct NaClImcTypedMsgHdr   hdr;
-  struct NaClDesc             *descs[2];
-  ssize_t                     rv;
+  struct NaClDescImcDesc      *channel = NULL;
+  struct NaClImcTypedMsgHdr   hdr = {0};
+  struct NaClDesc             *descs[2] = {0};
+  ssize_t                     rv = 0;
 
-  NaClLog(4,
-          "NaClSetUpBootstrapChannel(0x%08"NACL_PRIxPTR", %"NACL_PRIdPTR")\n",
+  NaClLog(1, "NaClSetUpBootstrapChannel(0x%08"NACL_PRIxPTR", %"NACL_PRIdPTR")\n",
           (uintptr_t) nap,
           (uintptr_t) inherited_desc);
 
-  channel = (struct NaClDescImcDesc *) malloc(sizeof *channel);
-  if (NULL == channel) {
+  channel = malloc(sizeof *channel);
+  if (!channel) {
     NaClLog(LOG_FATAL, "NaClSetUpBootstrapChannel: no memory\n");
+    return;
   }
   if (!NaClDescImcDescCtor(channel, inherited_desc)) {
     NaClLog(LOG_FATAL,
             ("NaClSetUpBootstrapChannel: cannot construct IMC descriptor"
              " object for inherited descriptor %"NACL_PRIdPTR"\n"),
             (uintptr_t) inherited_desc);
     return;
   }
-  if (NULL == nap->secure_service_address) {
+  if (!nap->secure_service_address) {
     NaClLog(LOG_FATAL,
             "NaClSetUpBootstrapChannel: secure service address not set\n");
     return;
   }
-  if (NULL == nap->service_address) {
+  if (!nap->service_address) {
     NaClLog(LOG_FATAL,
             "NaClSetUpBootstrapChannel: service address not set\n");
     return;
   }
   /*
    * service_address and service_port are set together.
    */
   descs[0] = nap->secure_service_address;
   descs[1] = nap->service_address;
 
-  hdr.iov = (struct NaClImcMsgIoVec *) NULL;
+  hdr.iov = (struct NaClImcMsgIoVec *)NULL;
   hdr.iov_length = 0;
   hdr.ndescv = descs;
   hdr.ndesc_length = NACL_ARRAY_SIZE(descs);
 
-  rv = (*NACL_VTBL(NaClDesc, channel)->SendMsg)((struct NaClDesc *) channel,
-                                                &hdr, 0);
+  rv = NACL_VTBL(NaClDesc, channel)->SendMsg((struct NaClDesc *)channel, &hdr, 0);
   NaClXMutexLock(&nap->mu);
-  if (NULL != nap->bootstrap_channel) {
+  if (nap->bootstrap_channel) {
     NaClLog(LOG_FATAL,
             "NaClSetUpBootstrapChannel: cannot have two bootstrap channels\n");
   }
-  nap->bootstrap_channel = (struct NaClDesc *) channel;
+  nap->bootstrap_channel = (struct NaClDesc *)channel;
   channel = NULL;
   NaClXMutexUnlock(&nap->mu);
 
   NaClLog(1,
           ("NaClSetUpBootstrapChannel: descriptor %"NACL_PRIdPTR
@@ -970,11 +990,11 @@ static void NaClLoadModuleRpc(struct NaClSrpcRpc      *rpc,
   NaClLog(4, "NaClLoadModuleRpc: entered\n");
 
   rpc->result = NACL_SRPC_RESULT_INTERNAL;
 
   aux = strdup(in_args[1]->arrays.str);
-  if (NULL == aux) {
+  if (!aux) {
     rpc->result = NACL_SRPC_RESULT_NO_MEMORY;
     goto cleanup;
   }
   NaClLog(4, "Received aux_info: %s\n", aux);
 
@@ -1112,16 +1132,16 @@ static void NaClSecureChannelStartModuleRpc(struct NaClSrpcRpc     *rpc,
    * without an answer.
    */
 
   NaClXMutexLock(&nap->mu);
   if (nap->module_may_start) {
-    NaClLog(LOG_ERROR, "Duplicate StartModule RPC?!?\n");
     status = LOAD_DUP_START_MODULE;
+    NaClLog(LOG_ERROR, "Duplicate StartModule RPC?!? status: [%u]\n", status);
   } else {
     nap->module_may_start = 1;
   }
-  NaClLog(4, "NaClSecureChannelStartModuleRpc: broadcasting\n");
+  NaClLog(1, "%s\n", "NaClSecureChannelStartModuleRpc: broadcasting");
   NaClXCondVarBroadcast(&nap->cv);
   NaClXMutexUnlock(&nap->mu);
 
   NaClLog(4, "NaClSecureChannelStartModuleRpc exiting\n");
 }
@@ -1159,11 +1179,11 @@ NaClErrorCode NaClWaitForStartModuleCommand(struct NaClApp *nap) {
 
   return status;
 }
 
 void NaClBlockIfCommandChannelExists(struct NaClApp *nap) {
-  if (NULL != nap->secure_service) {
+  if (nap->secure_service) {
     for (;;) {
       struct nacl_abi_timespec req;
       req.tv_sec = 1000;
       req.tv_nsec = 0;
       NaClNanosleep(&req, (struct nacl_abi_timespec *) NULL);
@@ -1212,11 +1232,11 @@ static void NaClSecureReverseClientCallback(
   if (!NaClSrpcClientCtor(&nap->reverse_channel, new_conn)) {
     NaClLog(LOG_FATAL, "Reverse channel SRPC Client Ctor failed\n");
   }
   nap->reverse_quota_interface = (struct NaClReverseQuotaInterface *)
       malloc(sizeof *nap->reverse_quota_interface);
-  if (NULL == nap->reverse_quota_interface ||
+  if (!nap->reverse_quota_interface ||
       NACL_FI_ERROR_COND(
           ("NaClSecureReverseClientCallback"
            "__NaClReverseQuotaInterfaceCtor"),
           !NaClReverseQuotaInterfaceCtor(nap->reverse_quota_interface,
                                          nap))) {
@@ -1240,11 +1260,11 @@ static void NaClSecureReverseClientSetup(struct NaClSrpcRpc     *rpc,
 
   UNREFERENCED_PARAMETER(in_args);
   NaClLog(4, "Entered NaClSecureReverseClientSetup\n");
 
   NaClXMutexLock(&nap->mu);
-  if (NULL != nap->reverse_client) {
+  if (nap->reverse_client) {
     NaClLog(LOG_FATAL, "Double reverse setup RPC\n");
   }
   if (NACL_REVERSE_CHANNEL_UNINITIALIZED !=
       nap->reverse_channel_initialization_state) {
     NaClLog(LOG_FATAL,
@@ -1252,11 +1272,11 @@ static void NaClSecureReverseClientSetup(struct NaClSrpcRpc     *rpc,
   }
   nap->reverse_channel_initialization_state =
       NACL_REVERSE_CHANNEL_INITIALIZATION_STARTED;
   /* the reverse connection is still coming */
   rev = (struct NaClSecureReverseClient *) malloc(sizeof *rev);
-  if (NULL == rev) {
+  if (!rev) {
     rpc->result = NACL_SRPC_RESULT_APP_ERROR;
     goto done;
   }
   NaClLog(4,
           "NaClSecureReverseClientSetup: invoking"
@@ -1306,11 +1326,11 @@ void NaClSecureCommandChannel(struct NaClApp *nap) {
   NaClLog(4, "Entered NaClSecureCommandChannel\n");
 
   secure_command_server = (struct NaClSecureService *) malloc(
       sizeof *secure_command_server);
   if (NACL_FI_ERROR_COND("NaClSecureCommandChannel__malloc",
-                         NULL == secure_command_server)) {
+                         !secure_command_server)) {
     NaClLog(LOG_FATAL, "Out of memory for secure command channel\n");
   }
   if (NACL_FI_ERROR_COND("NaClSecureCommandChannel__NaClSecureServiceCtor",
                          !NaClSecureServiceCtor(secure_command_server,
                                                 secure_handlers,
@@ -1420,5 +1440,188 @@ static void StopForDebuggerInit (uintptr_t mem_start) {
 }
 
 void NaClGdbHook(struct NaClApp const *nap) {
   StopForDebuggerInit(nap->mem_start);
 }
+
+/*
+ * Passed to NaClVmmapVisit in order to copy a memory region from
+ * an NaClApp to a child process (used when forking).
+ *
+ * -jp
+ *
+ * preconditions:
+ * * target_state must be a pointer to a valid, initialized NaClApp.
+ *
+ */
+static void NaClVmCopyEntry(void *target_state, struct NaClVmmapEntry *entry) {
+  struct NaClApp *target = target_state;
+  uintptr_t offset = target->mem_start;
+  uintptr_t parent_offset = target->parent ? target->parent->mem_start : 0;
+  uintptr_t page_addr_child = offset + (entry->page_num << NACL_PAGESHIFT);
+  uintptr_t page_addr_parent = parent_offset + (entry->page_num << NACL_PAGESHIFT);
+  size_t copy_size = entry->npages << NACL_PAGESHIFT;
+
+  /* don't copy pages if nap has no parent */
+  if (!parent_offset) {
+    return;
+  }
+  NaClLog(2, "copying %zu page(s) at %zu [%#lx] from (%p) to (%p)\n",
+          entry->npages,
+          entry->page_num,
+          copy_size,
+          (void *)page_addr_parent,
+          (void *)page_addr_child);
+  NaClVmmapAddWithOverwrite(&target->mem_map, entry->page_num, entry->npages,
+                            entry->prot, entry->flags|F_ANON_PRIV,
+                            entry->desc, entry->offset, entry->file_size);
+  if (!NaClPageAllocFlags((void **)&page_addr_child, copy_size, 0)) {
+    NaClLog(LOG_FATAL, "%s\n", "child vmmap NaClPageAllocAtAddr failed!");
+  }
+
+  /* temporarily set RW page permissions for copy */
+  NaClVmmapChangeProt(&target->mem_map, entry->page_num, entry->npages, entry->prot|PROT_RW);
+  NaClVmmapChangeProt(&target->parent->mem_map, entry->page_num, entry->npages, entry->prot|PROT_RW);
+  if (NaClMprotect((void *)page_addr_child, copy_size, PROT_RW) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "child vmmap page NaClMprotect failed!");
+  }
+  if (NaClMprotect((void *)page_addr_parent, copy_size, PROT_RW) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "parent vmmap page NaClMprotect failed!");
+  }
+
+  /* copy data pages point to */
+  memcpy((void *)page_addr_child, (void *)page_addr_parent, copy_size);
+  NaClPatchAddr(offset, parent_offset, (uintptr_t *)page_addr_child, copy_size / sizeof(uintptr_t));
+
+  /* reset to original page permissions */
+  NaClVmmapChangeProt(&target->mem_map, entry->page_num, entry->npages, entry->prot);
+  NaClVmmapChangeProt(&target->parent->mem_map, entry->page_num, entry->npages, entry->prot);
+  if (NaClMprotect((void *)page_addr_child, copy_size, entry->prot) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "child vmmap page NaClMprotect failed!");
+  }
+  if (NaClMprotect((void *)page_addr_parent, copy_size, entry->prot) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "parent vmmap page NaClMprotect failed!");
+  }
+}
+
+/*
+ * Passed to NaClDyncodeVisit in order to copy a dynamic region from
+ * an NaClApp to a child process (used when forking).
+ *
+ * -jp
+ *
+ * preconditions:
+ * * target_state must be a pointer to a valid, initialized NaClApp.
+ *
+ */
+static void NaClCopyDynamicRegion(void *target_state, struct NaClDynamicRegion *region) {
+  struct NaClApp *target = target_state;
+  uintptr_t offset = target->mem_start;
+  uintptr_t parent_offset = target->parent ? target->parent->mem_start : master_ctx->r15;
+  uintptr_t start = (region->start & UNTRUSTED_ADDR_MASK) + offset;
+  if (NaClMprotect((void *)start, region->size, PROT_RW) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "cbild dynamic text NaClMprotect failed!");
+  }
+  NaClLog(1, "copying dynamic code from (%p) to (%p)\n", (void *)start, (void *)region->start);
+  NaClDynamicRegionCreate(target, start, region->size, region->is_mmap);
+  memcpy((void *)start, (void *)region->start, region->size);
+  NaClPatchAddr(offset, parent_offset, (uintptr_t *)start, region->size / sizeof(uintptr_t));
+  if (NaClMprotect((void *)start, region->size, PROT_RX) == -1) {
+    NaClLog(LOG_FATAL, "%s\n", "cbild dynamic text NaClMprotect failed!");
+  }
+}
+
+/*
+ * Copy the entire address execution context of an NaClApp to a child
+ * process.
+ *
+ * preconditions:
+ * * `nap_parent` and `nap_child` must both be pointers to valid, initialized NaClApps
+ * * Caller must hold both the nap_parent->mu and the nap_child->mu mutexes
+ */
+void NaClCopyExecutionContext(struct NaClApp *nap_parent, struct NaClApp *nap_child) {
+  size_t stack_size = nap_parent->stack_size;
+  size_t dyncode_size = nap_parent->dynamic_text_end - nap_parent->dynamic_text_start - NACL_HALT_SLED_SIZE;
+  size_t stack_npages = stack_size >> NACL_PAGESHIFT;
+  size_t dyncode_npages = dyncode_size >> NACL_PAGESHIFT;
+  void *dyncode_parent = (void *)NaClUserToSys(nap_parent, nap_parent->dynamic_text_start);
+  void *dyncode_child = (void *)NaClUserToSys(nap_child, nap_child->dynamic_text_start);
+  void *stackaddr_parent = (void *)NaClUserToSysAddrRange(nap_parent,
+                                                          NaClGetInitialStackTop(nap_parent) - stack_size,
+                                                          stack_size);
+  void *stackaddr_child = (void *)NaClUserToSysAddrRange(nap_child,
+                                                         NaClGetInitialStackTop(nap_child) - stack_size,
+                                                         stack_size);
+  uintptr_t dyncode_pnum_parent = NaClSysToUser(nap_parent, (uintptr_t)dyncode_parent) >> NACL_PAGESHIFT;
+  uintptr_t dyncode_pnum_child = NaClSysToUser(nap_child, (uintptr_t)dyncode_child) >> NACL_PAGESHIFT;
+  uintptr_t stack_pnum_parent = NaClSysToUser(nap_parent, (uintptr_t)stackaddr_parent) >> NACL_PAGESHIFT;
+  uintptr_t stack_pnum_child = NaClSysToUser(nap_child, (uintptr_t)stackaddr_child) >> NACL_PAGESHIFT;
+
+  UNREFERENCED_PARAMETER(dyncode_pnum_parent);
+  UNREFERENCED_PARAMETER(stack_pnum_parent);
+
+  NaClLog(1, "dyncode [parent: %p] [child: %p]\n", dyncode_parent, dyncode_child);
+  NaClLog(1, "stack [parent: %p] [child: %p]\n", stackaddr_parent, stackaddr_child);
+  NaClLog(1, "cage_id [nap_parent: %d] [nap_child: %d]\n", nap_parent->cage_id, nap_child->cage_id);
+  NaClPrintAddressSpaceLayout(nap_parent);
+  NaClPrintAddressSpaceLayout(nap_child);
+
+  /* copy page mappings */
+  if (NaClMprotect(dyncode_parent, dyncode_size, PROT_RW) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "parent dynamic text NaClMprotect failed!");
+  }
+  if (NaClMprotect(dyncode_child, dyncode_size, PROT_RW) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "child dynamic text NaClMprotect failed!");
+  }
+  if (NaClMprotect(stackaddr_parent, stack_size, PROT_RW) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "parent stack address NaClMprotect failed!");
+  }
+  if (NaClMprotect(stackaddr_child, stack_size, PROT_RW) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "child stack address NaClMprotect failed!");
+  }
+  NaClVmmapAddWithOverwrite(&nap_child->mem_map,
+                            stack_pnum_child, stack_npages,
+                            PROT_RW, F_ANON_PRIV, NULL, 0, 0);
+  NaClVmmapAddWithOverwrite(&nap_child->mem_map,
+                            dyncode_pnum_child, dyncode_npages,
+                            PROT_RW, F_ANON_PRIV, NULL, 0, 0);
+
+  /* copy stack and dynamic text mappings */
+  nap_child->break_addr = nap_parent->break_addr;
+  memcpy(dyncode_child, dyncode_parent, dyncode_size);
+  NaClPatchAddr(nap_child->mem_start, nap_parent->mem_start, dyncode_child, dyncode_size / sizeof(uintptr_t));
+  NaClLog(1, "Copying parent stack (%zu [%#lx] bytes) from (%p) to (%p)\n",
+          stack_size,
+          stack_size,
+          stackaddr_parent,
+          stackaddr_child);
+  memcpy(stackaddr_child, stackaddr_parent, stack_size);
+  NaClPatchAddr(nap_child->mem_start, nap_parent->mem_start, stackaddr_child, stack_size / sizeof(uintptr_t));
+  NaClDyncodeVisit(nap_child, NaClCopyDynamicRegion, nap_parent);
+  NaClVmmapVisit(&nap_parent->mem_map, NaClVmCopyEntry, nap_child);
+  NaClVmmapChangeProt(&nap_child->mem_map, dyncode_pnum_child, dyncode_npages, PROT_RX);
+  if (NaClMprotect(dyncode_parent, dyncode_size, PROT_RX) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "parent dynamic text NaClMprotect failed!");
+  }
+  if (NaClMprotect(dyncode_child, dyncode_size, PROT_RX) == -1) {
+      NaClLog(LOG_FATAL, "%s\n", "child dynamic text NaClMprotect failed!");
+  }
+
+  NaClLog(1, "copied page tables from (%p) to (%p)\n", (void *)nap_parent, (void *)nap_child);
+  NaClLog(1, "%s\n", "nap_parent_parent address space after copy:");
+  NaClPrintAddressSpaceLayout(nap_parent);
+  NaClLog(1, "%s\n", "nap_child address space after copy:");
+  NaClPrintAddressSpaceLayout(nap_child);
+}
+
+/* set up the fd table for each cage */
+void InitializeCage(struct NaClApp *nap, int cage_id) {
+  fd_cage_table[cage_id][0] = 0;
+  fd_cage_table[cage_id][1] = 1;
+  fd_cage_table[cage_id][2] = 2;
+  /* set to the next unused (available for dup() etc.) file descriptor */
+  nap->fd = 3;
+  nap->num_lib = 3;
+  nap->num_children = 0;
+  nap->cage_id = cage_id;
+}
+
diff --git a/src/trusted/service_runtime/sel_ldr.h b/src/trusted/service_runtime/sel_ldr.h
index c91246c3bed1e5a40d..db3d2a45c7df86693d 100644
--- a/src/trusted/service_runtime/sel_ldr.h
+++ b/src/trusted/service_runtime/sel_ldr.h
@@ -26,17 +26,21 @@
  */
 
 #ifndef NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_SEL_LDR_H_
 #define NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_SEL_LDR_H_ 1
 
+#include <signal.h>
+#include <stdbool.h>
+
 #include "native_client/src/include/atomic_ops.h"
 #include "native_client/src/include/nacl_base.h"
 #include "native_client/src/include/portability.h"
 #include "native_client/src/include/elf.h"
 
 #include "native_client/src/shared/platform/nacl_host_desc.h"
 #include "native_client/src/shared/platform/nacl_log.h"
+#include "native_client/src/shared/platform/nacl_sync_checked.h"
 #include "native_client/src/shared/platform/nacl_threads.h"
 
 #include "native_client/src/shared/srpc/nacl_srpc.h"
 
 #include "native_client/src/trusted/interval_multiset/nacl_interval_multiset.h"
@@ -55,17 +59,18 @@
 #include "native_client/src/trusted/service_runtime/sel_rt.h"
 
 #include "native_client/src/trusted/service_runtime/name_service/name_service.h"
 
 #include "native_client/src/trusted/validator/ncvalidate.h"
+#include "native_client/src/trusted/service_runtime/nacl_globals.h"
 
 EXTERN_C_BEGIN
 
 #define NACL_SERVICE_PORT_DESCRIPTOR    3
 #define NACL_SERVICE_ADDRESS_DESCRIPTOR 4
 
-#define NACL_DEFAULT_STACK_MAX  (16 << 20)  /* main thread stack */
+#define NACL_DEFAULT_STACK_MAX  (16u << 20)  /* main thread stack */
 
 struct NaClAppThread;
 struct NaClDesc;  /* see native_client/src/trusted/desc/nacl_desc_base.h */
 struct NaClDynamicRegion;
 struct NaClManifestProxy;
@@ -73,10 +78,22 @@ struct NaClReverseQuotaInterface;
 struct NaClSignalContext;
 struct NaClThreadInterface;  /* see sel_ldr_thread_interface.h */
 struct NaClValidationCache;
 struct NaClValidationMetadata;
 
+struct Pipe {
+  bool xfer_done;
+  unsigned char pipe_buf[PIPE_BUF_MAX];
+  struct NaClMutex mu;
+  struct NaClCondVar cv;
+};
+
+extern volatile sig_atomic_t fork_num;
+extern struct Pipe pipe_table[PIPE_NUM_MAX];
+extern int fd_cage_table[CAGING_FD_NUM][CAGING_FD_NUM];
+extern int cached_lib_num;
+
 struct NaClDebugCallbacks {
   void (*thread_create_hook)(struct NaClAppThread *natp);
   void (*thread_exit_hook)(struct NaClAppThread *natp);
   void (*process_exit_hook)(void);
 };
@@ -105,10 +122,40 @@ struct NaClSpringboardInfo {
   uint32_t start_addr;
   uint32_t end_addr;
 };
 
 struct NaClApp {
+  /*
+   * children table lock children_mu is higher in the locking order than
+   * the thread locks, i.e., children_mu must be acqured w/o holding
+   * any thread table or per-thread lock (threads_mu or natp->mu).
+   *
+   * -jp
+   */
+  struct NaClMutex          children_mu;
+  struct NaClCondVar        children_cv;
+  struct DynArray           children;
+  // yiwen: store the <file_path, fd, mem_addr> for each cage, fd is used as the index
+  struct CachedLibTable     lib_table[CACHED_LIB_NUM_MAX];
+  /* mappings of `int fd` numbers to `NaClDesc *` */
+  struct NaClDesc           *fd_maps[FILE_DESC_MAX];
+  volatile sig_atomic_t     children_ids[CHILD_NUM_MAX];
+  volatile sig_atomic_t     num_children;
+  volatile sig_atomic_t     cage_id;
+  volatile sig_atomic_t     num_lib;
+  volatile sig_atomic_t     parent_id;
+  struct NaClApp            *parent;
+  struct NaClApp            *master;
+
+  // yiwen: store the path of the execuable running inside this cage(as the main thread)
+  int                       command_num;
+  char                      *binary_path;
+  char                      *binary_command;
+  char                      *nacl_file;
+  /* set to the next unused (available for dup() etc.) file descriptor */
+  int                       fd;
+
   /*
    * public, user settable prior to app start.
    */
   uint8_t                   addr_bits;
   uintptr_t                 stack_size;
@@ -547,11 +594,11 @@ int NaClAddrIsValidEntryPt(struct NaClApp *nap,
 /*
  * Takes ownership of descriptor, i.e., when NaCl app closes, it's gone.
  */
 void NaClAddHostDescriptor(struct NaClApp *nap,
                            int            host_os_desc,
-                           int            mode,
+                           int            flag,
                            int            nacl_desc);
 
 /*
  * Takes ownership of handle.
  */
@@ -598,10 +645,17 @@ uintptr_t NaClGetInitialStackTop(struct NaClApp *nap);
 int NaClCreateMainThread(struct NaClApp     *nap,
                          int                argc,
                          char               **argv,
                          char const *const  *envp) NACL_WUR;
 
+int NaClCreateMainForkThread(struct NaClApp           *nap_parent,
+                             struct NaClAppThread     *natp_parent,
+                             struct NaClApp           *nap_child,
+                             int                      argc,
+                             char                     **argv,
+                             char const *const        *envv) NACL_WUR;
+
 int NaClWaitForMainThreadToExit(struct NaClApp  *nap);
 
 /*
  * Used by syscall code.
  */
@@ -854,8 +908,130 @@ static INLINE void NaClHandleBootstrapArgs(int *argc_p, char ***argv_p) {
   UNREFERENCED_PARAMETER(argc_p);
   UNREFERENCED_PARAMETER(argv_p);
 }
 #endif
 
+/*
+ * Passed to NaClVmmapVisit in order to copy a memory region from
+ * an NaClApp to a child process (used when forking).
+ *
+ * preconditions:
+ * * target_state must be a pointer to a valid, initialized NaClApp
+ */
+void NaClVmCopyMemoryRegion(void *target_state, struct NaClVmmapEntry *entry);
+
+/*
+ * Copy the entire address space of an NaClApp to a child
+ * process.
+ *
+ * preconditions:
+ * * `child` must be a pointer to a valid, initialized NaClApp
+ * * Caller must hold both the nap->mu and the child->mu mutexes
+ */
+void NaClVmCopyAddressSpace(struct NaClApp *nap, struct NaClApp *child);
+
+/*
+ * Copy the entire address execution context of an NaClApp to a child
+ * process.
+ *
+ * preconditions:
+ * * `child` must be a pointer to a valid, initialized NaClApp
+ * * Caller must hold both the nap->mu and the child->mu mutexes
+ */
+void NaClCopyExecutionContext(struct NaClApp *nap_parent, struct NaClApp *nap_child);
+
+/* Set up the fd table for each cage */
+void InitializeCage(struct NaClApp *nap, int cage_id);
+
+static INLINE void NaClLogUserMemoryContent(struct NaClApp *nap, uintptr_t user_addr) {
+  char *addr = (char *)NaClUserToSys(nap, user_addr);
+  NaClLog(1, "[Memory] Memory addr:                   %p\n", (void *)addr);
+  NaClLog(1, "[Memory] Memory content (byte-swapped): %#08lx\n", OBJ_REP_64(addr));
+  NaClLog(1, "[Memory] Memory content (string):       %s\n", addr);
+  NaClLog(1, "[Memory] Memory content (raw):          %#08lx\n", *(uint64_t *)addr);
+}
+
+static INLINE void NaClLogSysMemoryContent(uintptr_t sys_addr) {
+  char *addr = (char *)sys_addr;
+  UNREFERENCED_PARAMETER(addr);
+  NaClLog(1, "[Memory] Memory addr:                   %p\n", (void *)addr);
+  NaClLog(1, "[Memory] Memory content (raw):          %#08lx\n", *(uint64_t *)addr);
+  NaClLog(1, "[Memory] Memory content (byte-swapped): %#08lx\n", OBJ_REP_64(addr));
+  NaClLog(1, "[Memory] Memory content (string):       %s\n", addr);
+}
+
+static INLINE void NaClLogThreadContext(struct NaClAppThread *natp) {
+  struct NaClThreadContext *ctx = &natp->user;
+  UNREFERENCED_PARAMETER(ctx);
+  NaClLog(1, "[Thread Context] cage id           = %i \n", natp->nap->cage_id);
+  NaClLog(1, "[Thread Context] sysret            = %p \n", (void *)ctx->sysret);
+  NaClLog(1, "[Thread Context] prog_ctr (%%rip)  = %p \n", (void *)ctx->prog_ctr);
+  NaClLog(1, "[Thread Context] new_prog_ctr      = %p \n", (void *)ctx->new_prog_ctr);
+  NaClLog(1, "[Thread Context] trusted_stack_ptr = %p \n", (void *)ctx->trusted_stack_ptr);
+  NaClLog(1, "[Thread Context] registers:\n"
+          "\t%%tls_idx (%#x), %%tls_value1 (%#x), %%tls_value2 (%#x),\n"
+          "\t%%rax (%#lx), %%rbx (%#lx), %%rcx (%#lx), %%rdx (%#lx),\n"
+          "\t%%rbp (%#lx), %%rsi (%#lx), %%rdi (%#lx), %%rsp (%#lx),\n"
+          "\t%%r8 (%#lx), %%r9 (%#lx), %%r10 (%#lx), %%r11 (%#lx),\n"
+          "\t%%r12 (%#lx), %%r13 (%#lx), %%r14 (%#lx), %%r15 (%#lx),\n"
+          "\t%%fcw (%#hx), %%sys_fcw (%#hx), %%mxcsr (%#x), %%sys_mxcsr (%#x),\n",
+          ctx->tls_idx, ctx->tls_value1, ctx->tls_value2,
+          ctx->rax, ctx->rbx, ctx->rcx, ctx->rdx,
+          ctx->rbp, ctx->rsi, ctx->rdi, ctx->rsp,
+          ctx->r8, ctx->r9, ctx->r10, ctx->r11,
+          ctx->r12, ctx->r13, ctx->r14, ctx->r15,
+          ctx->fcw, ctx->sys_fcw, ctx->mxcsr, ctx->sys_mxcsr);
+}
+
+/* print out memory layout of a nap */
+static INLINE void NaClPrintAddressSpaceLayout(struct NaClApp *nap) {
+  NaClLog(1, "%s\n", "NaClApp addr space layout:");
+  NaClLog(1, "NaClApp cage id: %d \n", nap->cage_id);
+  NaClLog(1, "nap->mem_start          = 0x%016"NACL_PRIxPTR"\n",
+          nap->mem_start);
+  NaClLog(1, "nap->static_text_end    = 0x%016"NACL_PRIxPTR"\n",
+          nap->static_text_end);
+  NaClLog(1, "nap->dynamic_text_start = 0x%016"NACL_PRIxPTR"\n",
+          nap->dynamic_text_start);
+  NaClLog(1, "nap->dynamic_text_end   = 0x%016"NACL_PRIxPTR"\n",
+          nap->dynamic_text_end);
+  NaClLog(1, "nap->rodata_start       = 0x%016"NACL_PRIxPTR"\n",
+          nap->rodata_start);
+  NaClLog(1, "nap->data_start         = 0x%016"NACL_PRIxPTR"\n",
+          nap->data_start);
+  NaClLog(1, "nap->data_end           = 0x%016"NACL_PRIxPTR"\n",
+          nap->data_end);
+  NaClLog(1, "nap->break_addr         = 0x%016"NACL_PRIxPTR"\n",
+          nap->break_addr);
+  NaClLog(1, "nap->initial_entry_pt   = 0x%016"NACL_PRIxPTR"\n",
+          nap->initial_entry_pt);
+  NaClLog(1, "nap->user_entry_pt      = 0x%016"NACL_PRIxPTR"\n",
+          nap->user_entry_pt);
+  NaClLog(1, "nap->bundle_size        = 0x%x\n", nap->bundle_size);
+}
+
+static INLINE void NaClLogAddressSpaceLayout(struct NaClApp *nap) {
+  NaClLog(2, "NaClApp addr space layout:\n");
+  NaClLog(2, "nap->static_text_end    = 0x%016"NACL_PRIxPTR"\n",
+          nap->static_text_end);
+  NaClLog(2, "nap->dynamic_text_start = 0x%016"NACL_PRIxPTR"\n",
+          nap->dynamic_text_start);
+  NaClLog(2, "nap->dynamic_text_end   = 0x%016"NACL_PRIxPTR"\n",
+          nap->dynamic_text_end);
+  NaClLog(2, "nap->rodata_start       = 0x%016"NACL_PRIxPTR"\n",
+          nap->rodata_start);
+  NaClLog(2, "nap->data_start         = 0x%016"NACL_PRIxPTR"\n",
+          nap->data_start);
+  NaClLog(2, "nap->data_end           = 0x%016"NACL_PRIxPTR"\n",
+          nap->data_end);
+  NaClLog(2, "nap->break_addr         = 0x%016"NACL_PRIxPTR"\n",
+          nap->break_addr);
+  NaClLog(2, "nap->initial_entry_pt   = 0x%016"NACL_PRIxPTR"\n",
+          nap->initial_entry_pt);
+  NaClLog(2, "nap->user_entry_pt      = 0x%016"NACL_PRIxPTR"\n",
+          nap->user_entry_pt);
+  NaClLog(2, "nap->bundle_size        = 0x%x\n", nap->bundle_size);
+}
+
 EXTERN_C_END
 
 #endif  /* NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_SEL_LDR_H_ */
diff --git a/src/trusted/service_runtime/sel_ldr_standard.c b/src/trusted/service_runtime/sel_ldr_standard.c
index 3e0aca13c3e4100e68..7f00e01c8ecf46bca3 100644
--- a/src/trusted/service_runtime/sel_ldr_standard.c
+++ b/src/trusted/service_runtime/sel_ldr_standard.c
@@ -20,10 +20,11 @@
 #include "native_client/src/include/win/mman.h"
 #include "native_client/src/shared/platform/nacl_check.h"
 #include "native_client/src/shared/platform/nacl_log.h"
 #include "native_client/src/shared/platform/nacl_sync_checked.h"
 #include "native_client/src/shared/platform/nacl_time.h"
+#include "native_client/src/shared/platform/lind_platform.h"
 
 #include "native_client/src/shared/srpc/nacl_srpc.h"
 
 #include "native_client/src/trusted/manifest_name_service_proxy/manifest_proxy.h"
 #include "native_client/src/trusted/perf_counter/nacl_perf_counter.h"
@@ -39,21 +40,16 @@
 #include "native_client/src/trusted/service_runtime/nacl_kernel_service.h"
 #include "native_client/src/trusted/service_runtime/nacl_signal.h"
 #include "native_client/src/trusted/service_runtime/nacl_switch_to_app.h"
 #include "native_client/src/trusted/service_runtime/nacl_syscall_common.h"
 #include "native_client/src/trusted/service_runtime/nacl_text.h"
-#include "native_client/src/trusted/service_runtime/sel_memory.h"
 #include "native_client/src/trusted/service_runtime/sel_ldr.h"
 #include "native_client/src/trusted/service_runtime/sel_ldr_thread_interface.h"
+#include "native_client/src/trusted/service_runtime/sel_memory.h"
 #include "native_client/src/trusted/service_runtime/sel_util.h"
 #include "native_client/src/trusted/service_runtime/sel_addrspace.h"
 
-#if !defined(SIZE_T_MAX)
-# define SIZE_T_MAX     (~(size_t) 0)
-#endif
-
-
 /*
  * Fill from static_text_end to end of that page with halt
  * instruction, which is at least NACL_HALT_LEN in size when no
  * dynamic text is present.  Does not touch dynamic text region, which
  * should be pre-filled with HLTs.
@@ -164,34 +160,10 @@ NaClErrorCode NaClCheckAddressSpaceLayoutSanity(struct NaClApp *nap,
     return LOAD_BAD_RODATA_ALIGNMENT;
   }
   return LOAD_OK;
 }
 
-void NaClLogAddressSpaceLayout(struct NaClApp *nap) {
-  NaClLog(2, "NaClApp addr space layout:\n");
-  NaClLog(2, "nap->static_text_end    = 0x%016"NACL_PRIxPTR"\n",
-          nap->static_text_end);
-  NaClLog(2, "nap->dynamic_text_start = 0x%016"NACL_PRIxPTR"\n",
-          nap->dynamic_text_start);
-  NaClLog(2, "nap->dynamic_text_end   = 0x%016"NACL_PRIxPTR"\n",
-          nap->dynamic_text_end);
-  NaClLog(2, "nap->rodata_start       = 0x%016"NACL_PRIxPTR"\n",
-          nap->rodata_start);
-  NaClLog(2, "nap->data_start         = 0x%016"NACL_PRIxPTR"\n",
-          nap->data_start);
-  NaClLog(2, "nap->data_end           = 0x%016"NACL_PRIxPTR"\n",
-          nap->data_end);
-  NaClLog(2, "nap->break_addr         = 0x%016"NACL_PRIxPTR"\n",
-          nap->break_addr);
-  NaClLog(2, "nap->initial_entry_pt   = 0x%016"NACL_PRIxPTR"\n",
-          nap->initial_entry_pt);
-  NaClLog(2, "nap->user_entry_pt      = 0x%016"NACL_PRIxPTR"\n",
-          nap->user_entry_pt);
-  NaClLog(2, "nap->bundle_size        = 0x%x\n", nap->bundle_size);
-}
-
-
 NaClErrorCode NaClAppLoadFileAslr(struct NaClDesc *ndp,
                                   struct NaClApp *nap,
                                   enum NaClAslrMode aslr_mode) {
   NaClErrorCode       ret = LOAD_INTERNAL;
   NaClErrorCode       subret = LOAD_INTERNAL;
@@ -299,10 +271,11 @@ NaClErrorCode NaClAppLoadFileAslr(struct NaClDesc *ndp,
     goto done;
   }
 
   subret = NaClCheckAddressSpaceLayoutSanity(nap, rodata_end, data_end,
                                              max_vaddr);
+
   if (LOAD_OK != subret) {
     ret = subret;
     goto done;
   }
 
@@ -359,11 +332,10 @@ NaClErrorCode NaClAppLoadFileAslr(struct NaClDesc *ndp,
   NaClPerfCounterIntervalLast(&time_load_file);
   if (LOAD_OK != subret) {
     ret = subret;
     goto done;
   }
-
   /*
    * NaClFillEndOfTextRegion will fill with halt instructions the
    * padding space after the static text region.
    *
    * Shm-backed dynamic text space was filled with halt instructions
@@ -387,20 +359,18 @@ NaClErrorCode NaClAppLoadFileAslr(struct NaClDesc *ndp,
   NaClPerfCounterIntervalLast(&time_load_file);
   if (LOAD_OK != subret) {
     ret = subret;
     goto done;
   }
-
   NaClLog(2, "Initializing arch switcher\n");
   NaClInitSwitchToApp(nap);
 
   NaClLog(2, "Installing trampoline\n");
   NaClLoadTrampoline(nap);
 
   NaClLog(2, "Installing springboard\n");
   NaClLoadSpringboard(nap);
-
   /*
    * NaClMemoryProtection also initializes the mem_map w/ information
    * about the memory pages and their current protection value.
    *
    * The contents of the dynamic text region will get remapped as
@@ -416,25 +386,23 @@ NaClErrorCode NaClAppLoadFileAslr(struct NaClDesc *ndp,
   NaClLog(2, "NaClAppLoadFile done; ");
   NaClLogAddressSpaceLayout(nap);
   ret = LOAD_OK;
 done:
   NaClElfImageDelete(image);
-
   NaClPerfCounterMark(&time_load_file, "EndLoadFile");
   NaClPerfCounterIntervalTotal(&time_load_file);
   return ret;
 }
 
 NaClErrorCode NaClAppLoadFile(struct NaClDesc *ndp,
                               struct NaClApp *nap) {
   return NaClAppLoadFileAslr(ndp, nap, NACL_ENABLE_ASLR);
 }
 
-NaClErrorCode NaClAppLoadFileDynamically(
-    struct NaClApp *nap,
-    struct NaClDesc *ndp,
-    struct NaClValidationMetadata *metadata) {
+NaClErrorCode NaClAppLoadFileDynamically(struct NaClApp *nap,
+                                         struct NaClDesc *ndp,
+                                         struct NaClValidationMetadata *metadata) {
   struct NaClElfImage *image = NULL;
   NaClErrorCode ret = LOAD_INTERNAL;
 
   image = NaClElfImageNew(ndp, &ret);
   if (NULL == image || LOAD_OK != ret) {
@@ -721,33 +689,35 @@ int NaClCreateMainThread(struct NaClApp     *nap,
   char                  *strp;
   size_t                *argv_len;
   size_t                *envv_len;
   uintptr_t             stack_ptr;
 
-  retval = 0;  /* fail */
   CHECK(argc >= 0);
-  CHECK(NULL != argv || 0 == argc);
+  CHECK(argv || !argc);
 
+  retval = 0;
+  size = 0;
   envc = 0;
-  if (NULL != envv) {
+  /* count number of environment strings */
+  if (envv) {
     char const *const *pp;
     for (pp = envv; NULL != *pp; ++pp) {
       ++envc;
     }
   }
-  envv_len = 0;
-  argv_len = malloc(argc * sizeof argv_len[0]);
-  envv_len = malloc(envc * sizeof envv_len[0]);
-  if (NULL == argv_len) {
+  /* allocate space to hold length of vectors */
+  argv_len = !argc ? NULL : malloc(argc * sizeof *argv_len);
+  envv_len = !envc ? NULL : malloc(envc * sizeof *envv_len);
+  /* `argvv_len = malloc()` failed or `argc == 0` */
+  if (!argv_len) {
     goto cleanup;
   }
-  if (NULL == envv_len && 0 != envc) {
+  /* `envv_len = malloc()` failed (`envc == 0` is not an error) */
+  if (!envv_len && envc) {
     goto cleanup;
   }
 
-  size = 0;
-
   /*
    * The following two loops cannot overflow.  The reason for this is
    * that they are counting the number of bytes used to hold the
    * NUL-terminated strings that comprise the argv and envv tables.
    * If the entire address space consisted of just those strings, then
@@ -755,11 +725,11 @@ int NaClCreateMainThread(struct NaClApp     *nap,
    * space required to hold the code below (and we are not targetting
    * Harvard architecture machines), at least one page holds code, not
    * data.  We are assuming that the caller is non-adversarial and the
    * code does not look like string data....
    */
-  for (i = 0; i < argc; ++i) {
+  for (i = 0; i < argc && argv; ++i) {
     argv_len[i] = strlen(argv[i]) + 1;
     size += argv_len[i];
   }
   for (i = 0; i < envc; ++i) {
     envv_len[i] = strlen(envv[i]) + 1;
@@ -821,41 +791,41 @@ int NaClCreateMainThread(struct NaClApp     *nap,
   NaClLog(2, "setting stack to : %016"NACL_PRIxPTR"\n", stack_ptr);
 
   VCHECK(0 == (stack_ptr & NACL_STACK_ALIGN_MASK),
          ("stack_ptr not aligned: %016"NACL_PRIxPTR"\n", stack_ptr));
 
-  p = (uint32_t *) stack_ptr;
-  strp = (char *) stack_ptr + ptr_tbl_size;
+  p = (uint32_t *)stack_ptr;
+  strp = (char *)stack_ptr + ptr_tbl_size;
 
   /*
    * For x86-32, we push an initial argument that is the address of
    * the main argument block.  For other machines, this is passed
    * in a register and that's set in NaClStartThreadInApp.
    */
   if (NACL_STACK_GETS_ARG) {
     uint32_t *argloc = p++;
-    *argloc = (uint32_t) NaClSysToUser(nap, (uintptr_t) p);
+    *argloc = (uint32_t)NaClSysToUser(nap, (uintptr_t) p);
   }
 
   *p++ = 0;  /* Cleanup function pointer, always NULL.  */
   *p++ = envc;
   *p++ = argc;
 
-  for (i = 0; i < argc; ++i) {
-    *p++ = (uint32_t) NaClSysToUser(nap, (uintptr_t) strp);
+  for (i = 0; i < argc && argv; ++i) {
+    *p++ = (uint32_t) NaClSysToUser(nap, (uintptr_t)strp);
     NaClLog(2, "copying arg %d  %p -> %p\n",
-            i, argv[i], strp);
-    strcpy(strp, argv[i]);
+            i, (void *)argv[i], (void *)strp);
+    snprintf(strp, ARG_LIMIT, "%s", argv[i]);
     strp += argv_len[i];
   }
   *p++ = 0;  /* argv[argc] is NULL.  */
 
   for (i = 0; i < envc; ++i) {
     *p++ = (uint32_t) NaClSysToUser(nap, (uintptr_t) strp);
     NaClLog(2, "copying env %d  %p -> %p\n",
-            i, envv[i], strp);
-    strcpy(strp, envv[i]);
+            i, (void *)envv[i], (void *)strp);
+    snprintf(strp, ARG_LIMIT, "%s", envv[i]);
     strp += envv_len[i];
   }
   *p++ = 0;  /* envp[envc] is NULL.  */
 
   /* Push an auxv */
@@ -902,10 +872,219 @@ cleanup:
   free(envv_len);
 
   return retval;
 }
 
+int NaClCreateMainForkThread(struct NaClApp           *nap_parent,
+                             struct NaClAppThread     *natp_parent,
+                             struct NaClApp           *nap_child,
+                             int                      argc,
+                             char                     **argv,
+                             char const *const        *envv) {
+  /*
+   * Compute size of string tables for argv and envv
+   */
+  int                   retval;
+  int                   envc;
+  size_t                size;
+  int                   auxv_entries;
+  size_t                ptr_tbl_size;
+  int                   i;
+  uint32_t              *p;
+  char                  *strp;
+  size_t                *argv_len;
+  size_t                *envv_len;
+  uintptr_t             stack_ptr;
+
+  CHECK(argc >= 0);
+  CHECK(argv || !argc);
+
+  retval = 0;
+  size = 0;
+  envc = 0;
+  /* count number of environment strings */
+  if (envv) {
+    char const *const *pp;
+    for (pp = envv; NULL != *pp; ++pp) {
+      ++envc;
+    }
+  }
+  /* allocate space to hold length of vectors */
+  argv_len = !argc ? NULL : malloc(argc * sizeof *argv_len);
+  envv_len = !envc ? NULL : malloc(envc * sizeof *envv_len);
+  /* `argvv_len = malloc()` failed or `argc == 0` */
+  if (!argv_len) {
+    goto cleanup;
+  }
+  /* `envv_len = malloc()` failed (`envc == 0` is not an error) */
+  if (!envv_len && envc) {
+    goto cleanup;
+  }
+
+  /*
+   * The following two loops cannot overflow.  The reason for this is
+   * that they are counting the number of bytes used to hold the
+   * NUL-terminated strings that comprise the argv and envv tables.
+   * If the entire address space consisted of just those strings, then
+   * the size variable would overflow; however, since there's the code
+   * space required to hold the code below (and we are not targetting
+   * Harvard architecture machines), at least one page holds code, not
+   * data.  We are assuming that the caller is non-adversarial and the
+   * code does not look like string data....
+   */
+  for (i = 0; i < argc && argv; ++i) {
+    argv_len[i] = strlen(argv[i]) + 1;
+    size += argv_len[i];
+  }
+  for (i = 0; i < envc; ++i) {
+    envv_len[i] = strlen(envv[i]) + 1;
+    size += envv_len[i];
+  }
+
+
+  /*
+   * NaCl modules are ILP32, so the argv, envv pointers, as well as
+   * the terminating NULL pointers at the end of the argv/envv tables,
+   * are 32-bit values.  We also have the auxv to take into account.
+   *
+   * The argv and envv pointer tables came from trusted code and is
+   * part of memory.  Thus, by the same argument above, adding in
+   * "ptr_tbl_size" cannot possibly overflow the "size" variable since
+   * it is a size_t object.  However, the extra pointers for auxv and
+   * the space for argv could cause an overflow.  The fact that we
+   * used stack to get here etc means that ptr_tbl_size could not have
+   * overflowed.
+   *
+   * NB: the underlying OS would have limited the amount of space used
+   * for argv and envv -- on linux, it is ARG_MAX, or 128KB -- and
+   * hence the overflow check is for obvious auditability rather than
+   * for correctness.
+   */
+  auxv_entries = 1;
+  if (0 != nap_child->user_entry_pt) {
+    auxv_entries++;
+  }
+  ptr_tbl_size = (((NACL_STACK_GETS_ARG ? 1 : 0) +
+                   (3 + argc + 1 + envc + 1 + auxv_entries * 2)) *
+                  sizeof(uint32_t));
+
+  if (SIZE_T_MAX - size < ptr_tbl_size) {
+    NaClLog(LOG_WARNING,
+            "NaClCreateMainThread: ptr_tbl_size cause size of"
+            " argv / environment copy to overflow!?!\n");
+    retval = 0;
+    goto cleanup;
+  }
+  size += ptr_tbl_size;
+
+  size = (size + NACL_STACK_ALIGN_MASK) & ~NACL_STACK_ALIGN_MASK;
+
+  if (size > nap_child->stack_size) {
+    retval = 0;
+    goto cleanup;
+  }
+
+  /*
+   * Write strings and char * arrays to stack.
+   */
+  stack_ptr = NaClUserToSysAddrRange(nap_child,
+                                     NaClGetInitialStackTop(nap_child) - size,
+                                     size);
+  if (stack_ptr == kNaClBadAddress) {
+    retval = 0;
+    goto cleanup;
+  }
+
+  NaClLog(2, "setting stack to : %016"NACL_PRIxPTR"\n", stack_ptr);
+
+  VCHECK(!(stack_ptr & NACL_STACK_ALIGN_MASK),
+         ("stack_ptr not aligned: %016"NACL_PRIxPTR"\n", stack_ptr));
+
+  p = (uint32_t *)stack_ptr;
+  strp = (char *)stack_ptr + ptr_tbl_size;
+
+  /*
+   * For x86-32, we push an initial argument that is the address of
+   * the main argument block.  For other machines, this is passed
+   * in a register and that's set in NaClStartThreadInApp.
+   */
+  if (NACL_STACK_GETS_ARG) {
+    uint32_t *argloc = p++;
+    *argloc = (uint32_t) NaClSysToUser(nap_child, (uintptr_t) p);
+  }
+
+  *p++ = 0;  /* Cleanup function pointer, always NULL.  */
+  *p++ = envc;
+  *p++ = argc;
+
+  for (i = 0; i < argc && argv; ++i) {
+    *p++ = (uint32_t)NaClSysToUser(nap_child, (uintptr_t)strp);
+    NaClLog(2, "copying arg %d  %p -> %p\n",
+            i, (void *)argv[i], (void *)strp);
+    snprintf(strp, ARG_LIMIT, "%s", argv[i]);
+    strp += argv_len[i];
+  }
+  *p++ = 0;  /* argv[argc] is NULL.  */
+
+  for (i = 0; i < envc; ++i) {
+    *p++ = (uint32_t)NaClSysToUser(nap_child, (uintptr_t)strp);
+    NaClLog(2, "copying env %d  %p -> %p\n",
+            i, (void *)envv[i], (void *)strp);
+    snprintf(strp, ARG_LIMIT, "%s", envv[i]);
+    strp += envv_len[i];
+  }
+  *p++ = 0;  /* envp[envc] is NULL.  */
+
+  /* Push an auxv */
+  if (nap_child->user_entry_pt) {
+    *p++ = AT_ENTRY;
+    *p++ = (uint32_t)nap_child->user_entry_pt;
+  }
+  *p++ = AT_NULL;
+  *p++ = 0;
+
+  CHECK((char *)p == (char *)stack_ptr + ptr_tbl_size);
+
+  /* now actually spawn the thread */
+  NaClXMutexLock(&nap_child->mu);
+  nap_child->running = 1;
+  NaClXMutexUnlock(&nap_child->mu);
+
+  NaClVmHoleWaitToStartThread(nap_child);
+
+  /*
+   * For x86, we adjust the stack pointer down to push a dummy return
+   * address.  This happens after the stack pointer alignment.
+   * We avoid the otherwise harmless call for the zero case because
+   * _FORTIFY_SOURCE memset can warn about zero-length calls.
+   */
+  if (NACL_STACK_PAD_BELOW_ALIGN) {
+    stack_ptr -= NACL_STACK_PAD_BELOW_ALIGN;
+    memset((void *)stack_ptr, 0, NACL_STACK_PAD_BELOW_ALIGN);
+  }
+
+  NaClLog(1, "   system stack ptr : %016"NACL_PRIxPTR"\n", stack_ptr);
+  NaClLog(1, "     user stack ptr : %016"NACL_PRIxPTR"\n", NaClSysToUserStackAddr(nap_child, stack_ptr));
+  NaClLog(1, "   initial entry pt : %016"NACL_PRIxPTR"\n", nap_child->initial_entry_pt);
+  NaClLog(1, "      user entry pt : %016"NACL_PRIxPTR"\n", nap_child->user_entry_pt);
+
+  /* e_entry is user addr */
+  retval = NaClAppForkThreadSpawn(nap_parent,
+                                  natp_parent,
+                                  nap_child,
+                                  nap_child->initial_entry_pt,
+                                  NaClSysToUserStackAddr(nap_child, stack_ptr),
+                                  (uint32_t)nap_child->break_addr,
+                                  0);
+
+cleanup:
+  free(argv_len);
+  free(envv_len);
+
+  return retval;
+}
+
 int NaClWaitForMainThreadToExit(struct NaClApp  *nap) {
   NaClLog(3, "NaClWaitForMainThreadToExit: taking NaClApp lock\n");
   NaClXMutexLock(&nap->mu);
   NaClLog(3, " waiting for exit status\n");
   while (nap->running) {
diff --git a/src/trusted/service_runtime/sel_main.c b/src/trusted/service_runtime/sel_main.c
index b6e95d98f5bec05cd1..64f7e39a1659b431d1 100644
--- a/src/trusted/service_runtime/sel_main.c
+++ b/src/trusted/service_runtime/sel_main.c
@@ -3,34 +3,42 @@
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file.
  */
 
 /*
- * NaCl Simple/secure ELF loader (NaCl SEL).
+ * NaCl Simple/secure ELF loader (NaCl SEL). The main entry point for the binary.
  */
 #include "native_client/src/include/portability.h"
 #include "native_client/src/include/portability_io.h"
 
 #if NACL_OSX
-#include <crt_externs.h>
+#  include <crt_externs.h>
 #endif
 
 #if NACL_LINUX
-#include <getopt.h>
+#  include <getopt.h>
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef _POSIX_C_SOURCE
+#  undef _POSIX_C_SOURCE
+#endif
+#ifdef _XOPEN_SOURCE
+#  undef _XOPEN_SOURCE
+#endif
+
 #include "native_client/src/shared/gio/gio.h"
 #include "native_client/src/shared/imc/nacl_imc_c.h"
 #include "native_client/src/shared/platform/nacl_check.h"
 #include "native_client/src/shared/platform/nacl_exit.h"
 #include "native_client/src/shared/platform/nacl_log.h"
 #include "native_client/src/shared/platform/nacl_sync.h"
 #include "native_client/src/shared/platform/nacl_sync_checked.h"
+#include "native_client/src/shared/platform/lind_platform.h"
 #include "native_client/src/shared/srpc/nacl_srpc.h"
 
 #include "native_client/src/trusted/desc/nacl_desc_base.h"
 #include "native_client/src/trusted/desc/nacl_desc_io.h"
 #include "native_client/src/trusted/fault_injection/fault_injection.h"
@@ -52,13 +60,18 @@
 #include "native_client/src/trusted/service_runtime/outer_sandbox.h"
 #include "native_client/src/trusted/service_runtime/sel_ldr.h"
 #include "native_client/src/trusted/service_runtime/sel_qualify.h"
 #include "native_client/src/trusted/service_runtime/win/exception_patch/ntdll_patch.h"
 #include "native_client/src/trusted/service_runtime/win/debug_exception_handler.h"
-#include "native_client/src/trusted/service_runtime/lind_syscalls.h"
 
 
+#include "native_client/src/trusted/service_runtime/sel_ldr.h"
+#include "native_client/src/trusted/service_runtime/include/bits/nacl_syscalls.h"
+#include <time.h>
+#include <sys/shm.h>
+#include <sys/mman.h>
+
 static void (*g_enable_outer_sandbox_func)(void) =
 #if NACL_OSX
     NaClEnableOuterSandbox;
 #else
     NULL;
@@ -66,43 +79,34 @@ static void (*g_enable_outer_sandbox_func)(void) =
 
 void NaClSetEnableOuterSandboxFunc(void (*func)(void)) {
   g_enable_outer_sandbox_func = func;
 }
 
-static void VmentryPrinter(void           *state,
-                    struct NaClVmmapEntry *vmep) {
+static void VmentryPrinter(void *state, struct NaClVmmapEntry *vmep) {
   UNREFERENCED_PARAMETER(state);
   printf("page num 0x%06x\n", (uint32_t)vmep->page_num);
   printf("num pages %d\n", (uint32_t)vmep->npages);
   printf("prot bits %x\n", vmep->prot);
-  fflush(stdout);
+  fflush(NULL);
 }
 
-static void PrintVmmap(struct NaClApp  *nap) {
-  printf("In PrintVmmap\n");
-  fflush(stdout);
+static void PrintVmmap(struct NaClApp *nap) {
+  puts("In PrintVmmap\n");
+  fflush(NULL);
   NaClXMutexLock(&nap->mu);
-  NaClVmmapVisit(&nap->mem_map, VmentryPrinter, (void *) 0);
-
+  NaClVmmapVisit(&nap->mem_map, VmentryPrinter, NULL);
   NaClXMutexUnlock(&nap->mu);
 }
 
-
 struct redir {
-  struct redir  *next;
-  int           nacl_desc;
-  enum {
-    HOST_DESC,
-    IMC_DESC
-  }             tag;
+  struct redir                  *next;
+  int                           nacl_desc;
+  enum { HOST_DESC, IMC_DESC }  tag;
   union {
-    struct {
-      int d;
-      int mode;
-    }                         host;
-    NaClHandle                handle;
-    struct NaClSocketAddress  addr;
+    struct { int d; int mode; } host;
+    NaClHandle                  handle;
+    struct NaClSocketAddress    addr;
   } u;
 };
 
 int ImportModeMap(char opt) {
   switch (opt) {
@@ -111,13 +115,11 @@ int ImportModeMap(char opt) {
     case 'r':
       return O_RDONLY;
     case 'w':
       return O_WRONLY;
   }
-  fprintf(stderr, ("option %c not understood as a host descriptor"
-                   " import mode\n"),
-          opt);
+  NaClLog(1, "option %c not understood as a host descriptor import mode\n", opt);
   exit(1);
   /* NOTREACHED */
 }
 
 static void PrintUsage(void) {
@@ -162,96 +164,122 @@ static void PrintUsage(void) {
           " -E <name=value>|<name> set an environment variable\n"
           " -Z use fixed feature x86 CPU mode\n"
           );  /* easier to add new flags/lines */
 }
 
-#if NACL_LINUX
 static const struct option longopts[] = {
   { "r_debug", required_argument, NULL, 'D' },
   { "reserved_at_zero", required_argument, NULL, 'z' },
   { NULL, 0, NULL, 0 }
 };
 
 static int my_getopt(int argc, char *const *argv, const char *shortopts) {
   return getopt_long(argc, argv, shortopts, longopts, NULL);
 }
+
+#if NACL_LINUX
+# define getopt my_getopt
+  static const char *const optstring = "+D:z:aB:ceE:f:Fgh:i:l:Qr:RsSvw:X:Z";
 #else
-#define my_getopt getopt
+# define NaClHandleRDebug(A, B) do { /* no-op */ } while (0)
+# define NaClHandleReservedAtZero(A) do { /* no-op */ } while (0)
+  static const char *const optstring = "aB:ceE:f:Fgh:i:l:Qr:RsSvw:X:Z";
 #endif
 
 int NaClSelLdrMain(int argc, char **argv) {
   int                           opt;
   char                          *rest;
   struct redir                  *entry;
   struct redir                  *redir_queue;
   struct redir                  **redir_qend;
 
-
-  struct NaClApp                state;
-  char                          *nacl_file = NULL;
-  char                          *blob_library_file = NULL;
+  struct NaClApp                state = {0};
+  struct NaClApp                *nap = &state;
+  struct NaClDesc               *blob_file = NULL;
+  struct GioFile                gout;
+  struct DynArray               env_vars;
+  struct NaClPerfCounter        time_all_main;
+  struct NaClEnvCleanser        env_cleanser;
+  NaClErrorCode                 errcode = LOAD_INTERNAL;
   int                           rpc_supplies_nexe = 0;
   int                           export_addr_to = -1;
-
-  struct NaClApp                *nap = &state;
-
-  struct GioFile                gout;
-  NaClErrorCode                 errcode = LOAD_INTERNAL;
-  struct NaClDesc               *blob_file = NULL;
-
   int                           ret_code;
-  struct DynArray               env_vars;
-
-  char                          *log_file = NULL;
   int                           verbosity = 0;
   int                           fuzzing_quit_after_load = 0;
   int                           debug_mode_bypass_acl_checks = 0;
   int                           debug_mode_ignore_validator = 0;
   int                           skip_qualification = 0;
   int                           handle_signals = 0;
   int                           enable_debug_stub = 0;
-  struct NaClPerfCounter        time_all_main;
+  char                          *blob_library_file = NULL;
+  char                          *log_file = NULL;
   const char                    **envp;
-  struct NaClEnvCleanser        env_cleanser;
+
+  // yiwen: define variables for doing evaluation measurement
+  clock_t                       nacl_main_begin;
+  clock_t                       nacl_main_finish;
+  clock_t                       nacl_initialization_finish;
+  double                        nacl_main_spent;
+  double                        nacl_initialization_spent;
+
+  clock_t                       nacl_user_program_begin;
+  clock_t                       nacl_user_program_finish;
+  double                        nacl_user_program_spent;
+  #ifdef SYSCALL_TIMING
+  double                        nacl_syscall_total_time;
+  double                        lind_syscall_total_time;
+  #endif
 
 #if NACL_OSX
   /* Mac dynamic libraries cannot access the environ variable directly. */
-  envp = (const char **) *_NSGetEnviron();
+  envp = (const char **)*_NSGetEnviron();
 #else
   /* Overzealous code style check is overzealous. */
   /* @IGNORE_LINES_FOR_CODE_HYGIENE[1] */
   extern char **environ;
-  envp = (const char **) environ;
+  envp = (const char **)environ;
 #endif
 
+  // yiwen: initialize the syscall_counter
+  nacl_syscall_counter = 0;
+  lind_syscall_counter = 0;
+  nacl_syscall_trace_level_counter = 0;
+
+  // yiwen: time measurement, record the start time of the NaCl main program
+  nacl_main_begin = clock();
+
   ret_code = 1;
   redir_queue = NULL;
   redir_qend = &redir_queue;
 
-  memset(&state, 0, sizeof state);
+  if (!DynArrayCtor(&nap->children, 16)) {
+    NaClLog(1, "%s\n", "Failed to initialize children list");
+  }
+
   NaClAllModulesInit();
   NaClBootstrapChannelErrorReporterInit();
   NaClErrorLogHookInit(NaClBootstrapChannelErrorReporter, &state);
 
   verbosity = NaClLogGetVerbosity();
 
   NaClPerfCounterCtor(&time_all_main, "SelMain");
 
-  fflush((FILE *) NULL);
+  fflush(NULL);
 
   NaClDebugExceptionHandlerStandaloneHandleArgs(argc, argv);
 
   if (!GioFileRefCtor(&gout, stdout)) {
-    fprintf(stderr, "Could not create general standard output channel\n");
+    NaClLog(1, "%s\n", "Could not create general standard output channel");
     exit(1);
   }
   if (!NaClAppCtor(&state)) {
-    NaClLog(LOG_FATAL, "NaClAppCtor() failed\n");
+    NaClLog(1, "%s\n", "NaClAppCtor() failed");
   }
   if (!DynArrayCtor(&env_vars, 0)) {
-    NaClLog(LOG_FATAL, "Failed to allocate env var array\n");
+    NaClLog(1, "%s\n", "Failed to allocate env var array");
   }
+
   /*
    * On platforms with glibc getopt, require POSIXLY_CORRECT behavior,
    * viz, no reordering of the arglist -- stop argument processing as
    * soon as an unrecognized argument is encountered, so that, for
    * example, in the invocation
@@ -260,31 +288,25 @@ int NaClSelLdrMain(int argc, char **argv) {
    *
    * the -vvv flags are made available to the nexe, rather than being
    * consumed by getopt.  This makes the behavior of the Linux build
    * of sel_ldr consistent with the Windows and OSX builds.
    */
-  while ((opt = my_getopt(argc, argv,
-#if NACL_LINUX
-                       "+D:z:"
-#endif
-                       "aB:ceE:f:Fgh:i:l:Qr:RsSvw:X:Z")) != -1) {
+  while ((opt = getopt(argc, argv, optstring)) != -1) {
     switch (opt) {
       case 'a':
-        fprintf(stderr, "DEBUG MODE ENABLED (bypass acl)\n");
+        NaClLog(1, "%s\n", "DEBUG MODE ENABLED (bypass acl)");
         debug_mode_bypass_acl_checks = 1;
         break;
       case 'B':
         blob_library_file = optarg;
         break;
       case 'c':
         ++debug_mode_ignore_validator;
         break;
-#if NACL_LINUX
       case 'D':
         NaClHandleRDebug(optarg, argv[0]);
         break;
-#endif
       case 'e':
         nap->enable_exception_handling = 1;
         break;
       case 'E':
         /*
@@ -299,134 +321,132 @@ int NaClSelLdrMain(int argc, char **argv) {
          * high-level language, in which case de-duplicating keys
          * outside of sel_ldr is easier.  However, we could do
          * de-duplication here if it proves to be worthwhile.
          */
         if (!DynArraySet(&env_vars, env_vars.num_entries, optarg)) {
-          NaClLog(LOG_FATAL, "Adding item to env_vars failed\n");
+          NaClLog(1, "%s\n", "Adding item to env_vars failed");
         }
         break;
       case 'f':
-        nacl_file = optarg;
+        nap->nacl_file = optarg;
         break;
       case 'F':
         fuzzing_quit_after_load = 1;
         break;
 
       case 'g':
         enable_debug_stub = 1;
         break;
 
-      case 'h':
-      case 'r':
+      case 'h': /* fallthrough */
+      case 'r': /* fallthrough */
       case 'w':
         /* import host descriptor */
         entry = malloc(sizeof *entry);
-        if (NULL == entry) {
-          fprintf(stderr, "No memory for redirection queue\n");
-          exit(1);
+        if (!entry) {
+          NaClLog(1, "%s\n", "No memory for redirection queue");
+          exit(EXIT_FAILURE);
         }
         entry->next = NULL;
         entry->nacl_desc = strtol(optarg, &rest, 0);
         entry->tag = HOST_DESC;
-        entry->u.host.d = strtol(rest+1, (char **) 0, 0);
+        entry->u.host.d = strtol(rest + 1, NULL, 0);
         entry->u.host.mode = ImportModeMap(opt);
         *redir_qend = entry;
         redir_qend = &entry->next;
         break;
       case 'i':
         /* import IMC handle */
         entry = malloc(sizeof *entry);
         if (NULL == entry) {
-          fprintf(stderr, "No memory for redirection queue\n");
+          NaClLog(1, "%s\n", "No memory for redirection queue");
           exit(1);
         }
         entry->next = NULL;
         entry->nacl_desc = strtol(optarg, &rest, 0);
         entry->tag = IMC_DESC;
-        entry->u.handle = (NaClHandle) strtol(rest+1, (char **) 0, 0);
+        entry->u.handle = (NaClHandle)strtol(rest + 1, NULL, 0);
         *redir_qend = entry;
         redir_qend = &entry->next;
         break;
       case 'l':
         log_file = optarg;
         break;
       case 'Q':
-        fprintf(stderr, "PLATFORM QUALIFICATION DISABLED BY -Q - "
+        NaClLog(1, "%s\n",
+                 "PLATFORM QUALIFICATION DISABLED BY -Q - "
                 "Native Client's sandbox will be unreliable!\n");
         skip_qualification = 1;
         break;
       case 'R':
         rpc_supplies_nexe = 1;
         break;
       /* case 'r':  with 'h' and 'w' above */
       case 's':
         if (nap->validator->stubout_mode_implemented) {
           nap->validator_stub_out_mode = 1;
-        } else {
-           NaClLog(LOG_WARNING,
-                   "stub_out_mode is not supported, disabled\n");
         }
+        else
+           NaClLog(1, "%s\n", "stub_out_mode is not supported, disabled");
         break;
       case 'S':
         handle_signals = 1;
         break;
       case 'v':
         ++verbosity;
         NaClLogIncrVerbosity();
         break;
       /* case 'w':  with 'h' and 'r' above */
       case 'X':
-        export_addr_to = strtol(optarg, (char **) 0, 0);
+        export_addr_to = strtol(optarg, NULL, 0);
         break;
-#if NACL_LINUX
       case 'z':
         NaClHandleReservedAtZero(optarg);
         break;
-#endif
       case 'Z':
         if (nap->validator->readonly_text_implemented) {
-          NaClLog(LOG_WARNING, "Enabling Fixed-Feature CPU Mode\n");
+          NaClLog(1, "%s\n", "Enabling Fixed-Feature CPU Mode");
           nap->fixed_feature_cpu_mode = 1;
           if (!nap->validator->FixCPUFeatures(nap->cpu_features)) {
-            NaClLog(LOG_ERROR,
-                    "This CPU lacks features required by "
-                    "fixed-function CPU mode.\n");
-            exit(1);
+            NaClLog(1, "%s\n", "This CPU lacks features required by fixed-function CPU mode.");
+            exit(EXIT_FAILURE);
           }
         } else {
-           NaClLog(LOG_ERROR,
-                   "fixed_feature_cpu_mode is not supported\n");
-           exit(1);
+           NaClLog(1, "%s\n", "fixed_feature_cpu_mode is not supported");
+           exit(EXIT_FAILURE);
         }
         break;
+
       default:
-        fprintf(stderr, "ERROR: unknown option: [%c]\n\n", opt);
+        NaClLog(1, "ERROR: unknown option: [%c]\n\n", opt);
         PrintUsage();
         exit(-1);
     }
   }
 
   if(!LindPythonInit()) {
       fflush(NULL);
-      exit(1);
+      exit(EXIT_FAILURE);
   }
 
-  if (debug_mode_ignore_validator == 1)
-    fprintf(stderr, "DEBUG MODE ENABLED (ignore validator)\n");
-  else if (debug_mode_ignore_validator > 1)
-    fprintf(stderr, "DEBUG MODE ENABLED (skip validator)\n");
+  if (debug_mode_ignore_validator == 1) {
+    NaClLog(1, "%s\n", "DEBUG MODE ENABLED (ignore validator)");
+  } else if (debug_mode_ignore_validator > 1) {
+    NaClLog(1, "%s\n", "DEBUG MODE ENABLED (skip validator)");
+  }
 
   if (verbosity) {
-    int         ix;
-    char const  *separator = "";
-
-    fprintf(stderr, "sel_ldr argument list:\n");
+    int        ix;
+    char const *separator = "";
+    (void)separator;
+    NaClLog(1, "%s", "sel_ldr argument list:");
     for (ix = 0; ix < argc; ++ix) {
-      fprintf(stderr, "%s%s", separator, argv[ix]);
+      NaClLog(1, "%s%s", separator, argv[ix]);
       separator = " ";
+      (void)separator;
     }
-    putc('\n', stderr);
+    NaClLog(1, "%s", "\n");
   }
 
   if (debug_mode_bypass_acl_checks) {
     NaClInsecurelyBypassAllAclChecks();
   }
@@ -435,77 +455,78 @@ int NaClSelLdrMain(int argc, char **argv) {
    * change stdout/stderr to log file now, so that subsequent error
    * messages will go there.  unfortunately, error messages that
    * result from getopt processing -- usually out-of-memory, which
    * shouldn't happen -- won't show up.
    */
-  if (NULL != log_file) {
+  if (log_file) {
     NaClLogSetFile(log_file);
   }
 
   if (rpc_supplies_nexe) {
-    if (NULL != nacl_file) {
-      fprintf(stderr,
-              "sel_ldr: mutually exclusive flags -f and -R both used\n");
-      exit(1);
+    if (nap->nacl_file) {
+      NaClLog(LOG_FATAL, "%s\n", "sel_ldr: mutually exclusive flags -f and -R both used");
     }
-    /* post: NULL == nacl_file */
+    /* post: NULL == nap->nacl_file */
     if (export_addr_to < 0) {
-      fprintf(stderr,
-              "sel_ldr: -R requires -X to set up secure command channel\n");
-      exit(1);
+      NaClLog(LOG_FATAL, "%s\n", "sel_ldr: -R requires -X to set up secure command channel");
     }
   } else {
-    if (NULL == nacl_file && optind < argc) {
-      nacl_file = argv[optind];
+    if (!nap->nacl_file && optind > argc) {
+      NaClLog(LOG_FATAL, "%s\n", "No nacl file specified");
+    }
+    /* post: NULL != nap->nacl_file */
+    if (!nap->nacl_file && optind < argc) {
+      nap->nacl_file = argv[optind];
       ++optind;
     }
-    if (NULL == nacl_file) {
-      fprintf(stderr, "No nacl file specified\n");
-      exit(1);
-    }
-    /* post: NULL != nacl_file */
   }
   /*
-   * post condition established by the above code (in Hoare logic
-   * terminology):
-   *
-   * NULL == nacl_file iff rpc_supplies_nexe
-   *
-   * so hence forth, testing !rpc_supplies_nexe suffices for
-   * establishing NULL != nacl_file.
+   * either nap->nacl_file or rpc_supplies_nexe
+   * must be non-NULL, but not both
    */
-  CHECK((NULL == nacl_file) == rpc_supplies_nexe);
+  CHECK(!!nap->nacl_file ^ !!rpc_supplies_nexe);
 
   /* to be passed to NaClMain, eventually... */
-  argv[--optind] = (char *) "NaClMain";
+  argv[--optind] = "NaClMain";
+  state.ignore_validator_result = debug_mode_ignore_validator > 0;
+  state.skip_validator = debug_mode_ignore_validator > 1;
 
-  state.ignore_validator_result = (debug_mode_ignore_validator > 0);
-  state.skip_validator = (debug_mode_ignore_validator > 1);
-
-  if (getenv("NACL_UNTRUSTED_EXCEPTION_HANDLING") != NULL) {
+/*
+ * `_HOST_OSX` is defined so that
+ * `if (... && _HOST_OSX)` expands
+ * to a valid conditional in when
+ * run through a linter
+ *
+ * -jp
+ */
+#if NACL_OSX
+# define _HOST_OSX 1
+#else
+# define _HOST_OSX 0
+#endif
+  if (getenv("NACL_UNTRUSTED_EXCEPTION_HANDLING")) {
     state.enable_exception_handling = 1;
   }
   /*
    * TODO(mseaborn): Always enable the Mach exception handler on Mac
    * OS X, and remove handle_signals and sel_ldr's "-S" option.
    */
-  if (state.enable_exception_handling || enable_debug_stub ||
-      (handle_signals && NACL_OSX)) {
+  if (state.enable_exception_handling || enable_debug_stub || (handle_signals && _HOST_OSX)) {
 #if NACL_WINDOWS
-    state.attach_debug_exception_handler_func =
-        NaClDebugExceptionHandlerStandaloneAttach;
+    state.attach_debug_exception_handler_func = NaClDebugExceptionHandlerStandaloneAttach;
 #elif NACL_LINUX
     /* NaCl's signal handler is always enabled on Linux. */
 #elif NACL_OSX
     if (!NaClInterceptMachExceptions()) {
-      fprintf(stderr, "ERROR setting up Mach exception interception.\n");
-      return -1;
+      NaClLog(1, "%s\n", "ERROR setting up Mach exception interception.");
+      exit(-1);
     }
 #else
 # error Unknown host OS
 #endif
   }
+#undef _HOST_OSX
 
   errcode = LOAD_OK;
 
   /*
    * in order to report load error to the browser plugin through the
@@ -519,26 +540,35 @@ int NaClSelLdrMain(int argc, char **argv) {
    * Ensure the platform qualification checks pass.
    *
    * NACL_DANGEROUS_SKIP_QUALIFICATION_TEST is used by tsan / memcheck
    * (see src/third_party/valgrind/).
    */
-  if (!skip_qualification &&
-      getenv("NACL_DANGEROUS_SKIP_QUALIFICATION_TEST") != NULL) {
-    fprintf(stderr, "PLATFORM QUALIFICATION DISABLED BY ENVIRONMENT - "
-            "Native Client's sandbox will be unreliable!\n");
+  if (!skip_qualification && getenv("NACL_DANGEROUS_SKIP_QUALIFICATION_TEST")) {
+    NaClLog(1, "%s\n",
+            "PLATFORM QUALIFICATION DISABLED BY ENVIRONMENT - "
+            "Native Client's sandbox will be unreliable!");
     skip_qualification = 1;
   }
 
   if (!skip_qualification) {
+    /*
+     * yiwen: temporarily skip this (caused gdb segmentation
+     * fault, the seg fault signal was ignored somehow when
+     * not running gdb.)
+     */
     NaClErrorCode pq_error = NACL_FI_VAL("pq", NaClErrorCode,
                                          NaClRunSelQualificationTests());
+
+    /*
+     * yiwen: temporarily define pq_error here, and assume that everything is Okay.
+     */
     if (LOAD_OK != pq_error) {
       errcode = pq_error;
       nap->module_load_status = pq_error;
-      fprintf(stderr, "Error while loading \"%s\": %s\n",
-              NULL != nacl_file ? nacl_file
-                                : "(no file, to-be-supplied-via-RPC)",
+      NaClLog(1, "%d: Error while loading \"%s\": %s\n",
+              __LINE__,
+              !nap->nacl_file ? nap->nacl_file : "(no file, to-be-supplied-via-RPC)",
               NaClErrorString(errcode));
     }
   }
 
 #if NACL_LINUX
@@ -547,60 +577,62 @@ int NaClSelLdrMain(int argc, char **argv) {
   /*
    * Patch the Windows exception dispatcher to be safe in the case of
    * faults inside x86-64 sandboxed code.  The sandbox is not secure
    * on 64-bit Windows without this.
    */
-#if (NACL_WINDOWS && NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 && \
-     NACL_BUILD_SUBARCH == 64)
+#if (NACL_WINDOWS && NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86 && NACL_BUILD_SUBARCH == 64)
   NaClPatchWindowsExceptionDispatcher();
 #endif
   NaClSignalTestCrashOnStartup();
 
   /*
    * Open both files first because (on Mac OS X at least)
    * NaClAppLoadFile() enables an outer sandbox.
    */
-  if (NULL != blob_library_file) {
+  if (blob_library_file) {
     NaClFileNameForValgrind(blob_library_file);
     blob_file = (struct NaClDesc *) NaClDescIoDescOpen(blob_library_file,
                                                        NACL_ABI_O_RDONLY, 0);
     if (NULL == blob_file) {
       perror("sel_main");
-      fprintf(stderr, "Cannot open \"%s\".\n", blob_library_file);
-      exit(1);
+      NaClLog(1, "Cannot open \"%s\".\n", blob_library_file);
+      exit(EXIT_FAILURE);
     }
     NaClPerfCounterMark(&time_all_main, "SnapshotBlob");
     NaClPerfCounterIntervalLast(&time_all_main);
   }
 
   NaClAppInitialDescriptorHookup(nap);
 
   if (!rpc_supplies_nexe) {
     if (LOAD_OK == errcode) {
-      NaClLog(2, "Loading nacl file %s (non-RPC)\n", nacl_file);
-      errcode = NaClAppLoadFileFromFilename(nap, nacl_file);
+      NaClLog(2, "Loading nacl file %s (non-RPC)\n", nap->nacl_file);
+      errcode = NaClAppLoadFileFromFilename(nap, nap->nacl_file);
+
       if (LOAD_OK != errcode) {
-        fprintf(stderr, "Error while loading \"%s\": %s\n",
-                nacl_file,
+        NaClLog(1, "%d: Error while loading \"%s\": %s\n",
+                __LINE__,
+                nap->nacl_file,
                 NaClErrorString(errcode));
         fprintf(stderr,
                 ("Using the wrong type of nexe (nacl-x86-32"
                  " on an x86-64 or vice versa)\n"
                  "or a corrupt nexe file may be"
                  " responsible for this error.\n"));
       }
+
       NaClPerfCounterMark(&time_all_main, "AppLoadEnd");
       NaClPerfCounterIntervalLast(&time_all_main);
 
       NaClXMutexLock(&nap->mu);
       nap->module_load_status = errcode;
       NaClXCondVarBroadcast(&nap->cv);
       NaClXMutexUnlock(&nap->mu);
     }
 
     if (fuzzing_quit_after_load) {
-      exit(0);
+      exit(EXIT_SUCCESS);
     }
   }
 
   /*
    * Execute additional I/O redirections.  NB: since the NaClApp
@@ -609,21 +641,22 @@ int NaClSelLdrMain(int argc, char **argv) {
    * them.  Currently a normal NaClApp process exit does not
    * close descriptors, since the underlying host OS will do so
    * as part of service runtime exit.
    */
   NaClLog(4, "Processing I/O redirection/inheritance from command line\n");
-  for (entry = redir_queue; NULL != entry; entry = entry->next) {
+  for (entry = redir_queue; entry && entry->next; entry = entry->next) {
     switch (entry->tag) {
       case HOST_DESC:
         NaClAddHostDescriptor(nap, entry->u.host.d,
                               entry->u.host.mode, entry->nacl_desc);
         break;
       case IMC_DESC:
         NaClAddImcHandle(nap, entry->u.handle, entry->nacl_desc);
         break;
     }
   }
+  free(entry);
 
   /*
    * If export_addr_to is set to a non-negative integer, we create a
    * bound socket and socket address pair and bind the former to
    * descriptor NACL_SERVICE_PORT_DESCRIPTOR (3 [see sel_ldr.h]) and
@@ -686,33 +719,45 @@ int NaClSelLdrMain(int argc, char **argv) {
        * (currently) a no-op.
        */
       errcode = NaClAppPrepareToLaunch(nap);
       if (LOAD_OK != errcode) {
         nap->module_load_status = errcode;
-        fprintf(stderr, "NaClAppPrepareToLaunch returned %d", errcode);
+        NaClLog(1, "NaClAppPrepareToLaunch returned %d", errcode);
       }
-      NaClPerfCounterMark(&time_all_main, "AppPrepLaunch");
-      NaClPerfCounterIntervalLast(&time_all_main);
     }
 
     /* Give debuggers a well known point at which xlate_base is known.  */
     NaClGdbHook(&state);
   }
 
+/*
+ * `_HOST_OSX` is defined so that
+ * `if (... && _HOST_OSX)` expands
+ * to a valid conditional in when
+ * run through a linter
+ *
+ * -jp
+ */
+#if NACL_OSX
+# define _HOST_OSX 1
+#else
+# define _HOST_OSX 0
+#endif
   /*
    * Tell the debug stub to bind a TCP port before enabling the outer
    * sandbox.  This is only needed on Mac OS X since that is the only
    * platform where we have an outer sandbox in standalone sel_ldr.
    * In principle this call should work on all platforms, but Windows
    * XP seems to have some problems when we do bind()/listen() on a
    * separate thread from accept().
    */
-  if (enable_debug_stub && NACL_OSX) {
+  if (enable_debug_stub && _HOST_OSX) {
     if (!NaClDebugBindSocket()) {
       exit(1);
     }
   }
+#undef _HOST_OSX
 
   /*
    * Enable the outer sandbox, if one is defined.  Do this as soon as
    * possible.
    *
@@ -722,25 +767,25 @@ int NaClSelLdrMain(int argc, char **argv) {
    * standalone sel_ldr when using a dynamic code area because it uses
    * NaClCreateMemoryObject() which opens a file in /tmp.
    *
    * We cannot enable the sandbox if file access is enabled.
    */
-  if (!NaClAclBypassChecks && g_enable_outer_sandbox_func != NULL) {
+  if (!NaClAclBypassChecks && g_enable_outer_sandbox_func) {
     g_enable_outer_sandbox_func();
   }
 
-  if (NULL != blob_library_file) {
+  if (blob_library_file) {
     if (nap->irt_loaded) {
-      NaClLog(LOG_INFO, "IRT loaded via command channel; ignoring -B irt\n");
+      NaClLog(1, "%s\n", "IRT loaded via command channel; ignoring -B irt");
     } else if (LOAD_OK == errcode) {
       NaClLog(2, "Loading blob file %s\n", blob_library_file);
       errcode = NaClAppLoadFileDynamically(nap, blob_file,
                                            NULL);
       if (LOAD_OK == errcode) {
         nap->irt_loaded = 1;
       } else {
-        fprintf(stderr, "Error while loading \"%s\": %s\n",
+        NaClLog(1, "%d: Error while loading \"%s\": %s\n", __LINE__,
                 blob_library_file,
                 NaClErrorString(errcode));
       }
       NaClPerfCounterMark(&time_all_main, "BlobLoaded");
       NaClPerfCounterIntervalLast(&time_all_main);
@@ -761,13 +806,13 @@ int NaClSelLdrMain(int argc, char **argv) {
 
   /*
    * Make sure all the file buffers are flushed before entering
    * the application code.
    */
-  fflush((FILE *) NULL);
+  fflush(NULL);
 
-  if (NULL != nap->secure_service) {
+  if (nap->secure_service) {
     NaClErrorCode start_result;
     /*
      * wait for start_module RPC call on secure channel thread.
      */
     start_result = NaClWaitForStartModuleCommand(nap);
@@ -788,44 +833,79 @@ int NaClSelLdrMain(int argc, char **argv) {
             errcode);
     goto done;
   }
 
   if (!DynArraySet(&env_vars, env_vars.num_entries, NULL)) {
-    NaClLog(LOG_FATAL, "Adding env_vars NULL terminator failed\n");
+    NaClLog(1, "%s\n", "Adding env_vars NULL terminator failed");
   }
 
   NaClEnvCleanserCtor(&env_cleanser, 0);
   if (!NaClEnvCleanserInit(&env_cleanser, envp,
           (char const *const *)env_vars.ptr_array)) {
-    NaClLog(LOG_FATAL, "Failed to initialise env cleanser\n");
+    NaClLog(1, "%s\n", "Failed to initialise env cleanser");
   }
 
   if (!NaClAppLaunchServiceThreads(nap)) {
-    fprintf(stderr, "Launch service threads failed\n");
+    NaClLog(1, "%s\n", "Launch service threads failed");
     goto done;
   }
   if (enable_debug_stub) {
     if (!NaClDebugInit(nap)) {
       goto done;
     }
   }
   NACL_TEST_INJECTION(BeforeMainThreadLaunches, ());
+  InitializeCage(nap, 1);
+
+  NaClLog(1, "[NaCl Main][Cage 1] argv[3]: %s \n\n", (argv + optind)[3]);
+  NaClLog(1, "[NaCl Main][Cage 1] argv[4]: %s \n\n", (argv + optind)[4]);
+  NaClLog(1, "[NaCl Main][Cage 1] argv num: %d \n\n", argc - optind);
+
+  nap->command_num = argc - optind - 3;
+  nap->binary_path = malloc(strlen((argv + optind)[3]) + 1);
+  strncpy(nap->binary_path, (argv + optind)[3], strlen((argv + optind)[3]) + 1);
+  if (nap->command_num > 1) {
+     nap->binary_command = malloc(strlen((argv + optind)[4]) + 1);
+     strncpy(nap->binary_command, (argv + optind)[4], strlen((argv + optind)[4]) + 1);
+  }
+
+  NaClLog(1, "nap->command_num = %d, nap->binary_path = %s\n", nap->command_num, nap->binary_path);
+
+  NaClLog(1, "%s\n", "Initializing pipe table mutexes/conditional variables.");
+  for (size_t i = 0; i < PIPE_NUM_MAX; i++) {
+    NaClXMutexCtor(&pipe_table[i].mu);
+    NaClXCondVarCtor(&pipe_table[i].cv);
+  }
+
+  // yiwen: this records the finishing time of the NaCl initialization / setup
+  nacl_initialization_finish = clock();
+
+  // yiwen: before the creation of the first cage
+  NaClLog(1, "%s\n\n", "[NaCl Main Loader] NaCl Loader: before creation of the cage to run user program!");
+
   if (!NaClCreateMainThread(nap,
                             argc - optind,
                             argv + optind,
                             NaClEnvCleanserEnvironment(&env_cleanser))) {
-    fprintf(stderr, "creating main thread failed\n");
-    goto done;
+     NaClLog(1, "%s\n", "creating main thread failed");
+     goto done;
   }
+  nacl_user_program_begin = clock();
 
+  // ***********************************************************************
+  // yiwen: cleanup and exit
+  // ***********************************************************************
   NaClEnvCleanserDtor(&env_cleanser);
 
   NaClPerfCounterMark(&time_all_main, "CreateMainThread");
   NaClPerfCounterIntervalLast(&time_all_main);
   DynArrayDtor(&env_vars);
 
+  // yiwen: waiting for running cages to exit
   ret_code = NaClWaitForMainThreadToExit(nap);
+  nacl_user_program_finish = clock();
+
   NaClPerfCounterMark(&time_all_main, "WaitForMainThread");
   NaClPerfCounterIntervalLast(&time_all_main);
 
   NaClPerfCounterMark(&time_all_main, "SelMainEnd");
   NaClPerfCounterIntervalTotal(&time_all_main);
@@ -834,24 +914,66 @@ int NaClSelLdrMain(int argc, char **argv) {
    * exit_group or equiv kills any still running threads while module
    * addr space is still valid.  otherwise we'd have to kill threads
    * before we clean up the address space.
    */
 
+  // yiwen: time measurement, record the finish time of the NaCl main program
+  nacl_main_finish = clock();
+
+  // yiwen: for evaluation measurement, we need to print out info here
+  NaClLog(1, "%s\n", "[NaClMain] End of the program! \n");
+
+  // calculate and print out time of running the NaCl main program
+  nacl_main_spent = (double)(nacl_main_finish - nacl_main_begin) / CLOCKS_PER_SEC;
+  NaClLog(1, "[NaClMain] NaCl main program time spent = %f \n", nacl_main_spent);
+
+  nacl_initialization_spent = (double)(nacl_initialization_finish - nacl_main_begin) / CLOCKS_PER_SEC;
+  NaClLog(1, "[NaClMain] NaCl initialization time spent = %f \n", nacl_initialization_spent);
+
+  nacl_user_program_spent = (double)(nacl_user_program_finish - nacl_user_program_begin) / CLOCKS_PER_SEC;
+  NaClLog(1, "[NaClMain] NaCl user program time spent = %f \n", nacl_user_program_spent);
+
+  #ifdef SYSCALL_TIMING
+  NaClLog(1, "%s\n", "[NaClMain] NaCl system call timing enabled! ");
+  NaClLog(1, "%s\n", "[NaClMain] Start printing out results now: ");
+  NaClLog(1, "[NaClMain] NaCl global system call counter = %d \n", nacl_syscall_counter);
+  NaClLog(1, "%s\n", "[NaClMain] Print out system call timing table: ");
+  nacl_syscall_total_time = 0.0;
+  for (size_t i = 0; i < NACL_MAX_SYSCALLS; i++) {
+    NaClLog(1, "sys_num: %d, invoked times: %d, execution time: %f \n", i, nacl_syscall_invoked_times[i], nacl_syscall_execution_time[i]);
+    nacl_syscall_total_time +=  nacl_syscall_execution_time[i];
+  }
+  NaClLog(1, "[NaClMain] NaCl system call total time: %f \n\n", nacl_syscall_total_time);
+
+  NaClLog(1, "[NaClMain] Lind system call counter = %d \n", lind_syscall_counter);
+  NaClLog(1, "%s\n", "[NaClMain] Print out Lind system call timing table: ");
+  lind_syscall_total_time = 0.0;
+  for (size_t i = 0; i < LIND_MAX_SYSCALLS; i++) {
+    NaClLog(1, "sys_num: %d, invoked times: %d, execution time: %f \n", i, lind_syscall_invoked_times[i], lind_syscall_execution_time[i]);
+    lind_syscall_total_time +=  lind_syscall_execution_time[i];
+  }
+  NaClLog(1, "[NaClMain] Lind system call total time: %f \n", lind_syscall_total_time);
+
+  NaClLog(1, "%s\n", "[NaClMain] Results printing out: done! ");
+  #endif
+
+  NaClLog(1, "[Performance results] LindPythonInit(): %f \n", time_counter);
+
   LindPythonFinalize();
 
   NaClExit(ret_code);
 
  done:
-  fflush(stdout);
+  fflush(NULL);
 
   if (verbosity) {
     gprintf((struct Gio *) &gout, "exiting -- printing NaClApp details\n");
     NaClAppPrintDetails(nap, (struct Gio *) &gout);
 
-    printf("Dumping vmmap.\n"); fflush(stdout);
+    printf("Dumping vmmap.\n"); fflush(NULL);
     PrintVmmap(nap);
-    fflush(stdout);
+    fflush(NULL);
   }
   /*
    * If there is a secure command channel, we sent an RPC reply with
    * the reason that the nexe was rejected.  If we exit now, that
    * reply may still be in-flight and the various channel closure (esp
@@ -861,25 +983,29 @@ int NaClSelLdrMain(int argc, char **argv) {
    */
   if (LOAD_OK != errcode) {
     NaClBlockIfCommandChannelExists(nap);
   }
 
-  if (verbosity > 0) {
-    printf("Done.\n");
-  }
-  fflush(stdout);
+  NaClLog(1, "%s\n", "Done.");
 
 #if NACL_LINUX
   NaClSignalHandlerFini();
 #endif
   NaClAllModulesFini();
 
   if(!LindPythonFinalize()) {
       fflush(NULL);
-      exit(1);
+      exit(EXIT_SUCCESS);
   }
 
   NaClExit(ret_code);
 
+  /* silence unused variable warnings */
+  UNREFERENCED_PARAMETER(nacl_main_spent);
+  UNREFERENCED_PARAMETER(nacl_initialization_spent);
+  UNREFERENCED_PARAMETER(nacl_user_program_begin);
+  UNREFERENCED_PARAMETER(nacl_user_program_finish);
+  UNREFERENCED_PARAMETER(nacl_user_program_spent);
+
   /* Unreachable, but having the return prevents a compiler error. */
   return ret_code;
 }
diff --git a/src/trusted/service_runtime/sel_memory.h b/src/trusted/service_runtime/sel_memory.h
index f74c3c5a864738681d..afb64ea59e9febf2eb 100644
--- a/src/trusted/service_runtime/sel_memory.h
+++ b/src/trusted/service_runtime/sel_memory.h
@@ -10,15 +10,18 @@
 
 #ifndef NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_SEL_MEMORY_H_
 #define NATIVE_CLIENT_SRC_TRUSTED_SERVICE_RUNTIME_SEL_MEMORY_H_ 1
 
 #include "native_client/src/include/nacl_compiler_annotations.h"
+#include <stdlib.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
 
+void *NaClPageAllocFlags(void **p, size_t size, int map_flags) NACL_WUR;
+
 int NaClPageAlloc(void **p, size_t num_bytes) NACL_WUR;
 
 int NaClPageAllocRandomized(void **p, size_t num_bytes) NACL_WUR;
 
 int NaClPageAllocAtAddr(void **p, size_t num_bytes) NACL_WUR;
-- 
Cheers,
Joey Pabalinas

